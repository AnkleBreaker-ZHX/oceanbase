// Generated by the gRPC C++ plugin.
// If you make any local change, they will be lost.
// source: newlogstorepb.proto

#include "newlogstorepb.pb.h"
#include "newlogstorepb.grpc.pb.h"

#include <functional>
#include <grpcpp/impl/codegen/async_stream.h>
#include <grpcpp/impl/codegen/async_unary_call.h>
#include <grpcpp/impl/codegen/channel_interface.h>
#include <grpcpp/impl/codegen/client_unary_call.h>
#include <grpcpp/impl/codegen/client_callback.h>
#include <grpcpp/impl/codegen/message_allocator.h>
#include <grpcpp/impl/codegen/method_handler.h>
#include <grpcpp/impl/codegen/rpc_service_method.h>
#include <grpcpp/impl/codegen/server_callback.h>
#include <grpcpp/impl/codegen/server_callback_handlers.h>
#include <grpcpp/impl/codegen/server_context.h>
#include <grpcpp/impl/codegen/service_type.h>
#include <grpcpp/impl/codegen/sync_stream.h>
namespace newlogstorepb {

static const char* NewLogStore_method_names[] = {
  "/newlogstorepb.NewLogStore/LoadLogStore",
  "/newlogstorepb.NewLogStore/Open",
  "/newlogstorepb.NewLogStore/Close",
  "/newlogstorepb.NewLogStore/Pwrite",
  "/newlogstorepb.NewLogStore/Pread",
  "/newlogstorepb.NewLogStore/Fallocate",
  "/newlogstorepb.NewLogStore/Ftruncate",
  "/newlogstorepb.NewLogStore/Scandir",
  "/newlogstorepb.NewLogStore/Unlink",
  "/newlogstorepb.NewLogStore/Mkdir",
  "/newlogstorepb.NewLogStore/Rmdir",
  "/newlogstorepb.NewLogStore/Stat",
  "/newlogstorepb.NewLogStore/Rename",
  "/newlogstorepb.NewLogStore/Fsync",
  "/newlogstorepb.NewLogStore/GetLogStoreInfo",
  "/newlogstorepb.NewLogStore/BatchFallocate",
};

std::unique_ptr< NewLogStore::Stub> NewLogStore::NewStub(const std::shared_ptr< ::grpc::ChannelInterface>& channel, const ::grpc::StubOptions& options) {
  (void)options;
  std::unique_ptr< NewLogStore::Stub> stub(new NewLogStore::Stub(channel, options));
  return stub;
}

NewLogStore::Stub::Stub(const std::shared_ptr< ::grpc::ChannelInterface>& channel, const ::grpc::StubOptions& options)
  : channel_(channel), rpcmethod_LoadLogStore_(NewLogStore_method_names[0], options.suffix_for_stats(),::grpc::internal::RpcMethod::NORMAL_RPC, channel)
  , rpcmethod_Open_(NewLogStore_method_names[1], options.suffix_for_stats(),::grpc::internal::RpcMethod::NORMAL_RPC, channel)
  , rpcmethod_Close_(NewLogStore_method_names[2], options.suffix_for_stats(),::grpc::internal::RpcMethod::NORMAL_RPC, channel)
  , rpcmethod_Pwrite_(NewLogStore_method_names[3], options.suffix_for_stats(),::grpc::internal::RpcMethod::NORMAL_RPC, channel)
  , rpcmethod_Pread_(NewLogStore_method_names[4], options.suffix_for_stats(),::grpc::internal::RpcMethod::NORMAL_RPC, channel)
  , rpcmethod_Fallocate_(NewLogStore_method_names[5], options.suffix_for_stats(),::grpc::internal::RpcMethod::NORMAL_RPC, channel)
  , rpcmethod_Ftruncate_(NewLogStore_method_names[6], options.suffix_for_stats(),::grpc::internal::RpcMethod::NORMAL_RPC, channel)
  , rpcmethod_Scandir_(NewLogStore_method_names[7], options.suffix_for_stats(),::grpc::internal::RpcMethod::NORMAL_RPC, channel)
  , rpcmethod_Unlink_(NewLogStore_method_names[8], options.suffix_for_stats(),::grpc::internal::RpcMethod::NORMAL_RPC, channel)
  , rpcmethod_Mkdir_(NewLogStore_method_names[9], options.suffix_for_stats(),::grpc::internal::RpcMethod::NORMAL_RPC, channel)
  , rpcmethod_Rmdir_(NewLogStore_method_names[10], options.suffix_for_stats(),::grpc::internal::RpcMethod::NORMAL_RPC, channel)
  , rpcmethod_Stat_(NewLogStore_method_names[11], options.suffix_for_stats(),::grpc::internal::RpcMethod::NORMAL_RPC, channel)
  , rpcmethod_Rename_(NewLogStore_method_names[12], options.suffix_for_stats(),::grpc::internal::RpcMethod::NORMAL_RPC, channel)
  , rpcmethod_Fsync_(NewLogStore_method_names[13], options.suffix_for_stats(),::grpc::internal::RpcMethod::NORMAL_RPC, channel)
  , rpcmethod_GetLogStoreInfo_(NewLogStore_method_names[14], options.suffix_for_stats(),::grpc::internal::RpcMethod::NORMAL_RPC, channel)
  , rpcmethod_BatchFallocate_(NewLogStore_method_names[15], options.suffix_for_stats(),::grpc::internal::RpcMethod::NORMAL_RPC, channel)
  {}

::grpc::Status NewLogStore::Stub::LoadLogStore(::grpc::ClientContext* context, const ::newlogstorepb::LoadLogStoreReq& request, ::newlogstorepb::LoadLogStoreResp* response) {
  return ::grpc::internal::BlockingUnaryCall< ::newlogstorepb::LoadLogStoreReq, ::newlogstorepb::LoadLogStoreResp, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(channel_.get(), rpcmethod_LoadLogStore_, context, request, response);
}

void NewLogStore::Stub::async::LoadLogStore(::grpc::ClientContext* context, const ::newlogstorepb::LoadLogStoreReq* request, ::newlogstorepb::LoadLogStoreResp* response, std::function<void(::grpc::Status)> f) {
  ::grpc::internal::CallbackUnaryCall< ::newlogstorepb::LoadLogStoreReq, ::newlogstorepb::LoadLogStoreResp, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(stub_->channel_.get(), stub_->rpcmethod_LoadLogStore_, context, request, response, std::move(f));
}

void NewLogStore::Stub::async::LoadLogStore(::grpc::ClientContext* context, const ::newlogstorepb::LoadLogStoreReq* request, ::newlogstorepb::LoadLogStoreResp* response, ::grpc::ClientUnaryReactor* reactor) {
  ::grpc::internal::ClientCallbackUnaryFactory::Create< ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(stub_->channel_.get(), stub_->rpcmethod_LoadLogStore_, context, request, response, reactor);
}

::grpc::ClientAsyncResponseReader< ::newlogstorepb::LoadLogStoreResp>* NewLogStore::Stub::PrepareAsyncLoadLogStoreRaw(::grpc::ClientContext* context, const ::newlogstorepb::LoadLogStoreReq& request, ::grpc::CompletionQueue* cq) {
  return ::grpc::internal::ClientAsyncResponseReaderHelper::Create< ::newlogstorepb::LoadLogStoreResp, ::newlogstorepb::LoadLogStoreReq, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(channel_.get(), cq, rpcmethod_LoadLogStore_, context, request);
}

::grpc::ClientAsyncResponseReader< ::newlogstorepb::LoadLogStoreResp>* NewLogStore::Stub::AsyncLoadLogStoreRaw(::grpc::ClientContext* context, const ::newlogstorepb::LoadLogStoreReq& request, ::grpc::CompletionQueue* cq) {
  auto* result =
    this->PrepareAsyncLoadLogStoreRaw(context, request, cq);
  result->StartCall();
  return result;
}

::grpc::Status NewLogStore::Stub::Open(::grpc::ClientContext* context, const ::newlogstorepb::OpenReq& request, ::newlogstorepb::OpenResp* response) {
  return ::grpc::internal::BlockingUnaryCall< ::newlogstorepb::OpenReq, ::newlogstorepb::OpenResp, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(channel_.get(), rpcmethod_Open_, context, request, response);
}

void NewLogStore::Stub::async::Open(::grpc::ClientContext* context, const ::newlogstorepb::OpenReq* request, ::newlogstorepb::OpenResp* response, std::function<void(::grpc::Status)> f) {
  ::grpc::internal::CallbackUnaryCall< ::newlogstorepb::OpenReq, ::newlogstorepb::OpenResp, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(stub_->channel_.get(), stub_->rpcmethod_Open_, context, request, response, std::move(f));
}

void NewLogStore::Stub::async::Open(::grpc::ClientContext* context, const ::newlogstorepb::OpenReq* request, ::newlogstorepb::OpenResp* response, ::grpc::ClientUnaryReactor* reactor) {
  ::grpc::internal::ClientCallbackUnaryFactory::Create< ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(stub_->channel_.get(), stub_->rpcmethod_Open_, context, request, response, reactor);
}

::grpc::ClientAsyncResponseReader< ::newlogstorepb::OpenResp>* NewLogStore::Stub::PrepareAsyncOpenRaw(::grpc::ClientContext* context, const ::newlogstorepb::OpenReq& request, ::grpc::CompletionQueue* cq) {
  return ::grpc::internal::ClientAsyncResponseReaderHelper::Create< ::newlogstorepb::OpenResp, ::newlogstorepb::OpenReq, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(channel_.get(), cq, rpcmethod_Open_, context, request);
}

::grpc::ClientAsyncResponseReader< ::newlogstorepb::OpenResp>* NewLogStore::Stub::AsyncOpenRaw(::grpc::ClientContext* context, const ::newlogstorepb::OpenReq& request, ::grpc::CompletionQueue* cq) {
  auto* result =
    this->PrepareAsyncOpenRaw(context, request, cq);
  result->StartCall();
  return result;
}

::grpc::Status NewLogStore::Stub::Close(::grpc::ClientContext* context, const ::newlogstorepb::CloseReq& request, ::newlogstorepb::CloseResp* response) {
  return ::grpc::internal::BlockingUnaryCall< ::newlogstorepb::CloseReq, ::newlogstorepb::CloseResp, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(channel_.get(), rpcmethod_Close_, context, request, response);
}

void NewLogStore::Stub::async::Close(::grpc::ClientContext* context, const ::newlogstorepb::CloseReq* request, ::newlogstorepb::CloseResp* response, std::function<void(::grpc::Status)> f) {
  ::grpc::internal::CallbackUnaryCall< ::newlogstorepb::CloseReq, ::newlogstorepb::CloseResp, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(stub_->channel_.get(), stub_->rpcmethod_Close_, context, request, response, std::move(f));
}

void NewLogStore::Stub::async::Close(::grpc::ClientContext* context, const ::newlogstorepb::CloseReq* request, ::newlogstorepb::CloseResp* response, ::grpc::ClientUnaryReactor* reactor) {
  ::grpc::internal::ClientCallbackUnaryFactory::Create< ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(stub_->channel_.get(), stub_->rpcmethod_Close_, context, request, response, reactor);
}

::grpc::ClientAsyncResponseReader< ::newlogstorepb::CloseResp>* NewLogStore::Stub::PrepareAsyncCloseRaw(::grpc::ClientContext* context, const ::newlogstorepb::CloseReq& request, ::grpc::CompletionQueue* cq) {
  return ::grpc::internal::ClientAsyncResponseReaderHelper::Create< ::newlogstorepb::CloseResp, ::newlogstorepb::CloseReq, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(channel_.get(), cq, rpcmethod_Close_, context, request);
}

::grpc::ClientAsyncResponseReader< ::newlogstorepb::CloseResp>* NewLogStore::Stub::AsyncCloseRaw(::grpc::ClientContext* context, const ::newlogstorepb::CloseReq& request, ::grpc::CompletionQueue* cq) {
  auto* result =
    this->PrepareAsyncCloseRaw(context, request, cq);
  result->StartCall();
  return result;
}

::grpc::Status NewLogStore::Stub::Pwrite(::grpc::ClientContext* context, const ::newlogstorepb::PwriteReq& request, ::newlogstorepb::PwriteResp* response) {
  return ::grpc::internal::BlockingUnaryCall< ::newlogstorepb::PwriteReq, ::newlogstorepb::PwriteResp, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(channel_.get(), rpcmethod_Pwrite_, context, request, response);
}

void NewLogStore::Stub::async::Pwrite(::grpc::ClientContext* context, const ::newlogstorepb::PwriteReq* request, ::newlogstorepb::PwriteResp* response, std::function<void(::grpc::Status)> f) {
  ::grpc::internal::CallbackUnaryCall< ::newlogstorepb::PwriteReq, ::newlogstorepb::PwriteResp, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(stub_->channel_.get(), stub_->rpcmethod_Pwrite_, context, request, response, std::move(f));
}

void NewLogStore::Stub::async::Pwrite(::grpc::ClientContext* context, const ::newlogstorepb::PwriteReq* request, ::newlogstorepb::PwriteResp* response, ::grpc::ClientUnaryReactor* reactor) {
  ::grpc::internal::ClientCallbackUnaryFactory::Create< ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(stub_->channel_.get(), stub_->rpcmethod_Pwrite_, context, request, response, reactor);
}

::grpc::ClientAsyncResponseReader< ::newlogstorepb::PwriteResp>* NewLogStore::Stub::PrepareAsyncPwriteRaw(::grpc::ClientContext* context, const ::newlogstorepb::PwriteReq& request, ::grpc::CompletionQueue* cq) {
  return ::grpc::internal::ClientAsyncResponseReaderHelper::Create< ::newlogstorepb::PwriteResp, ::newlogstorepb::PwriteReq, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(channel_.get(), cq, rpcmethod_Pwrite_, context, request);
}

::grpc::ClientAsyncResponseReader< ::newlogstorepb::PwriteResp>* NewLogStore::Stub::AsyncPwriteRaw(::grpc::ClientContext* context, const ::newlogstorepb::PwriteReq& request, ::grpc::CompletionQueue* cq) {
  auto* result =
    this->PrepareAsyncPwriteRaw(context, request, cq);
  result->StartCall();
  return result;
}

::grpc::Status NewLogStore::Stub::Pread(::grpc::ClientContext* context, const ::newlogstorepb::PreadReq& request, ::newlogstorepb::PreadResp* response) {
  return ::grpc::internal::BlockingUnaryCall< ::newlogstorepb::PreadReq, ::newlogstorepb::PreadResp, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(channel_.get(), rpcmethod_Pread_, context, request, response);
}

void NewLogStore::Stub::async::Pread(::grpc::ClientContext* context, const ::newlogstorepb::PreadReq* request, ::newlogstorepb::PreadResp* response, std::function<void(::grpc::Status)> f) {
  ::grpc::internal::CallbackUnaryCall< ::newlogstorepb::PreadReq, ::newlogstorepb::PreadResp, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(stub_->channel_.get(), stub_->rpcmethod_Pread_, context, request, response, std::move(f));
}

void NewLogStore::Stub::async::Pread(::grpc::ClientContext* context, const ::newlogstorepb::PreadReq* request, ::newlogstorepb::PreadResp* response, ::grpc::ClientUnaryReactor* reactor) {
  ::grpc::internal::ClientCallbackUnaryFactory::Create< ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(stub_->channel_.get(), stub_->rpcmethod_Pread_, context, request, response, reactor);
}

::grpc::ClientAsyncResponseReader< ::newlogstorepb::PreadResp>* NewLogStore::Stub::PrepareAsyncPreadRaw(::grpc::ClientContext* context, const ::newlogstorepb::PreadReq& request, ::grpc::CompletionQueue* cq) {
  return ::grpc::internal::ClientAsyncResponseReaderHelper::Create< ::newlogstorepb::PreadResp, ::newlogstorepb::PreadReq, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(channel_.get(), cq, rpcmethod_Pread_, context, request);
}

::grpc::ClientAsyncResponseReader< ::newlogstorepb::PreadResp>* NewLogStore::Stub::AsyncPreadRaw(::grpc::ClientContext* context, const ::newlogstorepb::PreadReq& request, ::grpc::CompletionQueue* cq) {
  auto* result =
    this->PrepareAsyncPreadRaw(context, request, cq);
  result->StartCall();
  return result;
}

::grpc::Status NewLogStore::Stub::Fallocate(::grpc::ClientContext* context, const ::newlogstorepb::FallocateReq& request, ::newlogstorepb::FallocateResp* response) {
  return ::grpc::internal::BlockingUnaryCall< ::newlogstorepb::FallocateReq, ::newlogstorepb::FallocateResp, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(channel_.get(), rpcmethod_Fallocate_, context, request, response);
}

void NewLogStore::Stub::async::Fallocate(::grpc::ClientContext* context, const ::newlogstorepb::FallocateReq* request, ::newlogstorepb::FallocateResp* response, std::function<void(::grpc::Status)> f) {
  ::grpc::internal::CallbackUnaryCall< ::newlogstorepb::FallocateReq, ::newlogstorepb::FallocateResp, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(stub_->channel_.get(), stub_->rpcmethod_Fallocate_, context, request, response, std::move(f));
}

void NewLogStore::Stub::async::Fallocate(::grpc::ClientContext* context, const ::newlogstorepb::FallocateReq* request, ::newlogstorepb::FallocateResp* response, ::grpc::ClientUnaryReactor* reactor) {
  ::grpc::internal::ClientCallbackUnaryFactory::Create< ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(stub_->channel_.get(), stub_->rpcmethod_Fallocate_, context, request, response, reactor);
}

::grpc::ClientAsyncResponseReader< ::newlogstorepb::FallocateResp>* NewLogStore::Stub::PrepareAsyncFallocateRaw(::grpc::ClientContext* context, const ::newlogstorepb::FallocateReq& request, ::grpc::CompletionQueue* cq) {
  return ::grpc::internal::ClientAsyncResponseReaderHelper::Create< ::newlogstorepb::FallocateResp, ::newlogstorepb::FallocateReq, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(channel_.get(), cq, rpcmethod_Fallocate_, context, request);
}

::grpc::ClientAsyncResponseReader< ::newlogstorepb::FallocateResp>* NewLogStore::Stub::AsyncFallocateRaw(::grpc::ClientContext* context, const ::newlogstorepb::FallocateReq& request, ::grpc::CompletionQueue* cq) {
  auto* result =
    this->PrepareAsyncFallocateRaw(context, request, cq);
  result->StartCall();
  return result;
}

::grpc::Status NewLogStore::Stub::Ftruncate(::grpc::ClientContext* context, const ::newlogstorepb::FtruncateReq& request, ::newlogstorepb::FtruncateResp* response) {
  return ::grpc::internal::BlockingUnaryCall< ::newlogstorepb::FtruncateReq, ::newlogstorepb::FtruncateResp, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(channel_.get(), rpcmethod_Ftruncate_, context, request, response);
}

void NewLogStore::Stub::async::Ftruncate(::grpc::ClientContext* context, const ::newlogstorepb::FtruncateReq* request, ::newlogstorepb::FtruncateResp* response, std::function<void(::grpc::Status)> f) {
  ::grpc::internal::CallbackUnaryCall< ::newlogstorepb::FtruncateReq, ::newlogstorepb::FtruncateResp, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(stub_->channel_.get(), stub_->rpcmethod_Ftruncate_, context, request, response, std::move(f));
}

void NewLogStore::Stub::async::Ftruncate(::grpc::ClientContext* context, const ::newlogstorepb::FtruncateReq* request, ::newlogstorepb::FtruncateResp* response, ::grpc::ClientUnaryReactor* reactor) {
  ::grpc::internal::ClientCallbackUnaryFactory::Create< ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(stub_->channel_.get(), stub_->rpcmethod_Ftruncate_, context, request, response, reactor);
}

::grpc::ClientAsyncResponseReader< ::newlogstorepb::FtruncateResp>* NewLogStore::Stub::PrepareAsyncFtruncateRaw(::grpc::ClientContext* context, const ::newlogstorepb::FtruncateReq& request, ::grpc::CompletionQueue* cq) {
  return ::grpc::internal::ClientAsyncResponseReaderHelper::Create< ::newlogstorepb::FtruncateResp, ::newlogstorepb::FtruncateReq, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(channel_.get(), cq, rpcmethod_Ftruncate_, context, request);
}

::grpc::ClientAsyncResponseReader< ::newlogstorepb::FtruncateResp>* NewLogStore::Stub::AsyncFtruncateRaw(::grpc::ClientContext* context, const ::newlogstorepb::FtruncateReq& request, ::grpc::CompletionQueue* cq) {
  auto* result =
    this->PrepareAsyncFtruncateRaw(context, request, cq);
  result->StartCall();
  return result;
}

::grpc::Status NewLogStore::Stub::Scandir(::grpc::ClientContext* context, const ::newlogstorepb::ScanDirReq& request, ::newlogstorepb::ScanDirResp* response) {
  return ::grpc::internal::BlockingUnaryCall< ::newlogstorepb::ScanDirReq, ::newlogstorepb::ScanDirResp, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(channel_.get(), rpcmethod_Scandir_, context, request, response);
}

void NewLogStore::Stub::async::Scandir(::grpc::ClientContext* context, const ::newlogstorepb::ScanDirReq* request, ::newlogstorepb::ScanDirResp* response, std::function<void(::grpc::Status)> f) {
  ::grpc::internal::CallbackUnaryCall< ::newlogstorepb::ScanDirReq, ::newlogstorepb::ScanDirResp, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(stub_->channel_.get(), stub_->rpcmethod_Scandir_, context, request, response, std::move(f));
}

void NewLogStore::Stub::async::Scandir(::grpc::ClientContext* context, const ::newlogstorepb::ScanDirReq* request, ::newlogstorepb::ScanDirResp* response, ::grpc::ClientUnaryReactor* reactor) {
  ::grpc::internal::ClientCallbackUnaryFactory::Create< ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(stub_->channel_.get(), stub_->rpcmethod_Scandir_, context, request, response, reactor);
}

::grpc::ClientAsyncResponseReader< ::newlogstorepb::ScanDirResp>* NewLogStore::Stub::PrepareAsyncScandirRaw(::grpc::ClientContext* context, const ::newlogstorepb::ScanDirReq& request, ::grpc::CompletionQueue* cq) {
  return ::grpc::internal::ClientAsyncResponseReaderHelper::Create< ::newlogstorepb::ScanDirResp, ::newlogstorepb::ScanDirReq, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(channel_.get(), cq, rpcmethod_Scandir_, context, request);
}

::grpc::ClientAsyncResponseReader< ::newlogstorepb::ScanDirResp>* NewLogStore::Stub::AsyncScandirRaw(::grpc::ClientContext* context, const ::newlogstorepb::ScanDirReq& request, ::grpc::CompletionQueue* cq) {
  auto* result =
    this->PrepareAsyncScandirRaw(context, request, cq);
  result->StartCall();
  return result;
}

::grpc::Status NewLogStore::Stub::Unlink(::grpc::ClientContext* context, const ::newlogstorepb::UnlinkReq& request, ::newlogstorepb::UnlinkResp* response) {
  return ::grpc::internal::BlockingUnaryCall< ::newlogstorepb::UnlinkReq, ::newlogstorepb::UnlinkResp, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(channel_.get(), rpcmethod_Unlink_, context, request, response);
}

void NewLogStore::Stub::async::Unlink(::grpc::ClientContext* context, const ::newlogstorepb::UnlinkReq* request, ::newlogstorepb::UnlinkResp* response, std::function<void(::grpc::Status)> f) {
  ::grpc::internal::CallbackUnaryCall< ::newlogstorepb::UnlinkReq, ::newlogstorepb::UnlinkResp, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(stub_->channel_.get(), stub_->rpcmethod_Unlink_, context, request, response, std::move(f));
}

void NewLogStore::Stub::async::Unlink(::grpc::ClientContext* context, const ::newlogstorepb::UnlinkReq* request, ::newlogstorepb::UnlinkResp* response, ::grpc::ClientUnaryReactor* reactor) {
  ::grpc::internal::ClientCallbackUnaryFactory::Create< ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(stub_->channel_.get(), stub_->rpcmethod_Unlink_, context, request, response, reactor);
}

::grpc::ClientAsyncResponseReader< ::newlogstorepb::UnlinkResp>* NewLogStore::Stub::PrepareAsyncUnlinkRaw(::grpc::ClientContext* context, const ::newlogstorepb::UnlinkReq& request, ::grpc::CompletionQueue* cq) {
  return ::grpc::internal::ClientAsyncResponseReaderHelper::Create< ::newlogstorepb::UnlinkResp, ::newlogstorepb::UnlinkReq, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(channel_.get(), cq, rpcmethod_Unlink_, context, request);
}

::grpc::ClientAsyncResponseReader< ::newlogstorepb::UnlinkResp>* NewLogStore::Stub::AsyncUnlinkRaw(::grpc::ClientContext* context, const ::newlogstorepb::UnlinkReq& request, ::grpc::CompletionQueue* cq) {
  auto* result =
    this->PrepareAsyncUnlinkRaw(context, request, cq);
  result->StartCall();
  return result;
}

::grpc::Status NewLogStore::Stub::Mkdir(::grpc::ClientContext* context, const ::newlogstorepb::MkdirReq& request, ::newlogstorepb::MkdirResp* response) {
  return ::grpc::internal::BlockingUnaryCall< ::newlogstorepb::MkdirReq, ::newlogstorepb::MkdirResp, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(channel_.get(), rpcmethod_Mkdir_, context, request, response);
}

void NewLogStore::Stub::async::Mkdir(::grpc::ClientContext* context, const ::newlogstorepb::MkdirReq* request, ::newlogstorepb::MkdirResp* response, std::function<void(::grpc::Status)> f) {
  ::grpc::internal::CallbackUnaryCall< ::newlogstorepb::MkdirReq, ::newlogstorepb::MkdirResp, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(stub_->channel_.get(), stub_->rpcmethod_Mkdir_, context, request, response, std::move(f));
}

void NewLogStore::Stub::async::Mkdir(::grpc::ClientContext* context, const ::newlogstorepb::MkdirReq* request, ::newlogstorepb::MkdirResp* response, ::grpc::ClientUnaryReactor* reactor) {
  ::grpc::internal::ClientCallbackUnaryFactory::Create< ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(stub_->channel_.get(), stub_->rpcmethod_Mkdir_, context, request, response, reactor);
}

::grpc::ClientAsyncResponseReader< ::newlogstorepb::MkdirResp>* NewLogStore::Stub::PrepareAsyncMkdirRaw(::grpc::ClientContext* context, const ::newlogstorepb::MkdirReq& request, ::grpc::CompletionQueue* cq) {
  return ::grpc::internal::ClientAsyncResponseReaderHelper::Create< ::newlogstorepb::MkdirResp, ::newlogstorepb::MkdirReq, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(channel_.get(), cq, rpcmethod_Mkdir_, context, request);
}

::grpc::ClientAsyncResponseReader< ::newlogstorepb::MkdirResp>* NewLogStore::Stub::AsyncMkdirRaw(::grpc::ClientContext* context, const ::newlogstorepb::MkdirReq& request, ::grpc::CompletionQueue* cq) {
  auto* result =
    this->PrepareAsyncMkdirRaw(context, request, cq);
  result->StartCall();
  return result;
}

::grpc::Status NewLogStore::Stub::Rmdir(::grpc::ClientContext* context, const ::newlogstorepb::RmdirReq& request, ::newlogstorepb::RmdirResp* response) {
  return ::grpc::internal::BlockingUnaryCall< ::newlogstorepb::RmdirReq, ::newlogstorepb::RmdirResp, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(channel_.get(), rpcmethod_Rmdir_, context, request, response);
}

void NewLogStore::Stub::async::Rmdir(::grpc::ClientContext* context, const ::newlogstorepb::RmdirReq* request, ::newlogstorepb::RmdirResp* response, std::function<void(::grpc::Status)> f) {
  ::grpc::internal::CallbackUnaryCall< ::newlogstorepb::RmdirReq, ::newlogstorepb::RmdirResp, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(stub_->channel_.get(), stub_->rpcmethod_Rmdir_, context, request, response, std::move(f));
}

void NewLogStore::Stub::async::Rmdir(::grpc::ClientContext* context, const ::newlogstorepb::RmdirReq* request, ::newlogstorepb::RmdirResp* response, ::grpc::ClientUnaryReactor* reactor) {
  ::grpc::internal::ClientCallbackUnaryFactory::Create< ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(stub_->channel_.get(), stub_->rpcmethod_Rmdir_, context, request, response, reactor);
}

::grpc::ClientAsyncResponseReader< ::newlogstorepb::RmdirResp>* NewLogStore::Stub::PrepareAsyncRmdirRaw(::grpc::ClientContext* context, const ::newlogstorepb::RmdirReq& request, ::grpc::CompletionQueue* cq) {
  return ::grpc::internal::ClientAsyncResponseReaderHelper::Create< ::newlogstorepb::RmdirResp, ::newlogstorepb::RmdirReq, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(channel_.get(), cq, rpcmethod_Rmdir_, context, request);
}

::grpc::ClientAsyncResponseReader< ::newlogstorepb::RmdirResp>* NewLogStore::Stub::AsyncRmdirRaw(::grpc::ClientContext* context, const ::newlogstorepb::RmdirReq& request, ::grpc::CompletionQueue* cq) {
  auto* result =
    this->PrepareAsyncRmdirRaw(context, request, cq);
  result->StartCall();
  return result;
}

::grpc::Status NewLogStore::Stub::Stat(::grpc::ClientContext* context, const ::newlogstorepb::StatReq& request, ::newlogstorepb::StatResp* response) {
  return ::grpc::internal::BlockingUnaryCall< ::newlogstorepb::StatReq, ::newlogstorepb::StatResp, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(channel_.get(), rpcmethod_Stat_, context, request, response);
}

void NewLogStore::Stub::async::Stat(::grpc::ClientContext* context, const ::newlogstorepb::StatReq* request, ::newlogstorepb::StatResp* response, std::function<void(::grpc::Status)> f) {
  ::grpc::internal::CallbackUnaryCall< ::newlogstorepb::StatReq, ::newlogstorepb::StatResp, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(stub_->channel_.get(), stub_->rpcmethod_Stat_, context, request, response, std::move(f));
}

void NewLogStore::Stub::async::Stat(::grpc::ClientContext* context, const ::newlogstorepb::StatReq* request, ::newlogstorepb::StatResp* response, ::grpc::ClientUnaryReactor* reactor) {
  ::grpc::internal::ClientCallbackUnaryFactory::Create< ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(stub_->channel_.get(), stub_->rpcmethod_Stat_, context, request, response, reactor);
}

::grpc::ClientAsyncResponseReader< ::newlogstorepb::StatResp>* NewLogStore::Stub::PrepareAsyncStatRaw(::grpc::ClientContext* context, const ::newlogstorepb::StatReq& request, ::grpc::CompletionQueue* cq) {
  return ::grpc::internal::ClientAsyncResponseReaderHelper::Create< ::newlogstorepb::StatResp, ::newlogstorepb::StatReq, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(channel_.get(), cq, rpcmethod_Stat_, context, request);
}

::grpc::ClientAsyncResponseReader< ::newlogstorepb::StatResp>* NewLogStore::Stub::AsyncStatRaw(::grpc::ClientContext* context, const ::newlogstorepb::StatReq& request, ::grpc::CompletionQueue* cq) {
  auto* result =
    this->PrepareAsyncStatRaw(context, request, cq);
  result->StartCall();
  return result;
}

::grpc::Status NewLogStore::Stub::Rename(::grpc::ClientContext* context, const ::newlogstorepb::RenameReq& request, ::newlogstorepb::RenameResp* response) {
  return ::grpc::internal::BlockingUnaryCall< ::newlogstorepb::RenameReq, ::newlogstorepb::RenameResp, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(channel_.get(), rpcmethod_Rename_, context, request, response);
}

void NewLogStore::Stub::async::Rename(::grpc::ClientContext* context, const ::newlogstorepb::RenameReq* request, ::newlogstorepb::RenameResp* response, std::function<void(::grpc::Status)> f) {
  ::grpc::internal::CallbackUnaryCall< ::newlogstorepb::RenameReq, ::newlogstorepb::RenameResp, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(stub_->channel_.get(), stub_->rpcmethod_Rename_, context, request, response, std::move(f));
}

void NewLogStore::Stub::async::Rename(::grpc::ClientContext* context, const ::newlogstorepb::RenameReq* request, ::newlogstorepb::RenameResp* response, ::grpc::ClientUnaryReactor* reactor) {
  ::grpc::internal::ClientCallbackUnaryFactory::Create< ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(stub_->channel_.get(), stub_->rpcmethod_Rename_, context, request, response, reactor);
}

::grpc::ClientAsyncResponseReader< ::newlogstorepb::RenameResp>* NewLogStore::Stub::PrepareAsyncRenameRaw(::grpc::ClientContext* context, const ::newlogstorepb::RenameReq& request, ::grpc::CompletionQueue* cq) {
  return ::grpc::internal::ClientAsyncResponseReaderHelper::Create< ::newlogstorepb::RenameResp, ::newlogstorepb::RenameReq, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(channel_.get(), cq, rpcmethod_Rename_, context, request);
}

::grpc::ClientAsyncResponseReader< ::newlogstorepb::RenameResp>* NewLogStore::Stub::AsyncRenameRaw(::grpc::ClientContext* context, const ::newlogstorepb::RenameReq& request, ::grpc::CompletionQueue* cq) {
  auto* result =
    this->PrepareAsyncRenameRaw(context, request, cq);
  result->StartCall();
  return result;
}

::grpc::Status NewLogStore::Stub::Fsync(::grpc::ClientContext* context, const ::newlogstorepb::FsyncReq& request, ::newlogstorepb::FsyncResp* response) {
  return ::grpc::internal::BlockingUnaryCall< ::newlogstorepb::FsyncReq, ::newlogstorepb::FsyncResp, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(channel_.get(), rpcmethod_Fsync_, context, request, response);
}

void NewLogStore::Stub::async::Fsync(::grpc::ClientContext* context, const ::newlogstorepb::FsyncReq* request, ::newlogstorepb::FsyncResp* response, std::function<void(::grpc::Status)> f) {
  ::grpc::internal::CallbackUnaryCall< ::newlogstorepb::FsyncReq, ::newlogstorepb::FsyncResp, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(stub_->channel_.get(), stub_->rpcmethod_Fsync_, context, request, response, std::move(f));
}

void NewLogStore::Stub::async::Fsync(::grpc::ClientContext* context, const ::newlogstorepb::FsyncReq* request, ::newlogstorepb::FsyncResp* response, ::grpc::ClientUnaryReactor* reactor) {
  ::grpc::internal::ClientCallbackUnaryFactory::Create< ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(stub_->channel_.get(), stub_->rpcmethod_Fsync_, context, request, response, reactor);
}

::grpc::ClientAsyncResponseReader< ::newlogstorepb::FsyncResp>* NewLogStore::Stub::PrepareAsyncFsyncRaw(::grpc::ClientContext* context, const ::newlogstorepb::FsyncReq& request, ::grpc::CompletionQueue* cq) {
  return ::grpc::internal::ClientAsyncResponseReaderHelper::Create< ::newlogstorepb::FsyncResp, ::newlogstorepb::FsyncReq, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(channel_.get(), cq, rpcmethod_Fsync_, context, request);
}

::grpc::ClientAsyncResponseReader< ::newlogstorepb::FsyncResp>* NewLogStore::Stub::AsyncFsyncRaw(::grpc::ClientContext* context, const ::newlogstorepb::FsyncReq& request, ::grpc::CompletionQueue* cq) {
  auto* result =
    this->PrepareAsyncFsyncRaw(context, request, cq);
  result->StartCall();
  return result;
}

::grpc::Status NewLogStore::Stub::GetLogStoreInfo(::grpc::ClientContext* context, const ::newlogstorepb::GetLogStoreInfoReq& request, ::newlogstorepb::GetLogStoreInfoResp* response) {
  return ::grpc::internal::BlockingUnaryCall< ::newlogstorepb::GetLogStoreInfoReq, ::newlogstorepb::GetLogStoreInfoResp, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(channel_.get(), rpcmethod_GetLogStoreInfo_, context, request, response);
}

void NewLogStore::Stub::async::GetLogStoreInfo(::grpc::ClientContext* context, const ::newlogstorepb::GetLogStoreInfoReq* request, ::newlogstorepb::GetLogStoreInfoResp* response, std::function<void(::grpc::Status)> f) {
  ::grpc::internal::CallbackUnaryCall< ::newlogstorepb::GetLogStoreInfoReq, ::newlogstorepb::GetLogStoreInfoResp, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(stub_->channel_.get(), stub_->rpcmethod_GetLogStoreInfo_, context, request, response, std::move(f));
}

void NewLogStore::Stub::async::GetLogStoreInfo(::grpc::ClientContext* context, const ::newlogstorepb::GetLogStoreInfoReq* request, ::newlogstorepb::GetLogStoreInfoResp* response, ::grpc::ClientUnaryReactor* reactor) {
  ::grpc::internal::ClientCallbackUnaryFactory::Create< ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(stub_->channel_.get(), stub_->rpcmethod_GetLogStoreInfo_, context, request, response, reactor);
}

::grpc::ClientAsyncResponseReader< ::newlogstorepb::GetLogStoreInfoResp>* NewLogStore::Stub::PrepareAsyncGetLogStoreInfoRaw(::grpc::ClientContext* context, const ::newlogstorepb::GetLogStoreInfoReq& request, ::grpc::CompletionQueue* cq) {
  return ::grpc::internal::ClientAsyncResponseReaderHelper::Create< ::newlogstorepb::GetLogStoreInfoResp, ::newlogstorepb::GetLogStoreInfoReq, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(channel_.get(), cq, rpcmethod_GetLogStoreInfo_, context, request);
}

::grpc::ClientAsyncResponseReader< ::newlogstorepb::GetLogStoreInfoResp>* NewLogStore::Stub::AsyncGetLogStoreInfoRaw(::grpc::ClientContext* context, const ::newlogstorepb::GetLogStoreInfoReq& request, ::grpc::CompletionQueue* cq) {
  auto* result =
    this->PrepareAsyncGetLogStoreInfoRaw(context, request, cq);
  result->StartCall();
  return result;
}

::grpc::Status NewLogStore::Stub::BatchFallocate(::grpc::ClientContext* context, const ::newlogstorepb::BatchFallocateReq& request, ::newlogstorepb::BatchFallocateResp* response) {
  return ::grpc::internal::BlockingUnaryCall< ::newlogstorepb::BatchFallocateReq, ::newlogstorepb::BatchFallocateResp, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(channel_.get(), rpcmethod_BatchFallocate_, context, request, response);
}

void NewLogStore::Stub::async::BatchFallocate(::grpc::ClientContext* context, const ::newlogstorepb::BatchFallocateReq* request, ::newlogstorepb::BatchFallocateResp* response, std::function<void(::grpc::Status)> f) {
  ::grpc::internal::CallbackUnaryCall< ::newlogstorepb::BatchFallocateReq, ::newlogstorepb::BatchFallocateResp, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(stub_->channel_.get(), stub_->rpcmethod_BatchFallocate_, context, request, response, std::move(f));
}

void NewLogStore::Stub::async::BatchFallocate(::grpc::ClientContext* context, const ::newlogstorepb::BatchFallocateReq* request, ::newlogstorepb::BatchFallocateResp* response, ::grpc::ClientUnaryReactor* reactor) {
  ::grpc::internal::ClientCallbackUnaryFactory::Create< ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(stub_->channel_.get(), stub_->rpcmethod_BatchFallocate_, context, request, response, reactor);
}

::grpc::ClientAsyncResponseReader< ::newlogstorepb::BatchFallocateResp>* NewLogStore::Stub::PrepareAsyncBatchFallocateRaw(::grpc::ClientContext* context, const ::newlogstorepb::BatchFallocateReq& request, ::grpc::CompletionQueue* cq) {
  return ::grpc::internal::ClientAsyncResponseReaderHelper::Create< ::newlogstorepb::BatchFallocateResp, ::newlogstorepb::BatchFallocateReq, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(channel_.get(), cq, rpcmethod_BatchFallocate_, context, request);
}

::grpc::ClientAsyncResponseReader< ::newlogstorepb::BatchFallocateResp>* NewLogStore::Stub::AsyncBatchFallocateRaw(::grpc::ClientContext* context, const ::newlogstorepb::BatchFallocateReq& request, ::grpc::CompletionQueue* cq) {
  auto* result =
    this->PrepareAsyncBatchFallocateRaw(context, request, cq);
  result->StartCall();
  return result;
}

NewLogStore::Service::Service() {
  AddMethod(new ::grpc::internal::RpcServiceMethod(
      NewLogStore_method_names[0],
      ::grpc::internal::RpcMethod::NORMAL_RPC,
      new ::grpc::internal::RpcMethodHandler< NewLogStore::Service, ::newlogstorepb::LoadLogStoreReq, ::newlogstorepb::LoadLogStoreResp, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(
          [](NewLogStore::Service* service,
             ::grpc::ServerContext* ctx,
             const ::newlogstorepb::LoadLogStoreReq* req,
             ::newlogstorepb::LoadLogStoreResp* resp) {
               return service->LoadLogStore(ctx, req, resp);
             }, this)));
  AddMethod(new ::grpc::internal::RpcServiceMethod(
      NewLogStore_method_names[1],
      ::grpc::internal::RpcMethod::NORMAL_RPC,
      new ::grpc::internal::RpcMethodHandler< NewLogStore::Service, ::newlogstorepb::OpenReq, ::newlogstorepb::OpenResp, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(
          [](NewLogStore::Service* service,
             ::grpc::ServerContext* ctx,
             const ::newlogstorepb::OpenReq* req,
             ::newlogstorepb::OpenResp* resp) {
               return service->Open(ctx, req, resp);
             }, this)));
  AddMethod(new ::grpc::internal::RpcServiceMethod(
      NewLogStore_method_names[2],
      ::grpc::internal::RpcMethod::NORMAL_RPC,
      new ::grpc::internal::RpcMethodHandler< NewLogStore::Service, ::newlogstorepb::CloseReq, ::newlogstorepb::CloseResp, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(
          [](NewLogStore::Service* service,
             ::grpc::ServerContext* ctx,
             const ::newlogstorepb::CloseReq* req,
             ::newlogstorepb::CloseResp* resp) {
               return service->Close(ctx, req, resp);
             }, this)));
  AddMethod(new ::grpc::internal::RpcServiceMethod(
      NewLogStore_method_names[3],
      ::grpc::internal::RpcMethod::NORMAL_RPC,
      new ::grpc::internal::RpcMethodHandler< NewLogStore::Service, ::newlogstorepb::PwriteReq, ::newlogstorepb::PwriteResp, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(
          [](NewLogStore::Service* service,
             ::grpc::ServerContext* ctx,
             const ::newlogstorepb::PwriteReq* req,
             ::newlogstorepb::PwriteResp* resp) {
               return service->Pwrite(ctx, req, resp);
             }, this)));
  AddMethod(new ::grpc::internal::RpcServiceMethod(
      NewLogStore_method_names[4],
      ::grpc::internal::RpcMethod::NORMAL_RPC,
      new ::grpc::internal::RpcMethodHandler< NewLogStore::Service, ::newlogstorepb::PreadReq, ::newlogstorepb::PreadResp, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(
          [](NewLogStore::Service* service,
             ::grpc::ServerContext* ctx,
             const ::newlogstorepb::PreadReq* req,
             ::newlogstorepb::PreadResp* resp) {
               return service->Pread(ctx, req, resp);
             }, this)));
  AddMethod(new ::grpc::internal::RpcServiceMethod(
      NewLogStore_method_names[5],
      ::grpc::internal::RpcMethod::NORMAL_RPC,
      new ::grpc::internal::RpcMethodHandler< NewLogStore::Service, ::newlogstorepb::FallocateReq, ::newlogstorepb::FallocateResp, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(
          [](NewLogStore::Service* service,
             ::grpc::ServerContext* ctx,
             const ::newlogstorepb::FallocateReq* req,
             ::newlogstorepb::FallocateResp* resp) {
               return service->Fallocate(ctx, req, resp);
             }, this)));
  AddMethod(new ::grpc::internal::RpcServiceMethod(
      NewLogStore_method_names[6],
      ::grpc::internal::RpcMethod::NORMAL_RPC,
      new ::grpc::internal::RpcMethodHandler< NewLogStore::Service, ::newlogstorepb::FtruncateReq, ::newlogstorepb::FtruncateResp, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(
          [](NewLogStore::Service* service,
             ::grpc::ServerContext* ctx,
             const ::newlogstorepb::FtruncateReq* req,
             ::newlogstorepb::FtruncateResp* resp) {
               return service->Ftruncate(ctx, req, resp);
             }, this)));
  AddMethod(new ::grpc::internal::RpcServiceMethod(
      NewLogStore_method_names[7],
      ::grpc::internal::RpcMethod::NORMAL_RPC,
      new ::grpc::internal::RpcMethodHandler< NewLogStore::Service, ::newlogstorepb::ScanDirReq, ::newlogstorepb::ScanDirResp, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(
          [](NewLogStore::Service* service,
             ::grpc::ServerContext* ctx,
             const ::newlogstorepb::ScanDirReq* req,
             ::newlogstorepb::ScanDirResp* resp) {
               return service->Scandir(ctx, req, resp);
             }, this)));
  AddMethod(new ::grpc::internal::RpcServiceMethod(
      NewLogStore_method_names[8],
      ::grpc::internal::RpcMethod::NORMAL_RPC,
      new ::grpc::internal::RpcMethodHandler< NewLogStore::Service, ::newlogstorepb::UnlinkReq, ::newlogstorepb::UnlinkResp, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(
          [](NewLogStore::Service* service,
             ::grpc::ServerContext* ctx,
             const ::newlogstorepb::UnlinkReq* req,
             ::newlogstorepb::UnlinkResp* resp) {
               return service->Unlink(ctx, req, resp);
             }, this)));
  AddMethod(new ::grpc::internal::RpcServiceMethod(
      NewLogStore_method_names[9],
      ::grpc::internal::RpcMethod::NORMAL_RPC,
      new ::grpc::internal::RpcMethodHandler< NewLogStore::Service, ::newlogstorepb::MkdirReq, ::newlogstorepb::MkdirResp, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(
          [](NewLogStore::Service* service,
             ::grpc::ServerContext* ctx,
             const ::newlogstorepb::MkdirReq* req,
             ::newlogstorepb::MkdirResp* resp) {
               return service->Mkdir(ctx, req, resp);
             }, this)));
  AddMethod(new ::grpc::internal::RpcServiceMethod(
      NewLogStore_method_names[10],
      ::grpc::internal::RpcMethod::NORMAL_RPC,
      new ::grpc::internal::RpcMethodHandler< NewLogStore::Service, ::newlogstorepb::RmdirReq, ::newlogstorepb::RmdirResp, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(
          [](NewLogStore::Service* service,
             ::grpc::ServerContext* ctx,
             const ::newlogstorepb::RmdirReq* req,
             ::newlogstorepb::RmdirResp* resp) {
               return service->Rmdir(ctx, req, resp);
             }, this)));
  AddMethod(new ::grpc::internal::RpcServiceMethod(
      NewLogStore_method_names[11],
      ::grpc::internal::RpcMethod::NORMAL_RPC,
      new ::grpc::internal::RpcMethodHandler< NewLogStore::Service, ::newlogstorepb::StatReq, ::newlogstorepb::StatResp, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(
          [](NewLogStore::Service* service,
             ::grpc::ServerContext* ctx,
             const ::newlogstorepb::StatReq* req,
             ::newlogstorepb::StatResp* resp) {
               return service->Stat(ctx, req, resp);
             }, this)));
  AddMethod(new ::grpc::internal::RpcServiceMethod(
      NewLogStore_method_names[12],
      ::grpc::internal::RpcMethod::NORMAL_RPC,
      new ::grpc::internal::RpcMethodHandler< NewLogStore::Service, ::newlogstorepb::RenameReq, ::newlogstorepb::RenameResp, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(
          [](NewLogStore::Service* service,
             ::grpc::ServerContext* ctx,
             const ::newlogstorepb::RenameReq* req,
             ::newlogstorepb::RenameResp* resp) {
               return service->Rename(ctx, req, resp);
             }, this)));
  AddMethod(new ::grpc::internal::RpcServiceMethod(
      NewLogStore_method_names[13],
      ::grpc::internal::RpcMethod::NORMAL_RPC,
      new ::grpc::internal::RpcMethodHandler< NewLogStore::Service, ::newlogstorepb::FsyncReq, ::newlogstorepb::FsyncResp, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(
          [](NewLogStore::Service* service,
             ::grpc::ServerContext* ctx,
             const ::newlogstorepb::FsyncReq* req,
             ::newlogstorepb::FsyncResp* resp) {
               return service->Fsync(ctx, req, resp);
             }, this)));
  AddMethod(new ::grpc::internal::RpcServiceMethod(
      NewLogStore_method_names[14],
      ::grpc::internal::RpcMethod::NORMAL_RPC,
      new ::grpc::internal::RpcMethodHandler< NewLogStore::Service, ::newlogstorepb::GetLogStoreInfoReq, ::newlogstorepb::GetLogStoreInfoResp, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(
          [](NewLogStore::Service* service,
             ::grpc::ServerContext* ctx,
             const ::newlogstorepb::GetLogStoreInfoReq* req,
             ::newlogstorepb::GetLogStoreInfoResp* resp) {
               return service->GetLogStoreInfo(ctx, req, resp);
             }, this)));
  AddMethod(new ::grpc::internal::RpcServiceMethod(
      NewLogStore_method_names[15],
      ::grpc::internal::RpcMethod::NORMAL_RPC,
      new ::grpc::internal::RpcMethodHandler< NewLogStore::Service, ::newlogstorepb::BatchFallocateReq, ::newlogstorepb::BatchFallocateResp, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(
          [](NewLogStore::Service* service,
             ::grpc::ServerContext* ctx,
             const ::newlogstorepb::BatchFallocateReq* req,
             ::newlogstorepb::BatchFallocateResp* resp) {
               return service->BatchFallocate(ctx, req, resp);
             }, this)));
}

NewLogStore::Service::~Service() {
}

::grpc::Status NewLogStore::Service::LoadLogStore(::grpc::ServerContext* context, const ::newlogstorepb::LoadLogStoreReq* request, ::newlogstorepb::LoadLogStoreResp* response) {
  (void) context;
  (void) request;
  (void) response;
  return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
}

::grpc::Status NewLogStore::Service::Open(::grpc::ServerContext* context, const ::newlogstorepb::OpenReq* request, ::newlogstorepb::OpenResp* response) {
  (void) context;
  (void) request;
  (void) response;
  return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
}

::grpc::Status NewLogStore::Service::Close(::grpc::ServerContext* context, const ::newlogstorepb::CloseReq* request, ::newlogstorepb::CloseResp* response) {
  (void) context;
  (void) request;
  (void) response;
  return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
}

::grpc::Status NewLogStore::Service::Pwrite(::grpc::ServerContext* context, const ::newlogstorepb::PwriteReq* request, ::newlogstorepb::PwriteResp* response) {
  (void) context;
  (void) request;
  (void) response;
  return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
}

::grpc::Status NewLogStore::Service::Pread(::grpc::ServerContext* context, const ::newlogstorepb::PreadReq* request, ::newlogstorepb::PreadResp* response) {
  (void) context;
  (void) request;
  (void) response;
  return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
}

::grpc::Status NewLogStore::Service::Fallocate(::grpc::ServerContext* context, const ::newlogstorepb::FallocateReq* request, ::newlogstorepb::FallocateResp* response) {
  (void) context;
  (void) request;
  (void) response;
  return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
}

::grpc::Status NewLogStore::Service::Ftruncate(::grpc::ServerContext* context, const ::newlogstorepb::FtruncateReq* request, ::newlogstorepb::FtruncateResp* response) {
  (void) context;
  (void) request;
  (void) response;
  return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
}

::grpc::Status NewLogStore::Service::Scandir(::grpc::ServerContext* context, const ::newlogstorepb::ScanDirReq* request, ::newlogstorepb::ScanDirResp* response) {
  (void) context;
  (void) request;
  (void) response;
  return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
}

::grpc::Status NewLogStore::Service::Unlink(::grpc::ServerContext* context, const ::newlogstorepb::UnlinkReq* request, ::newlogstorepb::UnlinkResp* response) {
  (void) context;
  (void) request;
  (void) response;
  return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
}

::grpc::Status NewLogStore::Service::Mkdir(::grpc::ServerContext* context, const ::newlogstorepb::MkdirReq* request, ::newlogstorepb::MkdirResp* response) {
  (void) context;
  (void) request;
  (void) response;
  return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
}

::grpc::Status NewLogStore::Service::Rmdir(::grpc::ServerContext* context, const ::newlogstorepb::RmdirReq* request, ::newlogstorepb::RmdirResp* response) {
  (void) context;
  (void) request;
  (void) response;
  return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
}

::grpc::Status NewLogStore::Service::Stat(::grpc::ServerContext* context, const ::newlogstorepb::StatReq* request, ::newlogstorepb::StatResp* response) {
  (void) context;
  (void) request;
  (void) response;
  return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
}

::grpc::Status NewLogStore::Service::Rename(::grpc::ServerContext* context, const ::newlogstorepb::RenameReq* request, ::newlogstorepb::RenameResp* response) {
  (void) context;
  (void) request;
  (void) response;
  return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
}

::grpc::Status NewLogStore::Service::Fsync(::grpc::ServerContext* context, const ::newlogstorepb::FsyncReq* request, ::newlogstorepb::FsyncResp* response) {
  (void) context;
  (void) request;
  (void) response;
  return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
}

::grpc::Status NewLogStore::Service::GetLogStoreInfo(::grpc::ServerContext* context, const ::newlogstorepb::GetLogStoreInfoReq* request, ::newlogstorepb::GetLogStoreInfoResp* response) {
  (void) context;
  (void) request;
  (void) response;
  return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
}

::grpc::Status NewLogStore::Service::BatchFallocate(::grpc::ServerContext* context, const ::newlogstorepb::BatchFallocateReq* request, ::newlogstorepb::BatchFallocateResp* response) {
  (void) context;
  (void) request;
  (void) response;
  return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
}


}  // namespace newlogstorepb
