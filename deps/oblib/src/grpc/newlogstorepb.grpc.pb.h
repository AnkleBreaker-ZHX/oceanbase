// Generated by the gRPC C++ plugin.
// If you make any local change, they will be lost.
// source: newlogstorepb.proto
#ifndef GRPC_newlogstorepb_2eproto__INCLUDED
#define GRPC_newlogstorepb_2eproto__INCLUDED

#include "newlogstorepb.pb.h"

#include <functional>
#include <grpcpp/impl/codegen/async_generic_service.h>
#include <grpcpp/impl/codegen/async_stream.h>
#include <grpcpp/impl/codegen/async_unary_call.h>
#include <grpcpp/impl/codegen/client_callback.h>
#include <grpcpp/impl/codegen/client_context.h>
#include <grpcpp/impl/codegen/completion_queue.h>
#include <grpcpp/impl/codegen/message_allocator.h>
#include <grpcpp/impl/codegen/method_handler.h>
#include <grpcpp/impl/codegen/proto_utils.h>
#include <grpcpp/impl/codegen/rpc_method.h>
#include <grpcpp/impl/codegen/server_callback.h>
#include <grpcpp/impl/codegen/server_callback_handlers.h>
#include <grpcpp/impl/codegen/server_context.h>
#include <grpcpp/impl/codegen/service_type.h>
#include <grpcpp/impl/codegen/status.h>
#include <grpcpp/impl/codegen/stub_options.h>
#include <grpcpp/impl/codegen/sync_stream.h>

namespace newlogstorepb {

class NewLogStore final {
 public:
  static constexpr char const* service_full_name() {
    return "newlogstorepb.NewLogStore";
  }
  class StubInterface {
   public:
    virtual ~StubInterface() {}
    // load logstore
    virtual ::grpc::Status LoadLogStore(::grpc::ClientContext* context, const ::newlogstorepb::LoadLogStoreReq& request, ::newlogstorepb::LoadLogStoreResp* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::newlogstorepb::LoadLogStoreResp>> AsyncLoadLogStore(::grpc::ClientContext* context, const ::newlogstorepb::LoadLogStoreReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::newlogstorepb::LoadLogStoreResp>>(AsyncLoadLogStoreRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::newlogstorepb::LoadLogStoreResp>> PrepareAsyncLoadLogStore(::grpc::ClientContext* context, const ::newlogstorepb::LoadLogStoreReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::newlogstorepb::LoadLogStoreResp>>(PrepareAsyncLoadLogStoreRaw(context, request, cq));
    }
    // open a file
    virtual ::grpc::Status Open(::grpc::ClientContext* context, const ::newlogstorepb::OpenReq& request, ::newlogstorepb::OpenResp* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::newlogstorepb::OpenResp>> AsyncOpen(::grpc::ClientContext* context, const ::newlogstorepb::OpenReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::newlogstorepb::OpenResp>>(AsyncOpenRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::newlogstorepb::OpenResp>> PrepareAsyncOpen(::grpc::ClientContext* context, const ::newlogstorepb::OpenReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::newlogstorepb::OpenResp>>(PrepareAsyncOpenRaw(context, request, cq));
    }
    // close a file
    virtual ::grpc::Status Close(::grpc::ClientContext* context, const ::newlogstorepb::CloseReq& request, ::newlogstorepb::CloseResp* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::newlogstorepb::CloseResp>> AsyncClose(::grpc::ClientContext* context, const ::newlogstorepb::CloseReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::newlogstorepb::CloseResp>>(AsyncCloseRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::newlogstorepb::CloseResp>> PrepareAsyncClose(::grpc::ClientContext* context, const ::newlogstorepb::CloseReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::newlogstorepb::CloseResp>>(PrepareAsyncCloseRaw(context, request, cq));
    }
    // pwrite to a file
    virtual ::grpc::Status Pwrite(::grpc::ClientContext* context, const ::newlogstorepb::PwriteReq& request, ::newlogstorepb::PwriteResp* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::newlogstorepb::PwriteResp>> AsyncPwrite(::grpc::ClientContext* context, const ::newlogstorepb::PwriteReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::newlogstorepb::PwriteResp>>(AsyncPwriteRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::newlogstorepb::PwriteResp>> PrepareAsyncPwrite(::grpc::ClientContext* context, const ::newlogstorepb::PwriteReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::newlogstorepb::PwriteResp>>(PrepareAsyncPwriteRaw(context, request, cq));
    }
    // pread from a file
    virtual ::grpc::Status Pread(::grpc::ClientContext* context, const ::newlogstorepb::PreadReq& request, ::newlogstorepb::PreadResp* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::newlogstorepb::PreadResp>> AsyncPread(::grpc::ClientContext* context, const ::newlogstorepb::PreadReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::newlogstorepb::PreadResp>>(AsyncPreadRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::newlogstorepb::PreadResp>> PrepareAsyncPread(::grpc::ClientContext* context, const ::newlogstorepb::PreadReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::newlogstorepb::PreadResp>>(PrepareAsyncPreadRaw(context, request, cq));
    }
    // fallocate a file to designated size
    virtual ::grpc::Status Fallocate(::grpc::ClientContext* context, const ::newlogstorepb::FallocateReq& request, ::newlogstorepb::FallocateResp* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::newlogstorepb::FallocateResp>> AsyncFallocate(::grpc::ClientContext* context, const ::newlogstorepb::FallocateReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::newlogstorepb::FallocateResp>>(AsyncFallocateRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::newlogstorepb::FallocateResp>> PrepareAsyncFallocate(::grpc::ClientContext* context, const ::newlogstorepb::FallocateReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::newlogstorepb::FallocateResp>>(PrepareAsyncFallocateRaw(context, request, cq));
    }
    // ftruncate a file
    virtual ::grpc::Status Ftruncate(::grpc::ClientContext* context, const ::newlogstorepb::FtruncateReq& request, ::newlogstorepb::FtruncateResp* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::newlogstorepb::FtruncateResp>> AsyncFtruncate(::grpc::ClientContext* context, const ::newlogstorepb::FtruncateReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::newlogstorepb::FtruncateResp>>(AsyncFtruncateRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::newlogstorepb::FtruncateResp>> PrepareAsyncFtruncate(::grpc::ClientContext* context, const ::newlogstorepb::FtruncateReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::newlogstorepb::FtruncateResp>>(PrepareAsyncFtruncateRaw(context, request, cq));
    }
    // scan a dir
    virtual ::grpc::Status Scandir(::grpc::ClientContext* context, const ::newlogstorepb::ScanDirReq& request, ::newlogstorepb::ScanDirResp* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::newlogstorepb::ScanDirResp>> AsyncScandir(::grpc::ClientContext* context, const ::newlogstorepb::ScanDirReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::newlogstorepb::ScanDirResp>>(AsyncScandirRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::newlogstorepb::ScanDirResp>> PrepareAsyncScandir(::grpc::ClientContext* context, const ::newlogstorepb::ScanDirReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::newlogstorepb::ScanDirResp>>(PrepareAsyncScandirRaw(context, request, cq));
    }
    // unlink
    virtual ::grpc::Status Unlink(::grpc::ClientContext* context, const ::newlogstorepb::UnlinkReq& request, ::newlogstorepb::UnlinkResp* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::newlogstorepb::UnlinkResp>> AsyncUnlink(::grpc::ClientContext* context, const ::newlogstorepb::UnlinkReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::newlogstorepb::UnlinkResp>>(AsyncUnlinkRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::newlogstorepb::UnlinkResp>> PrepareAsyncUnlink(::grpc::ClientContext* context, const ::newlogstorepb::UnlinkReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::newlogstorepb::UnlinkResp>>(PrepareAsyncUnlinkRaw(context, request, cq));
    }
    // mkdir
    virtual ::grpc::Status Mkdir(::grpc::ClientContext* context, const ::newlogstorepb::MkdirReq& request, ::newlogstorepb::MkdirResp* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::newlogstorepb::MkdirResp>> AsyncMkdir(::grpc::ClientContext* context, const ::newlogstorepb::MkdirReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::newlogstorepb::MkdirResp>>(AsyncMkdirRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::newlogstorepb::MkdirResp>> PrepareAsyncMkdir(::grpc::ClientContext* context, const ::newlogstorepb::MkdirReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::newlogstorepb::MkdirResp>>(PrepareAsyncMkdirRaw(context, request, cq));
    }
    // rmdir
    virtual ::grpc::Status Rmdir(::grpc::ClientContext* context, const ::newlogstorepb::RmdirReq& request, ::newlogstorepb::RmdirResp* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::newlogstorepb::RmdirResp>> AsyncRmdir(::grpc::ClientContext* context, const ::newlogstorepb::RmdirReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::newlogstorepb::RmdirResp>>(AsyncRmdirRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::newlogstorepb::RmdirResp>> PrepareAsyncRmdir(::grpc::ClientContext* context, const ::newlogstorepb::RmdirReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::newlogstorepb::RmdirResp>>(PrepareAsyncRmdirRaw(context, request, cq));
    }
    // stat interface
    virtual ::grpc::Status Stat(::grpc::ClientContext* context, const ::newlogstorepb::StatReq& request, ::newlogstorepb::StatResp* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::newlogstorepb::StatResp>> AsyncStat(::grpc::ClientContext* context, const ::newlogstorepb::StatReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::newlogstorepb::StatResp>>(AsyncStatRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::newlogstorepb::StatResp>> PrepareAsyncStat(::grpc::ClientContext* context, const ::newlogstorepb::StatReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::newlogstorepb::StatResp>>(PrepareAsyncStatRaw(context, request, cq));
    }
    // rename interface
    virtual ::grpc::Status Rename(::grpc::ClientContext* context, const ::newlogstorepb::RenameReq& request, ::newlogstorepb::RenameResp* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::newlogstorepb::RenameResp>> AsyncRename(::grpc::ClientContext* context, const ::newlogstorepb::RenameReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::newlogstorepb::RenameResp>>(AsyncRenameRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::newlogstorepb::RenameResp>> PrepareAsyncRename(::grpc::ClientContext* context, const ::newlogstorepb::RenameReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::newlogstorepb::RenameResp>>(PrepareAsyncRenameRaw(context, request, cq));
    }
    // fsync interface
    virtual ::grpc::Status Fsync(::grpc::ClientContext* context, const ::newlogstorepb::FsyncReq& request, ::newlogstorepb::FsyncResp* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::newlogstorepb::FsyncResp>> AsyncFsync(::grpc::ClientContext* context, const ::newlogstorepb::FsyncReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::newlogstorepb::FsyncResp>>(AsyncFsyncRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::newlogstorepb::FsyncResp>> PrepareAsyncFsync(::grpc::ClientContext* context, const ::newlogstorepb::FsyncReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::newlogstorepb::FsyncResp>>(PrepareAsyncFsyncRaw(context, request, cq));
    }
    // get logstore info interface
    virtual ::grpc::Status GetLogStoreInfo(::grpc::ClientContext* context, const ::newlogstorepb::GetLogStoreInfoReq& request, ::newlogstorepb::GetLogStoreInfoResp* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::newlogstorepb::GetLogStoreInfoResp>> AsyncGetLogStoreInfo(::grpc::ClientContext* context, const ::newlogstorepb::GetLogStoreInfoReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::newlogstorepb::GetLogStoreInfoResp>>(AsyncGetLogStoreInfoRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::newlogstorepb::GetLogStoreInfoResp>> PrepareAsyncGetLogStoreInfo(::grpc::ClientContext* context, const ::newlogstorepb::GetLogStoreInfoReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::newlogstorepb::GetLogStoreInfoResp>>(PrepareAsyncGetLogStoreInfoRaw(context, request, cq));
    }
    // batch fallocate interface
    virtual ::grpc::Status BatchFallocate(::grpc::ClientContext* context, const ::newlogstorepb::BatchFallocateReq& request, ::newlogstorepb::BatchFallocateResp* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::newlogstorepb::BatchFallocateResp>> AsyncBatchFallocate(::grpc::ClientContext* context, const ::newlogstorepb::BatchFallocateReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::newlogstorepb::BatchFallocateResp>>(AsyncBatchFallocateRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::newlogstorepb::BatchFallocateResp>> PrepareAsyncBatchFallocate(::grpc::ClientContext* context, const ::newlogstorepb::BatchFallocateReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::newlogstorepb::BatchFallocateResp>>(PrepareAsyncBatchFallocateRaw(context, request, cq));
    }
    class async_interface {
     public:
      virtual ~async_interface() {}
      // load logstore
      virtual void LoadLogStore(::grpc::ClientContext* context, const ::newlogstorepb::LoadLogStoreReq* request, ::newlogstorepb::LoadLogStoreResp* response, std::function<void(::grpc::Status)>) = 0;
      virtual void LoadLogStore(::grpc::ClientContext* context, const ::newlogstorepb::LoadLogStoreReq* request, ::newlogstorepb::LoadLogStoreResp* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      // open a file
      virtual void Open(::grpc::ClientContext* context, const ::newlogstorepb::OpenReq* request, ::newlogstorepb::OpenResp* response, std::function<void(::grpc::Status)>) = 0;
      virtual void Open(::grpc::ClientContext* context, const ::newlogstorepb::OpenReq* request, ::newlogstorepb::OpenResp* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      // close a file
      virtual void Close(::grpc::ClientContext* context, const ::newlogstorepb::CloseReq* request, ::newlogstorepb::CloseResp* response, std::function<void(::grpc::Status)>) = 0;
      virtual void Close(::grpc::ClientContext* context, const ::newlogstorepb::CloseReq* request, ::newlogstorepb::CloseResp* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      // pwrite to a file
      virtual void Pwrite(::grpc::ClientContext* context, const ::newlogstorepb::PwriteReq* request, ::newlogstorepb::PwriteResp* response, std::function<void(::grpc::Status)>) = 0;
      virtual void Pwrite(::grpc::ClientContext* context, const ::newlogstorepb::PwriteReq* request, ::newlogstorepb::PwriteResp* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      // pread from a file
      virtual void Pread(::grpc::ClientContext* context, const ::newlogstorepb::PreadReq* request, ::newlogstorepb::PreadResp* response, std::function<void(::grpc::Status)>) = 0;
      virtual void Pread(::grpc::ClientContext* context, const ::newlogstorepb::PreadReq* request, ::newlogstorepb::PreadResp* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      // fallocate a file to designated size
      virtual void Fallocate(::grpc::ClientContext* context, const ::newlogstorepb::FallocateReq* request, ::newlogstorepb::FallocateResp* response, std::function<void(::grpc::Status)>) = 0;
      virtual void Fallocate(::grpc::ClientContext* context, const ::newlogstorepb::FallocateReq* request, ::newlogstorepb::FallocateResp* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      // ftruncate a file
      virtual void Ftruncate(::grpc::ClientContext* context, const ::newlogstorepb::FtruncateReq* request, ::newlogstorepb::FtruncateResp* response, std::function<void(::grpc::Status)>) = 0;
      virtual void Ftruncate(::grpc::ClientContext* context, const ::newlogstorepb::FtruncateReq* request, ::newlogstorepb::FtruncateResp* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      // scan a dir
      virtual void Scandir(::grpc::ClientContext* context, const ::newlogstorepb::ScanDirReq* request, ::newlogstorepb::ScanDirResp* response, std::function<void(::grpc::Status)>) = 0;
      virtual void Scandir(::grpc::ClientContext* context, const ::newlogstorepb::ScanDirReq* request, ::newlogstorepb::ScanDirResp* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      // unlink
      virtual void Unlink(::grpc::ClientContext* context, const ::newlogstorepb::UnlinkReq* request, ::newlogstorepb::UnlinkResp* response, std::function<void(::grpc::Status)>) = 0;
      virtual void Unlink(::grpc::ClientContext* context, const ::newlogstorepb::UnlinkReq* request, ::newlogstorepb::UnlinkResp* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      // mkdir
      virtual void Mkdir(::grpc::ClientContext* context, const ::newlogstorepb::MkdirReq* request, ::newlogstorepb::MkdirResp* response, std::function<void(::grpc::Status)>) = 0;
      virtual void Mkdir(::grpc::ClientContext* context, const ::newlogstorepb::MkdirReq* request, ::newlogstorepb::MkdirResp* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      // rmdir
      virtual void Rmdir(::grpc::ClientContext* context, const ::newlogstorepb::RmdirReq* request, ::newlogstorepb::RmdirResp* response, std::function<void(::grpc::Status)>) = 0;
      virtual void Rmdir(::grpc::ClientContext* context, const ::newlogstorepb::RmdirReq* request, ::newlogstorepb::RmdirResp* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      // stat interface
      virtual void Stat(::grpc::ClientContext* context, const ::newlogstorepb::StatReq* request, ::newlogstorepb::StatResp* response, std::function<void(::grpc::Status)>) = 0;
      virtual void Stat(::grpc::ClientContext* context, const ::newlogstorepb::StatReq* request, ::newlogstorepb::StatResp* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      // rename interface
      virtual void Rename(::grpc::ClientContext* context, const ::newlogstorepb::RenameReq* request, ::newlogstorepb::RenameResp* response, std::function<void(::grpc::Status)>) = 0;
      virtual void Rename(::grpc::ClientContext* context, const ::newlogstorepb::RenameReq* request, ::newlogstorepb::RenameResp* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      // fsync interface
      virtual void Fsync(::grpc::ClientContext* context, const ::newlogstorepb::FsyncReq* request, ::newlogstorepb::FsyncResp* response, std::function<void(::grpc::Status)>) = 0;
      virtual void Fsync(::grpc::ClientContext* context, const ::newlogstorepb::FsyncReq* request, ::newlogstorepb::FsyncResp* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      // get logstore info interface
      virtual void GetLogStoreInfo(::grpc::ClientContext* context, const ::newlogstorepb::GetLogStoreInfoReq* request, ::newlogstorepb::GetLogStoreInfoResp* response, std::function<void(::grpc::Status)>) = 0;
      virtual void GetLogStoreInfo(::grpc::ClientContext* context, const ::newlogstorepb::GetLogStoreInfoReq* request, ::newlogstorepb::GetLogStoreInfoResp* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      // batch fallocate interface
      virtual void BatchFallocate(::grpc::ClientContext* context, const ::newlogstorepb::BatchFallocateReq* request, ::newlogstorepb::BatchFallocateResp* response, std::function<void(::grpc::Status)>) = 0;
      virtual void BatchFallocate(::grpc::ClientContext* context, const ::newlogstorepb::BatchFallocateReq* request, ::newlogstorepb::BatchFallocateResp* response, ::grpc::ClientUnaryReactor* reactor) = 0;
    };
    typedef class async_interface experimental_async_interface;
    virtual class async_interface* async() { return nullptr; }
    class async_interface* experimental_async() { return async(); }
   private:
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::newlogstorepb::LoadLogStoreResp>* AsyncLoadLogStoreRaw(::grpc::ClientContext* context, const ::newlogstorepb::LoadLogStoreReq& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::newlogstorepb::LoadLogStoreResp>* PrepareAsyncLoadLogStoreRaw(::grpc::ClientContext* context, const ::newlogstorepb::LoadLogStoreReq& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::newlogstorepb::OpenResp>* AsyncOpenRaw(::grpc::ClientContext* context, const ::newlogstorepb::OpenReq& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::newlogstorepb::OpenResp>* PrepareAsyncOpenRaw(::grpc::ClientContext* context, const ::newlogstorepb::OpenReq& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::newlogstorepb::CloseResp>* AsyncCloseRaw(::grpc::ClientContext* context, const ::newlogstorepb::CloseReq& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::newlogstorepb::CloseResp>* PrepareAsyncCloseRaw(::grpc::ClientContext* context, const ::newlogstorepb::CloseReq& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::newlogstorepb::PwriteResp>* AsyncPwriteRaw(::grpc::ClientContext* context, const ::newlogstorepb::PwriteReq& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::newlogstorepb::PwriteResp>* PrepareAsyncPwriteRaw(::grpc::ClientContext* context, const ::newlogstorepb::PwriteReq& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::newlogstorepb::PreadResp>* AsyncPreadRaw(::grpc::ClientContext* context, const ::newlogstorepb::PreadReq& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::newlogstorepb::PreadResp>* PrepareAsyncPreadRaw(::grpc::ClientContext* context, const ::newlogstorepb::PreadReq& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::newlogstorepb::FallocateResp>* AsyncFallocateRaw(::grpc::ClientContext* context, const ::newlogstorepb::FallocateReq& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::newlogstorepb::FallocateResp>* PrepareAsyncFallocateRaw(::grpc::ClientContext* context, const ::newlogstorepb::FallocateReq& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::newlogstorepb::FtruncateResp>* AsyncFtruncateRaw(::grpc::ClientContext* context, const ::newlogstorepb::FtruncateReq& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::newlogstorepb::FtruncateResp>* PrepareAsyncFtruncateRaw(::grpc::ClientContext* context, const ::newlogstorepb::FtruncateReq& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::newlogstorepb::ScanDirResp>* AsyncScandirRaw(::grpc::ClientContext* context, const ::newlogstorepb::ScanDirReq& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::newlogstorepb::ScanDirResp>* PrepareAsyncScandirRaw(::grpc::ClientContext* context, const ::newlogstorepb::ScanDirReq& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::newlogstorepb::UnlinkResp>* AsyncUnlinkRaw(::grpc::ClientContext* context, const ::newlogstorepb::UnlinkReq& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::newlogstorepb::UnlinkResp>* PrepareAsyncUnlinkRaw(::grpc::ClientContext* context, const ::newlogstorepb::UnlinkReq& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::newlogstorepb::MkdirResp>* AsyncMkdirRaw(::grpc::ClientContext* context, const ::newlogstorepb::MkdirReq& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::newlogstorepb::MkdirResp>* PrepareAsyncMkdirRaw(::grpc::ClientContext* context, const ::newlogstorepb::MkdirReq& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::newlogstorepb::RmdirResp>* AsyncRmdirRaw(::grpc::ClientContext* context, const ::newlogstorepb::RmdirReq& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::newlogstorepb::RmdirResp>* PrepareAsyncRmdirRaw(::grpc::ClientContext* context, const ::newlogstorepb::RmdirReq& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::newlogstorepb::StatResp>* AsyncStatRaw(::grpc::ClientContext* context, const ::newlogstorepb::StatReq& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::newlogstorepb::StatResp>* PrepareAsyncStatRaw(::grpc::ClientContext* context, const ::newlogstorepb::StatReq& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::newlogstorepb::RenameResp>* AsyncRenameRaw(::grpc::ClientContext* context, const ::newlogstorepb::RenameReq& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::newlogstorepb::RenameResp>* PrepareAsyncRenameRaw(::grpc::ClientContext* context, const ::newlogstorepb::RenameReq& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::newlogstorepb::FsyncResp>* AsyncFsyncRaw(::grpc::ClientContext* context, const ::newlogstorepb::FsyncReq& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::newlogstorepb::FsyncResp>* PrepareAsyncFsyncRaw(::grpc::ClientContext* context, const ::newlogstorepb::FsyncReq& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::newlogstorepb::GetLogStoreInfoResp>* AsyncGetLogStoreInfoRaw(::grpc::ClientContext* context, const ::newlogstorepb::GetLogStoreInfoReq& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::newlogstorepb::GetLogStoreInfoResp>* PrepareAsyncGetLogStoreInfoRaw(::grpc::ClientContext* context, const ::newlogstorepb::GetLogStoreInfoReq& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::newlogstorepb::BatchFallocateResp>* AsyncBatchFallocateRaw(::grpc::ClientContext* context, const ::newlogstorepb::BatchFallocateReq& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::newlogstorepb::BatchFallocateResp>* PrepareAsyncBatchFallocateRaw(::grpc::ClientContext* context, const ::newlogstorepb::BatchFallocateReq& request, ::grpc::CompletionQueue* cq) = 0;
  };
  class Stub final : public StubInterface {
   public:
    Stub(const std::shared_ptr< ::grpc::ChannelInterface>& channel, const ::grpc::StubOptions& options = ::grpc::StubOptions());
    ::grpc::Status LoadLogStore(::grpc::ClientContext* context, const ::newlogstorepb::LoadLogStoreReq& request, ::newlogstorepb::LoadLogStoreResp* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::newlogstorepb::LoadLogStoreResp>> AsyncLoadLogStore(::grpc::ClientContext* context, const ::newlogstorepb::LoadLogStoreReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::newlogstorepb::LoadLogStoreResp>>(AsyncLoadLogStoreRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::newlogstorepb::LoadLogStoreResp>> PrepareAsyncLoadLogStore(::grpc::ClientContext* context, const ::newlogstorepb::LoadLogStoreReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::newlogstorepb::LoadLogStoreResp>>(PrepareAsyncLoadLogStoreRaw(context, request, cq));
    }
    ::grpc::Status Open(::grpc::ClientContext* context, const ::newlogstorepb::OpenReq& request, ::newlogstorepb::OpenResp* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::newlogstorepb::OpenResp>> AsyncOpen(::grpc::ClientContext* context, const ::newlogstorepb::OpenReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::newlogstorepb::OpenResp>>(AsyncOpenRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::newlogstorepb::OpenResp>> PrepareAsyncOpen(::grpc::ClientContext* context, const ::newlogstorepb::OpenReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::newlogstorepb::OpenResp>>(PrepareAsyncOpenRaw(context, request, cq));
    }
    ::grpc::Status Close(::grpc::ClientContext* context, const ::newlogstorepb::CloseReq& request, ::newlogstorepb::CloseResp* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::newlogstorepb::CloseResp>> AsyncClose(::grpc::ClientContext* context, const ::newlogstorepb::CloseReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::newlogstorepb::CloseResp>>(AsyncCloseRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::newlogstorepb::CloseResp>> PrepareAsyncClose(::grpc::ClientContext* context, const ::newlogstorepb::CloseReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::newlogstorepb::CloseResp>>(PrepareAsyncCloseRaw(context, request, cq));
    }
    ::grpc::Status Pwrite(::grpc::ClientContext* context, const ::newlogstorepb::PwriteReq& request, ::newlogstorepb::PwriteResp* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::newlogstorepb::PwriteResp>> AsyncPwrite(::grpc::ClientContext* context, const ::newlogstorepb::PwriteReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::newlogstorepb::PwriteResp>>(AsyncPwriteRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::newlogstorepb::PwriteResp>> PrepareAsyncPwrite(::grpc::ClientContext* context, const ::newlogstorepb::PwriteReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::newlogstorepb::PwriteResp>>(PrepareAsyncPwriteRaw(context, request, cq));
    }
    ::grpc::Status Pread(::grpc::ClientContext* context, const ::newlogstorepb::PreadReq& request, ::newlogstorepb::PreadResp* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::newlogstorepb::PreadResp>> AsyncPread(::grpc::ClientContext* context, const ::newlogstorepb::PreadReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::newlogstorepb::PreadResp>>(AsyncPreadRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::newlogstorepb::PreadResp>> PrepareAsyncPread(::grpc::ClientContext* context, const ::newlogstorepb::PreadReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::newlogstorepb::PreadResp>>(PrepareAsyncPreadRaw(context, request, cq));
    }
    ::grpc::Status Fallocate(::grpc::ClientContext* context, const ::newlogstorepb::FallocateReq& request, ::newlogstorepb::FallocateResp* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::newlogstorepb::FallocateResp>> AsyncFallocate(::grpc::ClientContext* context, const ::newlogstorepb::FallocateReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::newlogstorepb::FallocateResp>>(AsyncFallocateRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::newlogstorepb::FallocateResp>> PrepareAsyncFallocate(::grpc::ClientContext* context, const ::newlogstorepb::FallocateReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::newlogstorepb::FallocateResp>>(PrepareAsyncFallocateRaw(context, request, cq));
    }
    ::grpc::Status Ftruncate(::grpc::ClientContext* context, const ::newlogstorepb::FtruncateReq& request, ::newlogstorepb::FtruncateResp* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::newlogstorepb::FtruncateResp>> AsyncFtruncate(::grpc::ClientContext* context, const ::newlogstorepb::FtruncateReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::newlogstorepb::FtruncateResp>>(AsyncFtruncateRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::newlogstorepb::FtruncateResp>> PrepareAsyncFtruncate(::grpc::ClientContext* context, const ::newlogstorepb::FtruncateReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::newlogstorepb::FtruncateResp>>(PrepareAsyncFtruncateRaw(context, request, cq));
    }
    ::grpc::Status Scandir(::grpc::ClientContext* context, const ::newlogstorepb::ScanDirReq& request, ::newlogstorepb::ScanDirResp* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::newlogstorepb::ScanDirResp>> AsyncScandir(::grpc::ClientContext* context, const ::newlogstorepb::ScanDirReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::newlogstorepb::ScanDirResp>>(AsyncScandirRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::newlogstorepb::ScanDirResp>> PrepareAsyncScandir(::grpc::ClientContext* context, const ::newlogstorepb::ScanDirReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::newlogstorepb::ScanDirResp>>(PrepareAsyncScandirRaw(context, request, cq));
    }
    ::grpc::Status Unlink(::grpc::ClientContext* context, const ::newlogstorepb::UnlinkReq& request, ::newlogstorepb::UnlinkResp* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::newlogstorepb::UnlinkResp>> AsyncUnlink(::grpc::ClientContext* context, const ::newlogstorepb::UnlinkReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::newlogstorepb::UnlinkResp>>(AsyncUnlinkRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::newlogstorepb::UnlinkResp>> PrepareAsyncUnlink(::grpc::ClientContext* context, const ::newlogstorepb::UnlinkReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::newlogstorepb::UnlinkResp>>(PrepareAsyncUnlinkRaw(context, request, cq));
    }
    ::grpc::Status Mkdir(::grpc::ClientContext* context, const ::newlogstorepb::MkdirReq& request, ::newlogstorepb::MkdirResp* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::newlogstorepb::MkdirResp>> AsyncMkdir(::grpc::ClientContext* context, const ::newlogstorepb::MkdirReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::newlogstorepb::MkdirResp>>(AsyncMkdirRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::newlogstorepb::MkdirResp>> PrepareAsyncMkdir(::grpc::ClientContext* context, const ::newlogstorepb::MkdirReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::newlogstorepb::MkdirResp>>(PrepareAsyncMkdirRaw(context, request, cq));
    }
    ::grpc::Status Rmdir(::grpc::ClientContext* context, const ::newlogstorepb::RmdirReq& request, ::newlogstorepb::RmdirResp* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::newlogstorepb::RmdirResp>> AsyncRmdir(::grpc::ClientContext* context, const ::newlogstorepb::RmdirReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::newlogstorepb::RmdirResp>>(AsyncRmdirRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::newlogstorepb::RmdirResp>> PrepareAsyncRmdir(::grpc::ClientContext* context, const ::newlogstorepb::RmdirReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::newlogstorepb::RmdirResp>>(PrepareAsyncRmdirRaw(context, request, cq));
    }
    ::grpc::Status Stat(::grpc::ClientContext* context, const ::newlogstorepb::StatReq& request, ::newlogstorepb::StatResp* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::newlogstorepb::StatResp>> AsyncStat(::grpc::ClientContext* context, const ::newlogstorepb::StatReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::newlogstorepb::StatResp>>(AsyncStatRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::newlogstorepb::StatResp>> PrepareAsyncStat(::grpc::ClientContext* context, const ::newlogstorepb::StatReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::newlogstorepb::StatResp>>(PrepareAsyncStatRaw(context, request, cq));
    }
    ::grpc::Status Rename(::grpc::ClientContext* context, const ::newlogstorepb::RenameReq& request, ::newlogstorepb::RenameResp* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::newlogstorepb::RenameResp>> AsyncRename(::grpc::ClientContext* context, const ::newlogstorepb::RenameReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::newlogstorepb::RenameResp>>(AsyncRenameRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::newlogstorepb::RenameResp>> PrepareAsyncRename(::grpc::ClientContext* context, const ::newlogstorepb::RenameReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::newlogstorepb::RenameResp>>(PrepareAsyncRenameRaw(context, request, cq));
    }
    ::grpc::Status Fsync(::grpc::ClientContext* context, const ::newlogstorepb::FsyncReq& request, ::newlogstorepb::FsyncResp* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::newlogstorepb::FsyncResp>> AsyncFsync(::grpc::ClientContext* context, const ::newlogstorepb::FsyncReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::newlogstorepb::FsyncResp>>(AsyncFsyncRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::newlogstorepb::FsyncResp>> PrepareAsyncFsync(::grpc::ClientContext* context, const ::newlogstorepb::FsyncReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::newlogstorepb::FsyncResp>>(PrepareAsyncFsyncRaw(context, request, cq));
    }
    ::grpc::Status GetLogStoreInfo(::grpc::ClientContext* context, const ::newlogstorepb::GetLogStoreInfoReq& request, ::newlogstorepb::GetLogStoreInfoResp* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::newlogstorepb::GetLogStoreInfoResp>> AsyncGetLogStoreInfo(::grpc::ClientContext* context, const ::newlogstorepb::GetLogStoreInfoReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::newlogstorepb::GetLogStoreInfoResp>>(AsyncGetLogStoreInfoRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::newlogstorepb::GetLogStoreInfoResp>> PrepareAsyncGetLogStoreInfo(::grpc::ClientContext* context, const ::newlogstorepb::GetLogStoreInfoReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::newlogstorepb::GetLogStoreInfoResp>>(PrepareAsyncGetLogStoreInfoRaw(context, request, cq));
    }
    ::grpc::Status BatchFallocate(::grpc::ClientContext* context, const ::newlogstorepb::BatchFallocateReq& request, ::newlogstorepb::BatchFallocateResp* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::newlogstorepb::BatchFallocateResp>> AsyncBatchFallocate(::grpc::ClientContext* context, const ::newlogstorepb::BatchFallocateReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::newlogstorepb::BatchFallocateResp>>(AsyncBatchFallocateRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::newlogstorepb::BatchFallocateResp>> PrepareAsyncBatchFallocate(::grpc::ClientContext* context, const ::newlogstorepb::BatchFallocateReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::newlogstorepb::BatchFallocateResp>>(PrepareAsyncBatchFallocateRaw(context, request, cq));
    }
    class async final :
      public StubInterface::async_interface {
     public:
      void LoadLogStore(::grpc::ClientContext* context, const ::newlogstorepb::LoadLogStoreReq* request, ::newlogstorepb::LoadLogStoreResp* response, std::function<void(::grpc::Status)>) override;
      void LoadLogStore(::grpc::ClientContext* context, const ::newlogstorepb::LoadLogStoreReq* request, ::newlogstorepb::LoadLogStoreResp* response, ::grpc::ClientUnaryReactor* reactor) override;
      void Open(::grpc::ClientContext* context, const ::newlogstorepb::OpenReq* request, ::newlogstorepb::OpenResp* response, std::function<void(::grpc::Status)>) override;
      void Open(::grpc::ClientContext* context, const ::newlogstorepb::OpenReq* request, ::newlogstorepb::OpenResp* response, ::grpc::ClientUnaryReactor* reactor) override;
      void Close(::grpc::ClientContext* context, const ::newlogstorepb::CloseReq* request, ::newlogstorepb::CloseResp* response, std::function<void(::grpc::Status)>) override;
      void Close(::grpc::ClientContext* context, const ::newlogstorepb::CloseReq* request, ::newlogstorepb::CloseResp* response, ::grpc::ClientUnaryReactor* reactor) override;
      void Pwrite(::grpc::ClientContext* context, const ::newlogstorepb::PwriteReq* request, ::newlogstorepb::PwriteResp* response, std::function<void(::grpc::Status)>) override;
      void Pwrite(::grpc::ClientContext* context, const ::newlogstorepb::PwriteReq* request, ::newlogstorepb::PwriteResp* response, ::grpc::ClientUnaryReactor* reactor) override;
      void Pread(::grpc::ClientContext* context, const ::newlogstorepb::PreadReq* request, ::newlogstorepb::PreadResp* response, std::function<void(::grpc::Status)>) override;
      void Pread(::grpc::ClientContext* context, const ::newlogstorepb::PreadReq* request, ::newlogstorepb::PreadResp* response, ::grpc::ClientUnaryReactor* reactor) override;
      void Fallocate(::grpc::ClientContext* context, const ::newlogstorepb::FallocateReq* request, ::newlogstorepb::FallocateResp* response, std::function<void(::grpc::Status)>) override;
      void Fallocate(::grpc::ClientContext* context, const ::newlogstorepb::FallocateReq* request, ::newlogstorepb::FallocateResp* response, ::grpc::ClientUnaryReactor* reactor) override;
      void Ftruncate(::grpc::ClientContext* context, const ::newlogstorepb::FtruncateReq* request, ::newlogstorepb::FtruncateResp* response, std::function<void(::grpc::Status)>) override;
      void Ftruncate(::grpc::ClientContext* context, const ::newlogstorepb::FtruncateReq* request, ::newlogstorepb::FtruncateResp* response, ::grpc::ClientUnaryReactor* reactor) override;
      void Scandir(::grpc::ClientContext* context, const ::newlogstorepb::ScanDirReq* request, ::newlogstorepb::ScanDirResp* response, std::function<void(::grpc::Status)>) override;
      void Scandir(::grpc::ClientContext* context, const ::newlogstorepb::ScanDirReq* request, ::newlogstorepb::ScanDirResp* response, ::grpc::ClientUnaryReactor* reactor) override;
      void Unlink(::grpc::ClientContext* context, const ::newlogstorepb::UnlinkReq* request, ::newlogstorepb::UnlinkResp* response, std::function<void(::grpc::Status)>) override;
      void Unlink(::grpc::ClientContext* context, const ::newlogstorepb::UnlinkReq* request, ::newlogstorepb::UnlinkResp* response, ::grpc::ClientUnaryReactor* reactor) override;
      void Mkdir(::grpc::ClientContext* context, const ::newlogstorepb::MkdirReq* request, ::newlogstorepb::MkdirResp* response, std::function<void(::grpc::Status)>) override;
      void Mkdir(::grpc::ClientContext* context, const ::newlogstorepb::MkdirReq* request, ::newlogstorepb::MkdirResp* response, ::grpc::ClientUnaryReactor* reactor) override;
      void Rmdir(::grpc::ClientContext* context, const ::newlogstorepb::RmdirReq* request, ::newlogstorepb::RmdirResp* response, std::function<void(::grpc::Status)>) override;
      void Rmdir(::grpc::ClientContext* context, const ::newlogstorepb::RmdirReq* request, ::newlogstorepb::RmdirResp* response, ::grpc::ClientUnaryReactor* reactor) override;
      void Stat(::grpc::ClientContext* context, const ::newlogstorepb::StatReq* request, ::newlogstorepb::StatResp* response, std::function<void(::grpc::Status)>) override;
      void Stat(::grpc::ClientContext* context, const ::newlogstorepb::StatReq* request, ::newlogstorepb::StatResp* response, ::grpc::ClientUnaryReactor* reactor) override;
      void Rename(::grpc::ClientContext* context, const ::newlogstorepb::RenameReq* request, ::newlogstorepb::RenameResp* response, std::function<void(::grpc::Status)>) override;
      void Rename(::grpc::ClientContext* context, const ::newlogstorepb::RenameReq* request, ::newlogstorepb::RenameResp* response, ::grpc::ClientUnaryReactor* reactor) override;
      void Fsync(::grpc::ClientContext* context, const ::newlogstorepb::FsyncReq* request, ::newlogstorepb::FsyncResp* response, std::function<void(::grpc::Status)>) override;
      void Fsync(::grpc::ClientContext* context, const ::newlogstorepb::FsyncReq* request, ::newlogstorepb::FsyncResp* response, ::grpc::ClientUnaryReactor* reactor) override;
      void GetLogStoreInfo(::grpc::ClientContext* context, const ::newlogstorepb::GetLogStoreInfoReq* request, ::newlogstorepb::GetLogStoreInfoResp* response, std::function<void(::grpc::Status)>) override;
      void GetLogStoreInfo(::grpc::ClientContext* context, const ::newlogstorepb::GetLogStoreInfoReq* request, ::newlogstorepb::GetLogStoreInfoResp* response, ::grpc::ClientUnaryReactor* reactor) override;
      void BatchFallocate(::grpc::ClientContext* context, const ::newlogstorepb::BatchFallocateReq* request, ::newlogstorepb::BatchFallocateResp* response, std::function<void(::grpc::Status)>) override;
      void BatchFallocate(::grpc::ClientContext* context, const ::newlogstorepb::BatchFallocateReq* request, ::newlogstorepb::BatchFallocateResp* response, ::grpc::ClientUnaryReactor* reactor) override;
     private:
      friend class Stub;
      explicit async(Stub* stub): stub_(stub) { }
      Stub* stub() { return stub_; }
      Stub* stub_;
    };
    class async* async() override { return &async_stub_; }

   private:
    std::shared_ptr< ::grpc::ChannelInterface> channel_;
    class async async_stub_{this};
    ::grpc::ClientAsyncResponseReader< ::newlogstorepb::LoadLogStoreResp>* AsyncLoadLogStoreRaw(::grpc::ClientContext* context, const ::newlogstorepb::LoadLogStoreReq& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::newlogstorepb::LoadLogStoreResp>* PrepareAsyncLoadLogStoreRaw(::grpc::ClientContext* context, const ::newlogstorepb::LoadLogStoreReq& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::newlogstorepb::OpenResp>* AsyncOpenRaw(::grpc::ClientContext* context, const ::newlogstorepb::OpenReq& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::newlogstorepb::OpenResp>* PrepareAsyncOpenRaw(::grpc::ClientContext* context, const ::newlogstorepb::OpenReq& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::newlogstorepb::CloseResp>* AsyncCloseRaw(::grpc::ClientContext* context, const ::newlogstorepb::CloseReq& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::newlogstorepb::CloseResp>* PrepareAsyncCloseRaw(::grpc::ClientContext* context, const ::newlogstorepb::CloseReq& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::newlogstorepb::PwriteResp>* AsyncPwriteRaw(::grpc::ClientContext* context, const ::newlogstorepb::PwriteReq& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::newlogstorepb::PwriteResp>* PrepareAsyncPwriteRaw(::grpc::ClientContext* context, const ::newlogstorepb::PwriteReq& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::newlogstorepb::PreadResp>* AsyncPreadRaw(::grpc::ClientContext* context, const ::newlogstorepb::PreadReq& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::newlogstorepb::PreadResp>* PrepareAsyncPreadRaw(::grpc::ClientContext* context, const ::newlogstorepb::PreadReq& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::newlogstorepb::FallocateResp>* AsyncFallocateRaw(::grpc::ClientContext* context, const ::newlogstorepb::FallocateReq& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::newlogstorepb::FallocateResp>* PrepareAsyncFallocateRaw(::grpc::ClientContext* context, const ::newlogstorepb::FallocateReq& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::newlogstorepb::FtruncateResp>* AsyncFtruncateRaw(::grpc::ClientContext* context, const ::newlogstorepb::FtruncateReq& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::newlogstorepb::FtruncateResp>* PrepareAsyncFtruncateRaw(::grpc::ClientContext* context, const ::newlogstorepb::FtruncateReq& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::newlogstorepb::ScanDirResp>* AsyncScandirRaw(::grpc::ClientContext* context, const ::newlogstorepb::ScanDirReq& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::newlogstorepb::ScanDirResp>* PrepareAsyncScandirRaw(::grpc::ClientContext* context, const ::newlogstorepb::ScanDirReq& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::newlogstorepb::UnlinkResp>* AsyncUnlinkRaw(::grpc::ClientContext* context, const ::newlogstorepb::UnlinkReq& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::newlogstorepb::UnlinkResp>* PrepareAsyncUnlinkRaw(::grpc::ClientContext* context, const ::newlogstorepb::UnlinkReq& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::newlogstorepb::MkdirResp>* AsyncMkdirRaw(::grpc::ClientContext* context, const ::newlogstorepb::MkdirReq& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::newlogstorepb::MkdirResp>* PrepareAsyncMkdirRaw(::grpc::ClientContext* context, const ::newlogstorepb::MkdirReq& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::newlogstorepb::RmdirResp>* AsyncRmdirRaw(::grpc::ClientContext* context, const ::newlogstorepb::RmdirReq& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::newlogstorepb::RmdirResp>* PrepareAsyncRmdirRaw(::grpc::ClientContext* context, const ::newlogstorepb::RmdirReq& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::newlogstorepb::StatResp>* AsyncStatRaw(::grpc::ClientContext* context, const ::newlogstorepb::StatReq& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::newlogstorepb::StatResp>* PrepareAsyncStatRaw(::grpc::ClientContext* context, const ::newlogstorepb::StatReq& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::newlogstorepb::RenameResp>* AsyncRenameRaw(::grpc::ClientContext* context, const ::newlogstorepb::RenameReq& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::newlogstorepb::RenameResp>* PrepareAsyncRenameRaw(::grpc::ClientContext* context, const ::newlogstorepb::RenameReq& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::newlogstorepb::FsyncResp>* AsyncFsyncRaw(::grpc::ClientContext* context, const ::newlogstorepb::FsyncReq& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::newlogstorepb::FsyncResp>* PrepareAsyncFsyncRaw(::grpc::ClientContext* context, const ::newlogstorepb::FsyncReq& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::newlogstorepb::GetLogStoreInfoResp>* AsyncGetLogStoreInfoRaw(::grpc::ClientContext* context, const ::newlogstorepb::GetLogStoreInfoReq& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::newlogstorepb::GetLogStoreInfoResp>* PrepareAsyncGetLogStoreInfoRaw(::grpc::ClientContext* context, const ::newlogstorepb::GetLogStoreInfoReq& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::newlogstorepb::BatchFallocateResp>* AsyncBatchFallocateRaw(::grpc::ClientContext* context, const ::newlogstorepb::BatchFallocateReq& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::newlogstorepb::BatchFallocateResp>* PrepareAsyncBatchFallocateRaw(::grpc::ClientContext* context, const ::newlogstorepb::BatchFallocateReq& request, ::grpc::CompletionQueue* cq) override;
    const ::grpc::internal::RpcMethod rpcmethod_LoadLogStore_;
    const ::grpc::internal::RpcMethod rpcmethod_Open_;
    const ::grpc::internal::RpcMethod rpcmethod_Close_;
    const ::grpc::internal::RpcMethod rpcmethod_Pwrite_;
    const ::grpc::internal::RpcMethod rpcmethod_Pread_;
    const ::grpc::internal::RpcMethod rpcmethod_Fallocate_;
    const ::grpc::internal::RpcMethod rpcmethod_Ftruncate_;
    const ::grpc::internal::RpcMethod rpcmethod_Scandir_;
    const ::grpc::internal::RpcMethod rpcmethod_Unlink_;
    const ::grpc::internal::RpcMethod rpcmethod_Mkdir_;
    const ::grpc::internal::RpcMethod rpcmethod_Rmdir_;
    const ::grpc::internal::RpcMethod rpcmethod_Stat_;
    const ::grpc::internal::RpcMethod rpcmethod_Rename_;
    const ::grpc::internal::RpcMethod rpcmethod_Fsync_;
    const ::grpc::internal::RpcMethod rpcmethod_GetLogStoreInfo_;
    const ::grpc::internal::RpcMethod rpcmethod_BatchFallocate_;
  };
  static std::unique_ptr<Stub> NewStub(const std::shared_ptr< ::grpc::ChannelInterface>& channel, const ::grpc::StubOptions& options = ::grpc::StubOptions());

  class Service : public ::grpc::Service {
   public:
    Service();
    virtual ~Service();
    // load logstore
    virtual ::grpc::Status LoadLogStore(::grpc::ServerContext* context, const ::newlogstorepb::LoadLogStoreReq* request, ::newlogstorepb::LoadLogStoreResp* response);
    // open a file
    virtual ::grpc::Status Open(::grpc::ServerContext* context, const ::newlogstorepb::OpenReq* request, ::newlogstorepb::OpenResp* response);
    // close a file
    virtual ::grpc::Status Close(::grpc::ServerContext* context, const ::newlogstorepb::CloseReq* request, ::newlogstorepb::CloseResp* response);
    // pwrite to a file
    virtual ::grpc::Status Pwrite(::grpc::ServerContext* context, const ::newlogstorepb::PwriteReq* request, ::newlogstorepb::PwriteResp* response);
    // pread from a file
    virtual ::grpc::Status Pread(::grpc::ServerContext* context, const ::newlogstorepb::PreadReq* request, ::newlogstorepb::PreadResp* response);
    // fallocate a file to designated size
    virtual ::grpc::Status Fallocate(::grpc::ServerContext* context, const ::newlogstorepb::FallocateReq* request, ::newlogstorepb::FallocateResp* response);
    // ftruncate a file
    virtual ::grpc::Status Ftruncate(::grpc::ServerContext* context, const ::newlogstorepb::FtruncateReq* request, ::newlogstorepb::FtruncateResp* response);
    // scan a dir
    virtual ::grpc::Status Scandir(::grpc::ServerContext* context, const ::newlogstorepb::ScanDirReq* request, ::newlogstorepb::ScanDirResp* response);
    // unlink
    virtual ::grpc::Status Unlink(::grpc::ServerContext* context, const ::newlogstorepb::UnlinkReq* request, ::newlogstorepb::UnlinkResp* response);
    // mkdir
    virtual ::grpc::Status Mkdir(::grpc::ServerContext* context, const ::newlogstorepb::MkdirReq* request, ::newlogstorepb::MkdirResp* response);
    // rmdir
    virtual ::grpc::Status Rmdir(::grpc::ServerContext* context, const ::newlogstorepb::RmdirReq* request, ::newlogstorepb::RmdirResp* response);
    // stat interface
    virtual ::grpc::Status Stat(::grpc::ServerContext* context, const ::newlogstorepb::StatReq* request, ::newlogstorepb::StatResp* response);
    // rename interface
    virtual ::grpc::Status Rename(::grpc::ServerContext* context, const ::newlogstorepb::RenameReq* request, ::newlogstorepb::RenameResp* response);
    // fsync interface
    virtual ::grpc::Status Fsync(::grpc::ServerContext* context, const ::newlogstorepb::FsyncReq* request, ::newlogstorepb::FsyncResp* response);
    // get logstore info interface
    virtual ::grpc::Status GetLogStoreInfo(::grpc::ServerContext* context, const ::newlogstorepb::GetLogStoreInfoReq* request, ::newlogstorepb::GetLogStoreInfoResp* response);
    // batch fallocate interface
    virtual ::grpc::Status BatchFallocate(::grpc::ServerContext* context, const ::newlogstorepb::BatchFallocateReq* request, ::newlogstorepb::BatchFallocateResp* response);
  };
  template <class BaseClass>
  class WithAsyncMethod_LoadLogStore : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_LoadLogStore() {
      ::grpc::Service::MarkMethodAsync(0);
    }
    ~WithAsyncMethod_LoadLogStore() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status LoadLogStore(::grpc::ServerContext* /*context*/, const ::newlogstorepb::LoadLogStoreReq* /*request*/, ::newlogstorepb::LoadLogStoreResp* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestLoadLogStore(::grpc::ServerContext* context, ::newlogstorepb::LoadLogStoreReq* request, ::grpc::ServerAsyncResponseWriter< ::newlogstorepb::LoadLogStoreResp>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(0, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_Open : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_Open() {
      ::grpc::Service::MarkMethodAsync(1);
    }
    ~WithAsyncMethod_Open() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Open(::grpc::ServerContext* /*context*/, const ::newlogstorepb::OpenReq* /*request*/, ::newlogstorepb::OpenResp* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestOpen(::grpc::ServerContext* context, ::newlogstorepb::OpenReq* request, ::grpc::ServerAsyncResponseWriter< ::newlogstorepb::OpenResp>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(1, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_Close : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_Close() {
      ::grpc::Service::MarkMethodAsync(2);
    }
    ~WithAsyncMethod_Close() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Close(::grpc::ServerContext* /*context*/, const ::newlogstorepb::CloseReq* /*request*/, ::newlogstorepb::CloseResp* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestClose(::grpc::ServerContext* context, ::newlogstorepb::CloseReq* request, ::grpc::ServerAsyncResponseWriter< ::newlogstorepb::CloseResp>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(2, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_Pwrite : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_Pwrite() {
      ::grpc::Service::MarkMethodAsync(3);
    }
    ~WithAsyncMethod_Pwrite() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Pwrite(::grpc::ServerContext* /*context*/, const ::newlogstorepb::PwriteReq* /*request*/, ::newlogstorepb::PwriteResp* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestPwrite(::grpc::ServerContext* context, ::newlogstorepb::PwriteReq* request, ::grpc::ServerAsyncResponseWriter< ::newlogstorepb::PwriteResp>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(3, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_Pread : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_Pread() {
      ::grpc::Service::MarkMethodAsync(4);
    }
    ~WithAsyncMethod_Pread() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Pread(::grpc::ServerContext* /*context*/, const ::newlogstorepb::PreadReq* /*request*/, ::newlogstorepb::PreadResp* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestPread(::grpc::ServerContext* context, ::newlogstorepb::PreadReq* request, ::grpc::ServerAsyncResponseWriter< ::newlogstorepb::PreadResp>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(4, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_Fallocate : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_Fallocate() {
      ::grpc::Service::MarkMethodAsync(5);
    }
    ~WithAsyncMethod_Fallocate() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Fallocate(::grpc::ServerContext* /*context*/, const ::newlogstorepb::FallocateReq* /*request*/, ::newlogstorepb::FallocateResp* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestFallocate(::grpc::ServerContext* context, ::newlogstorepb::FallocateReq* request, ::grpc::ServerAsyncResponseWriter< ::newlogstorepb::FallocateResp>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(5, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_Ftruncate : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_Ftruncate() {
      ::grpc::Service::MarkMethodAsync(6);
    }
    ~WithAsyncMethod_Ftruncate() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Ftruncate(::grpc::ServerContext* /*context*/, const ::newlogstorepb::FtruncateReq* /*request*/, ::newlogstorepb::FtruncateResp* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestFtruncate(::grpc::ServerContext* context, ::newlogstorepb::FtruncateReq* request, ::grpc::ServerAsyncResponseWriter< ::newlogstorepb::FtruncateResp>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(6, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_Scandir : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_Scandir() {
      ::grpc::Service::MarkMethodAsync(7);
    }
    ~WithAsyncMethod_Scandir() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Scandir(::grpc::ServerContext* /*context*/, const ::newlogstorepb::ScanDirReq* /*request*/, ::newlogstorepb::ScanDirResp* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestScandir(::grpc::ServerContext* context, ::newlogstorepb::ScanDirReq* request, ::grpc::ServerAsyncResponseWriter< ::newlogstorepb::ScanDirResp>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(7, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_Unlink : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_Unlink() {
      ::grpc::Service::MarkMethodAsync(8);
    }
    ~WithAsyncMethod_Unlink() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Unlink(::grpc::ServerContext* /*context*/, const ::newlogstorepb::UnlinkReq* /*request*/, ::newlogstorepb::UnlinkResp* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestUnlink(::grpc::ServerContext* context, ::newlogstorepb::UnlinkReq* request, ::grpc::ServerAsyncResponseWriter< ::newlogstorepb::UnlinkResp>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(8, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_Mkdir : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_Mkdir() {
      ::grpc::Service::MarkMethodAsync(9);
    }
    ~WithAsyncMethod_Mkdir() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Mkdir(::grpc::ServerContext* /*context*/, const ::newlogstorepb::MkdirReq* /*request*/, ::newlogstorepb::MkdirResp* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestMkdir(::grpc::ServerContext* context, ::newlogstorepb::MkdirReq* request, ::grpc::ServerAsyncResponseWriter< ::newlogstorepb::MkdirResp>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(9, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_Rmdir : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_Rmdir() {
      ::grpc::Service::MarkMethodAsync(10);
    }
    ~WithAsyncMethod_Rmdir() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Rmdir(::grpc::ServerContext* /*context*/, const ::newlogstorepb::RmdirReq* /*request*/, ::newlogstorepb::RmdirResp* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestRmdir(::grpc::ServerContext* context, ::newlogstorepb::RmdirReq* request, ::grpc::ServerAsyncResponseWriter< ::newlogstorepb::RmdirResp>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(10, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_Stat : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_Stat() {
      ::grpc::Service::MarkMethodAsync(11);
    }
    ~WithAsyncMethod_Stat() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Stat(::grpc::ServerContext* /*context*/, const ::newlogstorepb::StatReq* /*request*/, ::newlogstorepb::StatResp* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestStat(::grpc::ServerContext* context, ::newlogstorepb::StatReq* request, ::grpc::ServerAsyncResponseWriter< ::newlogstorepb::StatResp>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(11, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_Rename : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_Rename() {
      ::grpc::Service::MarkMethodAsync(12);
    }
    ~WithAsyncMethod_Rename() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Rename(::grpc::ServerContext* /*context*/, const ::newlogstorepb::RenameReq* /*request*/, ::newlogstorepb::RenameResp* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestRename(::grpc::ServerContext* context, ::newlogstorepb::RenameReq* request, ::grpc::ServerAsyncResponseWriter< ::newlogstorepb::RenameResp>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(12, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_Fsync : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_Fsync() {
      ::grpc::Service::MarkMethodAsync(13);
    }
    ~WithAsyncMethod_Fsync() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Fsync(::grpc::ServerContext* /*context*/, const ::newlogstorepb::FsyncReq* /*request*/, ::newlogstorepb::FsyncResp* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestFsync(::grpc::ServerContext* context, ::newlogstorepb::FsyncReq* request, ::grpc::ServerAsyncResponseWriter< ::newlogstorepb::FsyncResp>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(13, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_GetLogStoreInfo : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_GetLogStoreInfo() {
      ::grpc::Service::MarkMethodAsync(14);
    }
    ~WithAsyncMethod_GetLogStoreInfo() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetLogStoreInfo(::grpc::ServerContext* /*context*/, const ::newlogstorepb::GetLogStoreInfoReq* /*request*/, ::newlogstorepb::GetLogStoreInfoResp* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetLogStoreInfo(::grpc::ServerContext* context, ::newlogstorepb::GetLogStoreInfoReq* request, ::grpc::ServerAsyncResponseWriter< ::newlogstorepb::GetLogStoreInfoResp>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(14, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_BatchFallocate : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_BatchFallocate() {
      ::grpc::Service::MarkMethodAsync(15);
    }
    ~WithAsyncMethod_BatchFallocate() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status BatchFallocate(::grpc::ServerContext* /*context*/, const ::newlogstorepb::BatchFallocateReq* /*request*/, ::newlogstorepb::BatchFallocateResp* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestBatchFallocate(::grpc::ServerContext* context, ::newlogstorepb::BatchFallocateReq* request, ::grpc::ServerAsyncResponseWriter< ::newlogstorepb::BatchFallocateResp>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(15, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  typedef WithAsyncMethod_LoadLogStore<WithAsyncMethod_Open<WithAsyncMethod_Close<WithAsyncMethod_Pwrite<WithAsyncMethod_Pread<WithAsyncMethod_Fallocate<WithAsyncMethod_Ftruncate<WithAsyncMethod_Scandir<WithAsyncMethod_Unlink<WithAsyncMethod_Mkdir<WithAsyncMethod_Rmdir<WithAsyncMethod_Stat<WithAsyncMethod_Rename<WithAsyncMethod_Fsync<WithAsyncMethod_GetLogStoreInfo<WithAsyncMethod_BatchFallocate<Service > > > > > > > > > > > > > > > > AsyncService;
  template <class BaseClass>
  class WithCallbackMethod_LoadLogStore : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_LoadLogStore() {
      ::grpc::Service::MarkMethodCallback(0,
          new ::grpc::internal::CallbackUnaryHandler< ::newlogstorepb::LoadLogStoreReq, ::newlogstorepb::LoadLogStoreResp>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::newlogstorepb::LoadLogStoreReq* request, ::newlogstorepb::LoadLogStoreResp* response) { return this->LoadLogStore(context, request, response); }));}
    void SetMessageAllocatorFor_LoadLogStore(
        ::grpc::MessageAllocator< ::newlogstorepb::LoadLogStoreReq, ::newlogstorepb::LoadLogStoreResp>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(0);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::newlogstorepb::LoadLogStoreReq, ::newlogstorepb::LoadLogStoreResp>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_LoadLogStore() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status LoadLogStore(::grpc::ServerContext* /*context*/, const ::newlogstorepb::LoadLogStoreReq* /*request*/, ::newlogstorepb::LoadLogStoreResp* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* LoadLogStore(
      ::grpc::CallbackServerContext* /*context*/, const ::newlogstorepb::LoadLogStoreReq* /*request*/, ::newlogstorepb::LoadLogStoreResp* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_Open : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_Open() {
      ::grpc::Service::MarkMethodCallback(1,
          new ::grpc::internal::CallbackUnaryHandler< ::newlogstorepb::OpenReq, ::newlogstorepb::OpenResp>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::newlogstorepb::OpenReq* request, ::newlogstorepb::OpenResp* response) { return this->Open(context, request, response); }));}
    void SetMessageAllocatorFor_Open(
        ::grpc::MessageAllocator< ::newlogstorepb::OpenReq, ::newlogstorepb::OpenResp>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(1);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::newlogstorepb::OpenReq, ::newlogstorepb::OpenResp>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_Open() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Open(::grpc::ServerContext* /*context*/, const ::newlogstorepb::OpenReq* /*request*/, ::newlogstorepb::OpenResp* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* Open(
      ::grpc::CallbackServerContext* /*context*/, const ::newlogstorepb::OpenReq* /*request*/, ::newlogstorepb::OpenResp* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_Close : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_Close() {
      ::grpc::Service::MarkMethodCallback(2,
          new ::grpc::internal::CallbackUnaryHandler< ::newlogstorepb::CloseReq, ::newlogstorepb::CloseResp>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::newlogstorepb::CloseReq* request, ::newlogstorepb::CloseResp* response) { return this->Close(context, request, response); }));}
    void SetMessageAllocatorFor_Close(
        ::grpc::MessageAllocator< ::newlogstorepb::CloseReq, ::newlogstorepb::CloseResp>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(2);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::newlogstorepb::CloseReq, ::newlogstorepb::CloseResp>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_Close() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Close(::grpc::ServerContext* /*context*/, const ::newlogstorepb::CloseReq* /*request*/, ::newlogstorepb::CloseResp* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* Close(
      ::grpc::CallbackServerContext* /*context*/, const ::newlogstorepb::CloseReq* /*request*/, ::newlogstorepb::CloseResp* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_Pwrite : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_Pwrite() {
      ::grpc::Service::MarkMethodCallback(3,
          new ::grpc::internal::CallbackUnaryHandler< ::newlogstorepb::PwriteReq, ::newlogstorepb::PwriteResp>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::newlogstorepb::PwriteReq* request, ::newlogstorepb::PwriteResp* response) { return this->Pwrite(context, request, response); }));}
    void SetMessageAllocatorFor_Pwrite(
        ::grpc::MessageAllocator< ::newlogstorepb::PwriteReq, ::newlogstorepb::PwriteResp>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(3);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::newlogstorepb::PwriteReq, ::newlogstorepb::PwriteResp>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_Pwrite() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Pwrite(::grpc::ServerContext* /*context*/, const ::newlogstorepb::PwriteReq* /*request*/, ::newlogstorepb::PwriteResp* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* Pwrite(
      ::grpc::CallbackServerContext* /*context*/, const ::newlogstorepb::PwriteReq* /*request*/, ::newlogstorepb::PwriteResp* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_Pread : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_Pread() {
      ::grpc::Service::MarkMethodCallback(4,
          new ::grpc::internal::CallbackUnaryHandler< ::newlogstorepb::PreadReq, ::newlogstorepb::PreadResp>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::newlogstorepb::PreadReq* request, ::newlogstorepb::PreadResp* response) { return this->Pread(context, request, response); }));}
    void SetMessageAllocatorFor_Pread(
        ::grpc::MessageAllocator< ::newlogstorepb::PreadReq, ::newlogstorepb::PreadResp>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(4);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::newlogstorepb::PreadReq, ::newlogstorepb::PreadResp>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_Pread() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Pread(::grpc::ServerContext* /*context*/, const ::newlogstorepb::PreadReq* /*request*/, ::newlogstorepb::PreadResp* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* Pread(
      ::grpc::CallbackServerContext* /*context*/, const ::newlogstorepb::PreadReq* /*request*/, ::newlogstorepb::PreadResp* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_Fallocate : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_Fallocate() {
      ::grpc::Service::MarkMethodCallback(5,
          new ::grpc::internal::CallbackUnaryHandler< ::newlogstorepb::FallocateReq, ::newlogstorepb::FallocateResp>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::newlogstorepb::FallocateReq* request, ::newlogstorepb::FallocateResp* response) { return this->Fallocate(context, request, response); }));}
    void SetMessageAllocatorFor_Fallocate(
        ::grpc::MessageAllocator< ::newlogstorepb::FallocateReq, ::newlogstorepb::FallocateResp>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(5);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::newlogstorepb::FallocateReq, ::newlogstorepb::FallocateResp>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_Fallocate() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Fallocate(::grpc::ServerContext* /*context*/, const ::newlogstorepb::FallocateReq* /*request*/, ::newlogstorepb::FallocateResp* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* Fallocate(
      ::grpc::CallbackServerContext* /*context*/, const ::newlogstorepb::FallocateReq* /*request*/, ::newlogstorepb::FallocateResp* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_Ftruncate : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_Ftruncate() {
      ::grpc::Service::MarkMethodCallback(6,
          new ::grpc::internal::CallbackUnaryHandler< ::newlogstorepb::FtruncateReq, ::newlogstorepb::FtruncateResp>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::newlogstorepb::FtruncateReq* request, ::newlogstorepb::FtruncateResp* response) { return this->Ftruncate(context, request, response); }));}
    void SetMessageAllocatorFor_Ftruncate(
        ::grpc::MessageAllocator< ::newlogstorepb::FtruncateReq, ::newlogstorepb::FtruncateResp>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(6);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::newlogstorepb::FtruncateReq, ::newlogstorepb::FtruncateResp>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_Ftruncate() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Ftruncate(::grpc::ServerContext* /*context*/, const ::newlogstorepb::FtruncateReq* /*request*/, ::newlogstorepb::FtruncateResp* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* Ftruncate(
      ::grpc::CallbackServerContext* /*context*/, const ::newlogstorepb::FtruncateReq* /*request*/, ::newlogstorepb::FtruncateResp* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_Scandir : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_Scandir() {
      ::grpc::Service::MarkMethodCallback(7,
          new ::grpc::internal::CallbackUnaryHandler< ::newlogstorepb::ScanDirReq, ::newlogstorepb::ScanDirResp>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::newlogstorepb::ScanDirReq* request, ::newlogstorepb::ScanDirResp* response) { return this->Scandir(context, request, response); }));}
    void SetMessageAllocatorFor_Scandir(
        ::grpc::MessageAllocator< ::newlogstorepb::ScanDirReq, ::newlogstorepb::ScanDirResp>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(7);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::newlogstorepb::ScanDirReq, ::newlogstorepb::ScanDirResp>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_Scandir() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Scandir(::grpc::ServerContext* /*context*/, const ::newlogstorepb::ScanDirReq* /*request*/, ::newlogstorepb::ScanDirResp* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* Scandir(
      ::grpc::CallbackServerContext* /*context*/, const ::newlogstorepb::ScanDirReq* /*request*/, ::newlogstorepb::ScanDirResp* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_Unlink : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_Unlink() {
      ::grpc::Service::MarkMethodCallback(8,
          new ::grpc::internal::CallbackUnaryHandler< ::newlogstorepb::UnlinkReq, ::newlogstorepb::UnlinkResp>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::newlogstorepb::UnlinkReq* request, ::newlogstorepb::UnlinkResp* response) { return this->Unlink(context, request, response); }));}
    void SetMessageAllocatorFor_Unlink(
        ::grpc::MessageAllocator< ::newlogstorepb::UnlinkReq, ::newlogstorepb::UnlinkResp>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(8);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::newlogstorepb::UnlinkReq, ::newlogstorepb::UnlinkResp>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_Unlink() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Unlink(::grpc::ServerContext* /*context*/, const ::newlogstorepb::UnlinkReq* /*request*/, ::newlogstorepb::UnlinkResp* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* Unlink(
      ::grpc::CallbackServerContext* /*context*/, const ::newlogstorepb::UnlinkReq* /*request*/, ::newlogstorepb::UnlinkResp* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_Mkdir : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_Mkdir() {
      ::grpc::Service::MarkMethodCallback(9,
          new ::grpc::internal::CallbackUnaryHandler< ::newlogstorepb::MkdirReq, ::newlogstorepb::MkdirResp>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::newlogstorepb::MkdirReq* request, ::newlogstorepb::MkdirResp* response) { return this->Mkdir(context, request, response); }));}
    void SetMessageAllocatorFor_Mkdir(
        ::grpc::MessageAllocator< ::newlogstorepb::MkdirReq, ::newlogstorepb::MkdirResp>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(9);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::newlogstorepb::MkdirReq, ::newlogstorepb::MkdirResp>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_Mkdir() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Mkdir(::grpc::ServerContext* /*context*/, const ::newlogstorepb::MkdirReq* /*request*/, ::newlogstorepb::MkdirResp* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* Mkdir(
      ::grpc::CallbackServerContext* /*context*/, const ::newlogstorepb::MkdirReq* /*request*/, ::newlogstorepb::MkdirResp* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_Rmdir : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_Rmdir() {
      ::grpc::Service::MarkMethodCallback(10,
          new ::grpc::internal::CallbackUnaryHandler< ::newlogstorepb::RmdirReq, ::newlogstorepb::RmdirResp>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::newlogstorepb::RmdirReq* request, ::newlogstorepb::RmdirResp* response) { return this->Rmdir(context, request, response); }));}
    void SetMessageAllocatorFor_Rmdir(
        ::grpc::MessageAllocator< ::newlogstorepb::RmdirReq, ::newlogstorepb::RmdirResp>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(10);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::newlogstorepb::RmdirReq, ::newlogstorepb::RmdirResp>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_Rmdir() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Rmdir(::grpc::ServerContext* /*context*/, const ::newlogstorepb::RmdirReq* /*request*/, ::newlogstorepb::RmdirResp* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* Rmdir(
      ::grpc::CallbackServerContext* /*context*/, const ::newlogstorepb::RmdirReq* /*request*/, ::newlogstorepb::RmdirResp* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_Stat : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_Stat() {
      ::grpc::Service::MarkMethodCallback(11,
          new ::grpc::internal::CallbackUnaryHandler< ::newlogstorepb::StatReq, ::newlogstorepb::StatResp>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::newlogstorepb::StatReq* request, ::newlogstorepb::StatResp* response) { return this->Stat(context, request, response); }));}
    void SetMessageAllocatorFor_Stat(
        ::grpc::MessageAllocator< ::newlogstorepb::StatReq, ::newlogstorepb::StatResp>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(11);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::newlogstorepb::StatReq, ::newlogstorepb::StatResp>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_Stat() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Stat(::grpc::ServerContext* /*context*/, const ::newlogstorepb::StatReq* /*request*/, ::newlogstorepb::StatResp* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* Stat(
      ::grpc::CallbackServerContext* /*context*/, const ::newlogstorepb::StatReq* /*request*/, ::newlogstorepb::StatResp* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_Rename : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_Rename() {
      ::grpc::Service::MarkMethodCallback(12,
          new ::grpc::internal::CallbackUnaryHandler< ::newlogstorepb::RenameReq, ::newlogstorepb::RenameResp>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::newlogstorepb::RenameReq* request, ::newlogstorepb::RenameResp* response) { return this->Rename(context, request, response); }));}
    void SetMessageAllocatorFor_Rename(
        ::grpc::MessageAllocator< ::newlogstorepb::RenameReq, ::newlogstorepb::RenameResp>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(12);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::newlogstorepb::RenameReq, ::newlogstorepb::RenameResp>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_Rename() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Rename(::grpc::ServerContext* /*context*/, const ::newlogstorepb::RenameReq* /*request*/, ::newlogstorepb::RenameResp* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* Rename(
      ::grpc::CallbackServerContext* /*context*/, const ::newlogstorepb::RenameReq* /*request*/, ::newlogstorepb::RenameResp* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_Fsync : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_Fsync() {
      ::grpc::Service::MarkMethodCallback(13,
          new ::grpc::internal::CallbackUnaryHandler< ::newlogstorepb::FsyncReq, ::newlogstorepb::FsyncResp>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::newlogstorepb::FsyncReq* request, ::newlogstorepb::FsyncResp* response) { return this->Fsync(context, request, response); }));}
    void SetMessageAllocatorFor_Fsync(
        ::grpc::MessageAllocator< ::newlogstorepb::FsyncReq, ::newlogstorepb::FsyncResp>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(13);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::newlogstorepb::FsyncReq, ::newlogstorepb::FsyncResp>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_Fsync() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Fsync(::grpc::ServerContext* /*context*/, const ::newlogstorepb::FsyncReq* /*request*/, ::newlogstorepb::FsyncResp* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* Fsync(
      ::grpc::CallbackServerContext* /*context*/, const ::newlogstorepb::FsyncReq* /*request*/, ::newlogstorepb::FsyncResp* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_GetLogStoreInfo : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_GetLogStoreInfo() {
      ::grpc::Service::MarkMethodCallback(14,
          new ::grpc::internal::CallbackUnaryHandler< ::newlogstorepb::GetLogStoreInfoReq, ::newlogstorepb::GetLogStoreInfoResp>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::newlogstorepb::GetLogStoreInfoReq* request, ::newlogstorepb::GetLogStoreInfoResp* response) { return this->GetLogStoreInfo(context, request, response); }));}
    void SetMessageAllocatorFor_GetLogStoreInfo(
        ::grpc::MessageAllocator< ::newlogstorepb::GetLogStoreInfoReq, ::newlogstorepb::GetLogStoreInfoResp>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(14);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::newlogstorepb::GetLogStoreInfoReq, ::newlogstorepb::GetLogStoreInfoResp>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_GetLogStoreInfo() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetLogStoreInfo(::grpc::ServerContext* /*context*/, const ::newlogstorepb::GetLogStoreInfoReq* /*request*/, ::newlogstorepb::GetLogStoreInfoResp* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* GetLogStoreInfo(
      ::grpc::CallbackServerContext* /*context*/, const ::newlogstorepb::GetLogStoreInfoReq* /*request*/, ::newlogstorepb::GetLogStoreInfoResp* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_BatchFallocate : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_BatchFallocate() {
      ::grpc::Service::MarkMethodCallback(15,
          new ::grpc::internal::CallbackUnaryHandler< ::newlogstorepb::BatchFallocateReq, ::newlogstorepb::BatchFallocateResp>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::newlogstorepb::BatchFallocateReq* request, ::newlogstorepb::BatchFallocateResp* response) { return this->BatchFallocate(context, request, response); }));}
    void SetMessageAllocatorFor_BatchFallocate(
        ::grpc::MessageAllocator< ::newlogstorepb::BatchFallocateReq, ::newlogstorepb::BatchFallocateResp>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(15);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::newlogstorepb::BatchFallocateReq, ::newlogstorepb::BatchFallocateResp>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_BatchFallocate() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status BatchFallocate(::grpc::ServerContext* /*context*/, const ::newlogstorepb::BatchFallocateReq* /*request*/, ::newlogstorepb::BatchFallocateResp* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* BatchFallocate(
      ::grpc::CallbackServerContext* /*context*/, const ::newlogstorepb::BatchFallocateReq* /*request*/, ::newlogstorepb::BatchFallocateResp* /*response*/)  { return nullptr; }
  };
  typedef WithCallbackMethod_LoadLogStore<WithCallbackMethod_Open<WithCallbackMethod_Close<WithCallbackMethod_Pwrite<WithCallbackMethod_Pread<WithCallbackMethod_Fallocate<WithCallbackMethod_Ftruncate<WithCallbackMethod_Scandir<WithCallbackMethod_Unlink<WithCallbackMethod_Mkdir<WithCallbackMethod_Rmdir<WithCallbackMethod_Stat<WithCallbackMethod_Rename<WithCallbackMethod_Fsync<WithCallbackMethod_GetLogStoreInfo<WithCallbackMethod_BatchFallocate<Service > > > > > > > > > > > > > > > > CallbackService;
  typedef CallbackService ExperimentalCallbackService;
  template <class BaseClass>
  class WithGenericMethod_LoadLogStore : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_LoadLogStore() {
      ::grpc::Service::MarkMethodGeneric(0);
    }
    ~WithGenericMethod_LoadLogStore() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status LoadLogStore(::grpc::ServerContext* /*context*/, const ::newlogstorepb::LoadLogStoreReq* /*request*/, ::newlogstorepb::LoadLogStoreResp* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_Open : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_Open() {
      ::grpc::Service::MarkMethodGeneric(1);
    }
    ~WithGenericMethod_Open() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Open(::grpc::ServerContext* /*context*/, const ::newlogstorepb::OpenReq* /*request*/, ::newlogstorepb::OpenResp* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_Close : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_Close() {
      ::grpc::Service::MarkMethodGeneric(2);
    }
    ~WithGenericMethod_Close() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Close(::grpc::ServerContext* /*context*/, const ::newlogstorepb::CloseReq* /*request*/, ::newlogstorepb::CloseResp* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_Pwrite : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_Pwrite() {
      ::grpc::Service::MarkMethodGeneric(3);
    }
    ~WithGenericMethod_Pwrite() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Pwrite(::grpc::ServerContext* /*context*/, const ::newlogstorepb::PwriteReq* /*request*/, ::newlogstorepb::PwriteResp* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_Pread : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_Pread() {
      ::grpc::Service::MarkMethodGeneric(4);
    }
    ~WithGenericMethod_Pread() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Pread(::grpc::ServerContext* /*context*/, const ::newlogstorepb::PreadReq* /*request*/, ::newlogstorepb::PreadResp* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_Fallocate : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_Fallocate() {
      ::grpc::Service::MarkMethodGeneric(5);
    }
    ~WithGenericMethod_Fallocate() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Fallocate(::grpc::ServerContext* /*context*/, const ::newlogstorepb::FallocateReq* /*request*/, ::newlogstorepb::FallocateResp* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_Ftruncate : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_Ftruncate() {
      ::grpc::Service::MarkMethodGeneric(6);
    }
    ~WithGenericMethod_Ftruncate() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Ftruncate(::grpc::ServerContext* /*context*/, const ::newlogstorepb::FtruncateReq* /*request*/, ::newlogstorepb::FtruncateResp* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_Scandir : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_Scandir() {
      ::grpc::Service::MarkMethodGeneric(7);
    }
    ~WithGenericMethod_Scandir() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Scandir(::grpc::ServerContext* /*context*/, const ::newlogstorepb::ScanDirReq* /*request*/, ::newlogstorepb::ScanDirResp* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_Unlink : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_Unlink() {
      ::grpc::Service::MarkMethodGeneric(8);
    }
    ~WithGenericMethod_Unlink() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Unlink(::grpc::ServerContext* /*context*/, const ::newlogstorepb::UnlinkReq* /*request*/, ::newlogstorepb::UnlinkResp* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_Mkdir : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_Mkdir() {
      ::grpc::Service::MarkMethodGeneric(9);
    }
    ~WithGenericMethod_Mkdir() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Mkdir(::grpc::ServerContext* /*context*/, const ::newlogstorepb::MkdirReq* /*request*/, ::newlogstorepb::MkdirResp* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_Rmdir : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_Rmdir() {
      ::grpc::Service::MarkMethodGeneric(10);
    }
    ~WithGenericMethod_Rmdir() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Rmdir(::grpc::ServerContext* /*context*/, const ::newlogstorepb::RmdirReq* /*request*/, ::newlogstorepb::RmdirResp* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_Stat : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_Stat() {
      ::grpc::Service::MarkMethodGeneric(11);
    }
    ~WithGenericMethod_Stat() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Stat(::grpc::ServerContext* /*context*/, const ::newlogstorepb::StatReq* /*request*/, ::newlogstorepb::StatResp* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_Rename : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_Rename() {
      ::grpc::Service::MarkMethodGeneric(12);
    }
    ~WithGenericMethod_Rename() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Rename(::grpc::ServerContext* /*context*/, const ::newlogstorepb::RenameReq* /*request*/, ::newlogstorepb::RenameResp* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_Fsync : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_Fsync() {
      ::grpc::Service::MarkMethodGeneric(13);
    }
    ~WithGenericMethod_Fsync() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Fsync(::grpc::ServerContext* /*context*/, const ::newlogstorepb::FsyncReq* /*request*/, ::newlogstorepb::FsyncResp* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_GetLogStoreInfo : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_GetLogStoreInfo() {
      ::grpc::Service::MarkMethodGeneric(14);
    }
    ~WithGenericMethod_GetLogStoreInfo() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetLogStoreInfo(::grpc::ServerContext* /*context*/, const ::newlogstorepb::GetLogStoreInfoReq* /*request*/, ::newlogstorepb::GetLogStoreInfoResp* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_BatchFallocate : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_BatchFallocate() {
      ::grpc::Service::MarkMethodGeneric(15);
    }
    ~WithGenericMethod_BatchFallocate() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status BatchFallocate(::grpc::ServerContext* /*context*/, const ::newlogstorepb::BatchFallocateReq* /*request*/, ::newlogstorepb::BatchFallocateResp* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithRawMethod_LoadLogStore : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_LoadLogStore() {
      ::grpc::Service::MarkMethodRaw(0);
    }
    ~WithRawMethod_LoadLogStore() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status LoadLogStore(::grpc::ServerContext* /*context*/, const ::newlogstorepb::LoadLogStoreReq* /*request*/, ::newlogstorepb::LoadLogStoreResp* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestLoadLogStore(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(0, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_Open : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_Open() {
      ::grpc::Service::MarkMethodRaw(1);
    }
    ~WithRawMethod_Open() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Open(::grpc::ServerContext* /*context*/, const ::newlogstorepb::OpenReq* /*request*/, ::newlogstorepb::OpenResp* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestOpen(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(1, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_Close : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_Close() {
      ::grpc::Service::MarkMethodRaw(2);
    }
    ~WithRawMethod_Close() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Close(::grpc::ServerContext* /*context*/, const ::newlogstorepb::CloseReq* /*request*/, ::newlogstorepb::CloseResp* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestClose(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(2, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_Pwrite : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_Pwrite() {
      ::grpc::Service::MarkMethodRaw(3);
    }
    ~WithRawMethod_Pwrite() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Pwrite(::grpc::ServerContext* /*context*/, const ::newlogstorepb::PwriteReq* /*request*/, ::newlogstorepb::PwriteResp* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestPwrite(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(3, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_Pread : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_Pread() {
      ::grpc::Service::MarkMethodRaw(4);
    }
    ~WithRawMethod_Pread() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Pread(::grpc::ServerContext* /*context*/, const ::newlogstorepb::PreadReq* /*request*/, ::newlogstorepb::PreadResp* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestPread(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(4, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_Fallocate : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_Fallocate() {
      ::grpc::Service::MarkMethodRaw(5);
    }
    ~WithRawMethod_Fallocate() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Fallocate(::grpc::ServerContext* /*context*/, const ::newlogstorepb::FallocateReq* /*request*/, ::newlogstorepb::FallocateResp* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestFallocate(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(5, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_Ftruncate : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_Ftruncate() {
      ::grpc::Service::MarkMethodRaw(6);
    }
    ~WithRawMethod_Ftruncate() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Ftruncate(::grpc::ServerContext* /*context*/, const ::newlogstorepb::FtruncateReq* /*request*/, ::newlogstorepb::FtruncateResp* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestFtruncate(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(6, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_Scandir : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_Scandir() {
      ::grpc::Service::MarkMethodRaw(7);
    }
    ~WithRawMethod_Scandir() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Scandir(::grpc::ServerContext* /*context*/, const ::newlogstorepb::ScanDirReq* /*request*/, ::newlogstorepb::ScanDirResp* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestScandir(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(7, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_Unlink : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_Unlink() {
      ::grpc::Service::MarkMethodRaw(8);
    }
    ~WithRawMethod_Unlink() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Unlink(::grpc::ServerContext* /*context*/, const ::newlogstorepb::UnlinkReq* /*request*/, ::newlogstorepb::UnlinkResp* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestUnlink(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(8, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_Mkdir : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_Mkdir() {
      ::grpc::Service::MarkMethodRaw(9);
    }
    ~WithRawMethod_Mkdir() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Mkdir(::grpc::ServerContext* /*context*/, const ::newlogstorepb::MkdirReq* /*request*/, ::newlogstorepb::MkdirResp* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestMkdir(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(9, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_Rmdir : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_Rmdir() {
      ::grpc::Service::MarkMethodRaw(10);
    }
    ~WithRawMethod_Rmdir() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Rmdir(::grpc::ServerContext* /*context*/, const ::newlogstorepb::RmdirReq* /*request*/, ::newlogstorepb::RmdirResp* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestRmdir(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(10, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_Stat : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_Stat() {
      ::grpc::Service::MarkMethodRaw(11);
    }
    ~WithRawMethod_Stat() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Stat(::grpc::ServerContext* /*context*/, const ::newlogstorepb::StatReq* /*request*/, ::newlogstorepb::StatResp* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestStat(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(11, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_Rename : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_Rename() {
      ::grpc::Service::MarkMethodRaw(12);
    }
    ~WithRawMethod_Rename() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Rename(::grpc::ServerContext* /*context*/, const ::newlogstorepb::RenameReq* /*request*/, ::newlogstorepb::RenameResp* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestRename(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(12, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_Fsync : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_Fsync() {
      ::grpc::Service::MarkMethodRaw(13);
    }
    ~WithRawMethod_Fsync() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Fsync(::grpc::ServerContext* /*context*/, const ::newlogstorepb::FsyncReq* /*request*/, ::newlogstorepb::FsyncResp* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestFsync(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(13, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_GetLogStoreInfo : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_GetLogStoreInfo() {
      ::grpc::Service::MarkMethodRaw(14);
    }
    ~WithRawMethod_GetLogStoreInfo() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetLogStoreInfo(::grpc::ServerContext* /*context*/, const ::newlogstorepb::GetLogStoreInfoReq* /*request*/, ::newlogstorepb::GetLogStoreInfoResp* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetLogStoreInfo(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(14, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_BatchFallocate : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_BatchFallocate() {
      ::grpc::Service::MarkMethodRaw(15);
    }
    ~WithRawMethod_BatchFallocate() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status BatchFallocate(::grpc::ServerContext* /*context*/, const ::newlogstorepb::BatchFallocateReq* /*request*/, ::newlogstorepb::BatchFallocateResp* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestBatchFallocate(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(15, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_LoadLogStore : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_LoadLogStore() {
      ::grpc::Service::MarkMethodRawCallback(0,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->LoadLogStore(context, request, response); }));
    }
    ~WithRawCallbackMethod_LoadLogStore() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status LoadLogStore(::grpc::ServerContext* /*context*/, const ::newlogstorepb::LoadLogStoreReq* /*request*/, ::newlogstorepb::LoadLogStoreResp* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* LoadLogStore(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_Open : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_Open() {
      ::grpc::Service::MarkMethodRawCallback(1,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->Open(context, request, response); }));
    }
    ~WithRawCallbackMethod_Open() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Open(::grpc::ServerContext* /*context*/, const ::newlogstorepb::OpenReq* /*request*/, ::newlogstorepb::OpenResp* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* Open(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_Close : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_Close() {
      ::grpc::Service::MarkMethodRawCallback(2,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->Close(context, request, response); }));
    }
    ~WithRawCallbackMethod_Close() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Close(::grpc::ServerContext* /*context*/, const ::newlogstorepb::CloseReq* /*request*/, ::newlogstorepb::CloseResp* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* Close(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_Pwrite : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_Pwrite() {
      ::grpc::Service::MarkMethodRawCallback(3,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->Pwrite(context, request, response); }));
    }
    ~WithRawCallbackMethod_Pwrite() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Pwrite(::grpc::ServerContext* /*context*/, const ::newlogstorepb::PwriteReq* /*request*/, ::newlogstorepb::PwriteResp* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* Pwrite(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_Pread : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_Pread() {
      ::grpc::Service::MarkMethodRawCallback(4,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->Pread(context, request, response); }));
    }
    ~WithRawCallbackMethod_Pread() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Pread(::grpc::ServerContext* /*context*/, const ::newlogstorepb::PreadReq* /*request*/, ::newlogstorepb::PreadResp* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* Pread(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_Fallocate : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_Fallocate() {
      ::grpc::Service::MarkMethodRawCallback(5,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->Fallocate(context, request, response); }));
    }
    ~WithRawCallbackMethod_Fallocate() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Fallocate(::grpc::ServerContext* /*context*/, const ::newlogstorepb::FallocateReq* /*request*/, ::newlogstorepb::FallocateResp* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* Fallocate(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_Ftruncate : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_Ftruncate() {
      ::grpc::Service::MarkMethodRawCallback(6,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->Ftruncate(context, request, response); }));
    }
    ~WithRawCallbackMethod_Ftruncate() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Ftruncate(::grpc::ServerContext* /*context*/, const ::newlogstorepb::FtruncateReq* /*request*/, ::newlogstorepb::FtruncateResp* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* Ftruncate(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_Scandir : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_Scandir() {
      ::grpc::Service::MarkMethodRawCallback(7,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->Scandir(context, request, response); }));
    }
    ~WithRawCallbackMethod_Scandir() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Scandir(::grpc::ServerContext* /*context*/, const ::newlogstorepb::ScanDirReq* /*request*/, ::newlogstorepb::ScanDirResp* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* Scandir(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_Unlink : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_Unlink() {
      ::grpc::Service::MarkMethodRawCallback(8,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->Unlink(context, request, response); }));
    }
    ~WithRawCallbackMethod_Unlink() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Unlink(::grpc::ServerContext* /*context*/, const ::newlogstorepb::UnlinkReq* /*request*/, ::newlogstorepb::UnlinkResp* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* Unlink(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_Mkdir : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_Mkdir() {
      ::grpc::Service::MarkMethodRawCallback(9,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->Mkdir(context, request, response); }));
    }
    ~WithRawCallbackMethod_Mkdir() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Mkdir(::grpc::ServerContext* /*context*/, const ::newlogstorepb::MkdirReq* /*request*/, ::newlogstorepb::MkdirResp* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* Mkdir(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_Rmdir : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_Rmdir() {
      ::grpc::Service::MarkMethodRawCallback(10,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->Rmdir(context, request, response); }));
    }
    ~WithRawCallbackMethod_Rmdir() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Rmdir(::grpc::ServerContext* /*context*/, const ::newlogstorepb::RmdirReq* /*request*/, ::newlogstorepb::RmdirResp* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* Rmdir(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_Stat : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_Stat() {
      ::grpc::Service::MarkMethodRawCallback(11,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->Stat(context, request, response); }));
    }
    ~WithRawCallbackMethod_Stat() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Stat(::grpc::ServerContext* /*context*/, const ::newlogstorepb::StatReq* /*request*/, ::newlogstorepb::StatResp* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* Stat(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_Rename : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_Rename() {
      ::grpc::Service::MarkMethodRawCallback(12,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->Rename(context, request, response); }));
    }
    ~WithRawCallbackMethod_Rename() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Rename(::grpc::ServerContext* /*context*/, const ::newlogstorepb::RenameReq* /*request*/, ::newlogstorepb::RenameResp* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* Rename(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_Fsync : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_Fsync() {
      ::grpc::Service::MarkMethodRawCallback(13,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->Fsync(context, request, response); }));
    }
    ~WithRawCallbackMethod_Fsync() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Fsync(::grpc::ServerContext* /*context*/, const ::newlogstorepb::FsyncReq* /*request*/, ::newlogstorepb::FsyncResp* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* Fsync(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_GetLogStoreInfo : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_GetLogStoreInfo() {
      ::grpc::Service::MarkMethodRawCallback(14,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->GetLogStoreInfo(context, request, response); }));
    }
    ~WithRawCallbackMethod_GetLogStoreInfo() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetLogStoreInfo(::grpc::ServerContext* /*context*/, const ::newlogstorepb::GetLogStoreInfoReq* /*request*/, ::newlogstorepb::GetLogStoreInfoResp* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* GetLogStoreInfo(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_BatchFallocate : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_BatchFallocate() {
      ::grpc::Service::MarkMethodRawCallback(15,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->BatchFallocate(context, request, response); }));
    }
    ~WithRawCallbackMethod_BatchFallocate() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status BatchFallocate(::grpc::ServerContext* /*context*/, const ::newlogstorepb::BatchFallocateReq* /*request*/, ::newlogstorepb::BatchFallocateResp* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* BatchFallocate(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_LoadLogStore : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_LoadLogStore() {
      ::grpc::Service::MarkMethodStreamed(0,
        new ::grpc::internal::StreamedUnaryHandler<
          ::newlogstorepb::LoadLogStoreReq, ::newlogstorepb::LoadLogStoreResp>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::newlogstorepb::LoadLogStoreReq, ::newlogstorepb::LoadLogStoreResp>* streamer) {
                       return this->StreamedLoadLogStore(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_LoadLogStore() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status LoadLogStore(::grpc::ServerContext* /*context*/, const ::newlogstorepb::LoadLogStoreReq* /*request*/, ::newlogstorepb::LoadLogStoreResp* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedLoadLogStore(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::newlogstorepb::LoadLogStoreReq,::newlogstorepb::LoadLogStoreResp>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_Open : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_Open() {
      ::grpc::Service::MarkMethodStreamed(1,
        new ::grpc::internal::StreamedUnaryHandler<
          ::newlogstorepb::OpenReq, ::newlogstorepb::OpenResp>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::newlogstorepb::OpenReq, ::newlogstorepb::OpenResp>* streamer) {
                       return this->StreamedOpen(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_Open() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status Open(::grpc::ServerContext* /*context*/, const ::newlogstorepb::OpenReq* /*request*/, ::newlogstorepb::OpenResp* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedOpen(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::newlogstorepb::OpenReq,::newlogstorepb::OpenResp>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_Close : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_Close() {
      ::grpc::Service::MarkMethodStreamed(2,
        new ::grpc::internal::StreamedUnaryHandler<
          ::newlogstorepb::CloseReq, ::newlogstorepb::CloseResp>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::newlogstorepb::CloseReq, ::newlogstorepb::CloseResp>* streamer) {
                       return this->StreamedClose(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_Close() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status Close(::grpc::ServerContext* /*context*/, const ::newlogstorepb::CloseReq* /*request*/, ::newlogstorepb::CloseResp* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedClose(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::newlogstorepb::CloseReq,::newlogstorepb::CloseResp>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_Pwrite : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_Pwrite() {
      ::grpc::Service::MarkMethodStreamed(3,
        new ::grpc::internal::StreamedUnaryHandler<
          ::newlogstorepb::PwriteReq, ::newlogstorepb::PwriteResp>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::newlogstorepb::PwriteReq, ::newlogstorepb::PwriteResp>* streamer) {
                       return this->StreamedPwrite(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_Pwrite() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status Pwrite(::grpc::ServerContext* /*context*/, const ::newlogstorepb::PwriteReq* /*request*/, ::newlogstorepb::PwriteResp* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedPwrite(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::newlogstorepb::PwriteReq,::newlogstorepb::PwriteResp>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_Pread : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_Pread() {
      ::grpc::Service::MarkMethodStreamed(4,
        new ::grpc::internal::StreamedUnaryHandler<
          ::newlogstorepb::PreadReq, ::newlogstorepb::PreadResp>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::newlogstorepb::PreadReq, ::newlogstorepb::PreadResp>* streamer) {
                       return this->StreamedPread(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_Pread() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status Pread(::grpc::ServerContext* /*context*/, const ::newlogstorepb::PreadReq* /*request*/, ::newlogstorepb::PreadResp* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedPread(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::newlogstorepb::PreadReq,::newlogstorepb::PreadResp>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_Fallocate : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_Fallocate() {
      ::grpc::Service::MarkMethodStreamed(5,
        new ::grpc::internal::StreamedUnaryHandler<
          ::newlogstorepb::FallocateReq, ::newlogstorepb::FallocateResp>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::newlogstorepb::FallocateReq, ::newlogstorepb::FallocateResp>* streamer) {
                       return this->StreamedFallocate(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_Fallocate() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status Fallocate(::grpc::ServerContext* /*context*/, const ::newlogstorepb::FallocateReq* /*request*/, ::newlogstorepb::FallocateResp* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedFallocate(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::newlogstorepb::FallocateReq,::newlogstorepb::FallocateResp>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_Ftruncate : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_Ftruncate() {
      ::grpc::Service::MarkMethodStreamed(6,
        new ::grpc::internal::StreamedUnaryHandler<
          ::newlogstorepb::FtruncateReq, ::newlogstorepb::FtruncateResp>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::newlogstorepb::FtruncateReq, ::newlogstorepb::FtruncateResp>* streamer) {
                       return this->StreamedFtruncate(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_Ftruncate() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status Ftruncate(::grpc::ServerContext* /*context*/, const ::newlogstorepb::FtruncateReq* /*request*/, ::newlogstorepb::FtruncateResp* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedFtruncate(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::newlogstorepb::FtruncateReq,::newlogstorepb::FtruncateResp>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_Scandir : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_Scandir() {
      ::grpc::Service::MarkMethodStreamed(7,
        new ::grpc::internal::StreamedUnaryHandler<
          ::newlogstorepb::ScanDirReq, ::newlogstorepb::ScanDirResp>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::newlogstorepb::ScanDirReq, ::newlogstorepb::ScanDirResp>* streamer) {
                       return this->StreamedScandir(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_Scandir() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status Scandir(::grpc::ServerContext* /*context*/, const ::newlogstorepb::ScanDirReq* /*request*/, ::newlogstorepb::ScanDirResp* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedScandir(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::newlogstorepb::ScanDirReq,::newlogstorepb::ScanDirResp>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_Unlink : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_Unlink() {
      ::grpc::Service::MarkMethodStreamed(8,
        new ::grpc::internal::StreamedUnaryHandler<
          ::newlogstorepb::UnlinkReq, ::newlogstorepb::UnlinkResp>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::newlogstorepb::UnlinkReq, ::newlogstorepb::UnlinkResp>* streamer) {
                       return this->StreamedUnlink(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_Unlink() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status Unlink(::grpc::ServerContext* /*context*/, const ::newlogstorepb::UnlinkReq* /*request*/, ::newlogstorepb::UnlinkResp* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedUnlink(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::newlogstorepb::UnlinkReq,::newlogstorepb::UnlinkResp>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_Mkdir : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_Mkdir() {
      ::grpc::Service::MarkMethodStreamed(9,
        new ::grpc::internal::StreamedUnaryHandler<
          ::newlogstorepb::MkdirReq, ::newlogstorepb::MkdirResp>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::newlogstorepb::MkdirReq, ::newlogstorepb::MkdirResp>* streamer) {
                       return this->StreamedMkdir(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_Mkdir() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status Mkdir(::grpc::ServerContext* /*context*/, const ::newlogstorepb::MkdirReq* /*request*/, ::newlogstorepb::MkdirResp* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedMkdir(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::newlogstorepb::MkdirReq,::newlogstorepb::MkdirResp>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_Rmdir : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_Rmdir() {
      ::grpc::Service::MarkMethodStreamed(10,
        new ::grpc::internal::StreamedUnaryHandler<
          ::newlogstorepb::RmdirReq, ::newlogstorepb::RmdirResp>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::newlogstorepb::RmdirReq, ::newlogstorepb::RmdirResp>* streamer) {
                       return this->StreamedRmdir(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_Rmdir() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status Rmdir(::grpc::ServerContext* /*context*/, const ::newlogstorepb::RmdirReq* /*request*/, ::newlogstorepb::RmdirResp* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedRmdir(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::newlogstorepb::RmdirReq,::newlogstorepb::RmdirResp>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_Stat : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_Stat() {
      ::grpc::Service::MarkMethodStreamed(11,
        new ::grpc::internal::StreamedUnaryHandler<
          ::newlogstorepb::StatReq, ::newlogstorepb::StatResp>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::newlogstorepb::StatReq, ::newlogstorepb::StatResp>* streamer) {
                       return this->StreamedStat(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_Stat() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status Stat(::grpc::ServerContext* /*context*/, const ::newlogstorepb::StatReq* /*request*/, ::newlogstorepb::StatResp* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedStat(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::newlogstorepb::StatReq,::newlogstorepb::StatResp>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_Rename : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_Rename() {
      ::grpc::Service::MarkMethodStreamed(12,
        new ::grpc::internal::StreamedUnaryHandler<
          ::newlogstorepb::RenameReq, ::newlogstorepb::RenameResp>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::newlogstorepb::RenameReq, ::newlogstorepb::RenameResp>* streamer) {
                       return this->StreamedRename(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_Rename() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status Rename(::grpc::ServerContext* /*context*/, const ::newlogstorepb::RenameReq* /*request*/, ::newlogstorepb::RenameResp* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedRename(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::newlogstorepb::RenameReq,::newlogstorepb::RenameResp>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_Fsync : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_Fsync() {
      ::grpc::Service::MarkMethodStreamed(13,
        new ::grpc::internal::StreamedUnaryHandler<
          ::newlogstorepb::FsyncReq, ::newlogstorepb::FsyncResp>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::newlogstorepb::FsyncReq, ::newlogstorepb::FsyncResp>* streamer) {
                       return this->StreamedFsync(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_Fsync() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status Fsync(::grpc::ServerContext* /*context*/, const ::newlogstorepb::FsyncReq* /*request*/, ::newlogstorepb::FsyncResp* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedFsync(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::newlogstorepb::FsyncReq,::newlogstorepb::FsyncResp>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_GetLogStoreInfo : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_GetLogStoreInfo() {
      ::grpc::Service::MarkMethodStreamed(14,
        new ::grpc::internal::StreamedUnaryHandler<
          ::newlogstorepb::GetLogStoreInfoReq, ::newlogstorepb::GetLogStoreInfoResp>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::newlogstorepb::GetLogStoreInfoReq, ::newlogstorepb::GetLogStoreInfoResp>* streamer) {
                       return this->StreamedGetLogStoreInfo(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_GetLogStoreInfo() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status GetLogStoreInfo(::grpc::ServerContext* /*context*/, const ::newlogstorepb::GetLogStoreInfoReq* /*request*/, ::newlogstorepb::GetLogStoreInfoResp* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedGetLogStoreInfo(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::newlogstorepb::GetLogStoreInfoReq,::newlogstorepb::GetLogStoreInfoResp>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_BatchFallocate : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_BatchFallocate() {
      ::grpc::Service::MarkMethodStreamed(15,
        new ::grpc::internal::StreamedUnaryHandler<
          ::newlogstorepb::BatchFallocateReq, ::newlogstorepb::BatchFallocateResp>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::newlogstorepb::BatchFallocateReq, ::newlogstorepb::BatchFallocateResp>* streamer) {
                       return this->StreamedBatchFallocate(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_BatchFallocate() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status BatchFallocate(::grpc::ServerContext* /*context*/, const ::newlogstorepb::BatchFallocateReq* /*request*/, ::newlogstorepb::BatchFallocateResp* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedBatchFallocate(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::newlogstorepb::BatchFallocateReq,::newlogstorepb::BatchFallocateResp>* server_unary_streamer) = 0;
  };
  typedef WithStreamedUnaryMethod_LoadLogStore<WithStreamedUnaryMethod_Open<WithStreamedUnaryMethod_Close<WithStreamedUnaryMethod_Pwrite<WithStreamedUnaryMethod_Pread<WithStreamedUnaryMethod_Fallocate<WithStreamedUnaryMethod_Ftruncate<WithStreamedUnaryMethod_Scandir<WithStreamedUnaryMethod_Unlink<WithStreamedUnaryMethod_Mkdir<WithStreamedUnaryMethod_Rmdir<WithStreamedUnaryMethod_Stat<WithStreamedUnaryMethod_Rename<WithStreamedUnaryMethod_Fsync<WithStreamedUnaryMethod_GetLogStoreInfo<WithStreamedUnaryMethod_BatchFallocate<Service > > > > > > > > > > > > > > > > StreamedUnaryService;
  typedef Service SplitStreamedService;
  typedef WithStreamedUnaryMethod_LoadLogStore<WithStreamedUnaryMethod_Open<WithStreamedUnaryMethod_Close<WithStreamedUnaryMethod_Pwrite<WithStreamedUnaryMethod_Pread<WithStreamedUnaryMethod_Fallocate<WithStreamedUnaryMethod_Ftruncate<WithStreamedUnaryMethod_Scandir<WithStreamedUnaryMethod_Unlink<WithStreamedUnaryMethod_Mkdir<WithStreamedUnaryMethod_Rmdir<WithStreamedUnaryMethod_Stat<WithStreamedUnaryMethod_Rename<WithStreamedUnaryMethod_Fsync<WithStreamedUnaryMethod_GetLogStoreInfo<WithStreamedUnaryMethod_BatchFallocate<Service > > > > > > > > > > > > > > > > StreamedService;
};

}  // namespace newlogstorepb


#endif  // GRPC_newlogstorepb_2eproto__INCLUDED
