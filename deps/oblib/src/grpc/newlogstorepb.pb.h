// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: newlogstorepb.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_newlogstorepb_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_newlogstorepb_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3019000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3019005 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_newlogstorepb_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_newlogstorepb_2eproto {
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::AuxiliaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTable schema[33]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::FieldMetadata field_metadata[];
  static const ::PROTOBUF_NAMESPACE_ID::internal::SerializationTable serialization_table[];
  static const uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_newlogstorepb_2eproto;
namespace newlogstorepb {
class BatchFallocateReq;
struct BatchFallocateReqDefaultTypeInternal;
extern BatchFallocateReqDefaultTypeInternal _BatchFallocateReq_default_instance_;
class BatchFallocateResp;
struct BatchFallocateRespDefaultTypeInternal;
extern BatchFallocateRespDefaultTypeInternal _BatchFallocateResp_default_instance_;
class CloseReq;
struct CloseReqDefaultTypeInternal;
extern CloseReqDefaultTypeInternal _CloseReq_default_instance_;
class CloseResp;
struct CloseRespDefaultTypeInternal;
extern CloseRespDefaultTypeInternal _CloseResp_default_instance_;
class FallocateReq;
struct FallocateReqDefaultTypeInternal;
extern FallocateReqDefaultTypeInternal _FallocateReq_default_instance_;
class FallocateResp;
struct FallocateRespDefaultTypeInternal;
extern FallocateRespDefaultTypeInternal _FallocateResp_default_instance_;
class FsyncReq;
struct FsyncReqDefaultTypeInternal;
extern FsyncReqDefaultTypeInternal _FsyncReq_default_instance_;
class FsyncResp;
struct FsyncRespDefaultTypeInternal;
extern FsyncRespDefaultTypeInternal _FsyncResp_default_instance_;
class FtruncateReq;
struct FtruncateReqDefaultTypeInternal;
extern FtruncateReqDefaultTypeInternal _FtruncateReq_default_instance_;
class FtruncateResp;
struct FtruncateRespDefaultTypeInternal;
extern FtruncateRespDefaultTypeInternal _FtruncateResp_default_instance_;
class GetLogStoreInfoReq;
struct GetLogStoreInfoReqDefaultTypeInternal;
extern GetLogStoreInfoReqDefaultTypeInternal _GetLogStoreInfoReq_default_instance_;
class GetLogStoreInfoResp;
struct GetLogStoreInfoRespDefaultTypeInternal;
extern GetLogStoreInfoRespDefaultTypeInternal _GetLogStoreInfoResp_default_instance_;
class LoadLogStoreReq;
struct LoadLogStoreReqDefaultTypeInternal;
extern LoadLogStoreReqDefaultTypeInternal _LoadLogStoreReq_default_instance_;
class LoadLogStoreResp;
struct LoadLogStoreRespDefaultTypeInternal;
extern LoadLogStoreRespDefaultTypeInternal _LoadLogStoreResp_default_instance_;
class MkdirReq;
struct MkdirReqDefaultTypeInternal;
extern MkdirReqDefaultTypeInternal _MkdirReq_default_instance_;
class MkdirResp;
struct MkdirRespDefaultTypeInternal;
extern MkdirRespDefaultTypeInternal _MkdirResp_default_instance_;
class OpenReq;
struct OpenReqDefaultTypeInternal;
extern OpenReqDefaultTypeInternal _OpenReq_default_instance_;
class OpenResp;
struct OpenRespDefaultTypeInternal;
extern OpenRespDefaultTypeInternal _OpenResp_default_instance_;
class PreadReq;
struct PreadReqDefaultTypeInternal;
extern PreadReqDefaultTypeInternal _PreadReq_default_instance_;
class PreadResp;
struct PreadRespDefaultTypeInternal;
extern PreadRespDefaultTypeInternal _PreadResp_default_instance_;
class PwriteReq;
struct PwriteReqDefaultTypeInternal;
extern PwriteReqDefaultTypeInternal _PwriteReq_default_instance_;
class PwriteResp;
struct PwriteRespDefaultTypeInternal;
extern PwriteRespDefaultTypeInternal _PwriteResp_default_instance_;
class RenameReq;
struct RenameReqDefaultTypeInternal;
extern RenameReqDefaultTypeInternal _RenameReq_default_instance_;
class RenameResp;
struct RenameRespDefaultTypeInternal;
extern RenameRespDefaultTypeInternal _RenameResp_default_instance_;
class RmdirReq;
struct RmdirReqDefaultTypeInternal;
extern RmdirReqDefaultTypeInternal _RmdirReq_default_instance_;
class RmdirResp;
struct RmdirRespDefaultTypeInternal;
extern RmdirRespDefaultTypeInternal _RmdirResp_default_instance_;
class ScanDirReq;
struct ScanDirReqDefaultTypeInternal;
extern ScanDirReqDefaultTypeInternal _ScanDirReq_default_instance_;
class ScanDirResp;
struct ScanDirRespDefaultTypeInternal;
extern ScanDirRespDefaultTypeInternal _ScanDirResp_default_instance_;
class ScanDirResp1;
struct ScanDirResp1DefaultTypeInternal;
extern ScanDirResp1DefaultTypeInternal _ScanDirResp1_default_instance_;
class StatReq;
struct StatReqDefaultTypeInternal;
extern StatReqDefaultTypeInternal _StatReq_default_instance_;
class StatResp;
struct StatRespDefaultTypeInternal;
extern StatRespDefaultTypeInternal _StatResp_default_instance_;
class UnlinkReq;
struct UnlinkReqDefaultTypeInternal;
extern UnlinkReqDefaultTypeInternal _UnlinkReq_default_instance_;
class UnlinkResp;
struct UnlinkRespDefaultTypeInternal;
extern UnlinkRespDefaultTypeInternal _UnlinkResp_default_instance_;
}  // namespace newlogstorepb
PROTOBUF_NAMESPACE_OPEN
template<> ::newlogstorepb::BatchFallocateReq* Arena::CreateMaybeMessage<::newlogstorepb::BatchFallocateReq>(Arena*);
template<> ::newlogstorepb::BatchFallocateResp* Arena::CreateMaybeMessage<::newlogstorepb::BatchFallocateResp>(Arena*);
template<> ::newlogstorepb::CloseReq* Arena::CreateMaybeMessage<::newlogstorepb::CloseReq>(Arena*);
template<> ::newlogstorepb::CloseResp* Arena::CreateMaybeMessage<::newlogstorepb::CloseResp>(Arena*);
template<> ::newlogstorepb::FallocateReq* Arena::CreateMaybeMessage<::newlogstorepb::FallocateReq>(Arena*);
template<> ::newlogstorepb::FallocateResp* Arena::CreateMaybeMessage<::newlogstorepb::FallocateResp>(Arena*);
template<> ::newlogstorepb::FsyncReq* Arena::CreateMaybeMessage<::newlogstorepb::FsyncReq>(Arena*);
template<> ::newlogstorepb::FsyncResp* Arena::CreateMaybeMessage<::newlogstorepb::FsyncResp>(Arena*);
template<> ::newlogstorepb::FtruncateReq* Arena::CreateMaybeMessage<::newlogstorepb::FtruncateReq>(Arena*);
template<> ::newlogstorepb::FtruncateResp* Arena::CreateMaybeMessage<::newlogstorepb::FtruncateResp>(Arena*);
template<> ::newlogstorepb::GetLogStoreInfoReq* Arena::CreateMaybeMessage<::newlogstorepb::GetLogStoreInfoReq>(Arena*);
template<> ::newlogstorepb::GetLogStoreInfoResp* Arena::CreateMaybeMessage<::newlogstorepb::GetLogStoreInfoResp>(Arena*);
template<> ::newlogstorepb::LoadLogStoreReq* Arena::CreateMaybeMessage<::newlogstorepb::LoadLogStoreReq>(Arena*);
template<> ::newlogstorepb::LoadLogStoreResp* Arena::CreateMaybeMessage<::newlogstorepb::LoadLogStoreResp>(Arena*);
template<> ::newlogstorepb::MkdirReq* Arena::CreateMaybeMessage<::newlogstorepb::MkdirReq>(Arena*);
template<> ::newlogstorepb::MkdirResp* Arena::CreateMaybeMessage<::newlogstorepb::MkdirResp>(Arena*);
template<> ::newlogstorepb::OpenReq* Arena::CreateMaybeMessage<::newlogstorepb::OpenReq>(Arena*);
template<> ::newlogstorepb::OpenResp* Arena::CreateMaybeMessage<::newlogstorepb::OpenResp>(Arena*);
template<> ::newlogstorepb::PreadReq* Arena::CreateMaybeMessage<::newlogstorepb::PreadReq>(Arena*);
template<> ::newlogstorepb::PreadResp* Arena::CreateMaybeMessage<::newlogstorepb::PreadResp>(Arena*);
template<> ::newlogstorepb::PwriteReq* Arena::CreateMaybeMessage<::newlogstorepb::PwriteReq>(Arena*);
template<> ::newlogstorepb::PwriteResp* Arena::CreateMaybeMessage<::newlogstorepb::PwriteResp>(Arena*);
template<> ::newlogstorepb::RenameReq* Arena::CreateMaybeMessage<::newlogstorepb::RenameReq>(Arena*);
template<> ::newlogstorepb::RenameResp* Arena::CreateMaybeMessage<::newlogstorepb::RenameResp>(Arena*);
template<> ::newlogstorepb::RmdirReq* Arena::CreateMaybeMessage<::newlogstorepb::RmdirReq>(Arena*);
template<> ::newlogstorepb::RmdirResp* Arena::CreateMaybeMessage<::newlogstorepb::RmdirResp>(Arena*);
template<> ::newlogstorepb::ScanDirReq* Arena::CreateMaybeMessage<::newlogstorepb::ScanDirReq>(Arena*);
template<> ::newlogstorepb::ScanDirResp* Arena::CreateMaybeMessage<::newlogstorepb::ScanDirResp>(Arena*);
template<> ::newlogstorepb::ScanDirResp1* Arena::CreateMaybeMessage<::newlogstorepb::ScanDirResp1>(Arena*);
template<> ::newlogstorepb::StatReq* Arena::CreateMaybeMessage<::newlogstorepb::StatReq>(Arena*);
template<> ::newlogstorepb::StatResp* Arena::CreateMaybeMessage<::newlogstorepb::StatResp>(Arena*);
template<> ::newlogstorepb::UnlinkReq* Arena::CreateMaybeMessage<::newlogstorepb::UnlinkReq>(Arena*);
template<> ::newlogstorepb::UnlinkResp* Arena::CreateMaybeMessage<::newlogstorepb::UnlinkResp>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace newlogstorepb {

// ===================================================================

class LoadLogStoreReq final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:newlogstorepb.LoadLogStoreReq) */ {
 public:
  inline LoadLogStoreReq() : LoadLogStoreReq(nullptr) {}
  ~LoadLogStoreReq() override;
  explicit constexpr LoadLogStoreReq(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  LoadLogStoreReq(const LoadLogStoreReq& from);
  LoadLogStoreReq(LoadLogStoreReq&& from) noexcept
    : LoadLogStoreReq() {
    *this = ::std::move(from);
  }

  inline LoadLogStoreReq& operator=(const LoadLogStoreReq& from) {
    CopyFrom(from);
    return *this;
  }
  inline LoadLogStoreReq& operator=(LoadLogStoreReq&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const LoadLogStoreReq& default_instance() {
    return *internal_default_instance();
  }
  static inline const LoadLogStoreReq* internal_default_instance() {
    return reinterpret_cast<const LoadLogStoreReq*>(
               &_LoadLogStoreReq_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(LoadLogStoreReq& a, LoadLogStoreReq& b) {
    a.Swap(&b);
  }
  inline void Swap(LoadLogStoreReq* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(LoadLogStoreReq* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  LoadLogStoreReq* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<LoadLogStoreReq>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const LoadLogStoreReq& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const LoadLogStoreReq& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LoadLogStoreReq* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "newlogstorepb.LoadLogStoreReq";
  }
  protected:
  explicit LoadLogStoreReq(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kVersionFieldNumber = 1,
  };
  // int64 version = 1;
  void clear_version();
  int64_t version() const;
  void set_version(int64_t value);
  private:
  int64_t _internal_version() const;
  void _internal_set_version(int64_t value);
  public:

  // @@protoc_insertion_point(class_scope:newlogstorepb.LoadLogStoreReq)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  int64_t version_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_newlogstorepb_2eproto;
};
// -------------------------------------------------------------------

class LoadLogStoreResp final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:newlogstorepb.LoadLogStoreResp) */ {
 public:
  inline LoadLogStoreResp() : LoadLogStoreResp(nullptr) {}
  ~LoadLogStoreResp() override;
  explicit constexpr LoadLogStoreResp(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  LoadLogStoreResp(const LoadLogStoreResp& from);
  LoadLogStoreResp(LoadLogStoreResp&& from) noexcept
    : LoadLogStoreResp() {
    *this = ::std::move(from);
  }

  inline LoadLogStoreResp& operator=(const LoadLogStoreResp& from) {
    CopyFrom(from);
    return *this;
  }
  inline LoadLogStoreResp& operator=(LoadLogStoreResp&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const LoadLogStoreResp& default_instance() {
    return *internal_default_instance();
  }
  static inline const LoadLogStoreResp* internal_default_instance() {
    return reinterpret_cast<const LoadLogStoreResp*>(
               &_LoadLogStoreResp_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(LoadLogStoreResp& a, LoadLogStoreResp& b) {
    a.Swap(&b);
  }
  inline void Swap(LoadLogStoreResp* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(LoadLogStoreResp* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  LoadLogStoreResp* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<LoadLogStoreResp>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const LoadLogStoreResp& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const LoadLogStoreResp& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LoadLogStoreResp* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "newlogstorepb.LoadLogStoreResp";
  }
  protected:
  explicit LoadLogStoreResp(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRetCodeFieldNumber = 1,
    kVersionFieldNumber = 2,
    kEpochFieldNumber = 3,
  };
  // int64 ret_code = 1;
  void clear_ret_code();
  int64_t ret_code() const;
  void set_ret_code(int64_t value);
  private:
  int64_t _internal_ret_code() const;
  void _internal_set_ret_code(int64_t value);
  public:

  // int64 version = 2;
  void clear_version();
  int64_t version() const;
  void set_version(int64_t value);
  private:
  int64_t _internal_version() const;
  void _internal_set_version(int64_t value);
  public:

  // int64 epoch = 3;
  void clear_epoch();
  int64_t epoch() const;
  void set_epoch(int64_t value);
  private:
  int64_t _internal_epoch() const;
  void _internal_set_epoch(int64_t value);
  public:

  // @@protoc_insertion_point(class_scope:newlogstorepb.LoadLogStoreResp)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  int64_t ret_code_;
  int64_t version_;
  int64_t epoch_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_newlogstorepb_2eproto;
};
// -------------------------------------------------------------------

class OpenReq final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:newlogstorepb.OpenReq) */ {
 public:
  inline OpenReq() : OpenReq(nullptr) {}
  ~OpenReq() override;
  explicit constexpr OpenReq(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  OpenReq(const OpenReq& from);
  OpenReq(OpenReq&& from) noexcept
    : OpenReq() {
    *this = ::std::move(from);
  }

  inline OpenReq& operator=(const OpenReq& from) {
    CopyFrom(from);
    return *this;
  }
  inline OpenReq& operator=(OpenReq&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const OpenReq& default_instance() {
    return *internal_default_instance();
  }
  static inline const OpenReq* internal_default_instance() {
    return reinterpret_cast<const OpenReq*>(
               &_OpenReq_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(OpenReq& a, OpenReq& b) {
    a.Swap(&b);
  }
  inline void Swap(OpenReq* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(OpenReq* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  OpenReq* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<OpenReq>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const OpenReq& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const OpenReq& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(OpenReq* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "newlogstorepb.OpenReq";
  }
  protected:
  explicit OpenReq(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPathnameFieldNumber = 2,
    kEpochFieldNumber = 1,
    kFlagsFieldNumber = 3,
    kModeFieldNumber = 4,
  };
  // string pathname = 2;
  void clear_pathname();
  const std::string& pathname() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_pathname(ArgT0&& arg0, ArgT... args);
  std::string* mutable_pathname();
  PROTOBUF_NODISCARD std::string* release_pathname();
  void set_allocated_pathname(std::string* pathname);
  private:
  const std::string& _internal_pathname() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_pathname(const std::string& value);
  std::string* _internal_mutable_pathname();
  public:

  // int64 epoch = 1;
  void clear_epoch();
  int64_t epoch() const;
  void set_epoch(int64_t value);
  private:
  int64_t _internal_epoch() const;
  void _internal_set_epoch(int64_t value);
  public:

  // int32 flags = 3;
  void clear_flags();
  int32_t flags() const;
  void set_flags(int32_t value);
  private:
  int32_t _internal_flags() const;
  void _internal_set_flags(int32_t value);
  public:

  // uint32 mode = 4;
  void clear_mode();
  uint32_t mode() const;
  void set_mode(uint32_t value);
  private:
  uint32_t _internal_mode() const;
  void _internal_set_mode(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:newlogstorepb.OpenReq)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr pathname_;
  int64_t epoch_;
  int32_t flags_;
  uint32_t mode_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_newlogstorepb_2eproto;
};
// -------------------------------------------------------------------

class OpenResp final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:newlogstorepb.OpenResp) */ {
 public:
  inline OpenResp() : OpenResp(nullptr) {}
  ~OpenResp() override;
  explicit constexpr OpenResp(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  OpenResp(const OpenResp& from);
  OpenResp(OpenResp&& from) noexcept
    : OpenResp() {
    *this = ::std::move(from);
  }

  inline OpenResp& operator=(const OpenResp& from) {
    CopyFrom(from);
    return *this;
  }
  inline OpenResp& operator=(OpenResp&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const OpenResp& default_instance() {
    return *internal_default_instance();
  }
  static inline const OpenResp* internal_default_instance() {
    return reinterpret_cast<const OpenResp*>(
               &_OpenResp_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(OpenResp& a, OpenResp& b) {
    a.Swap(&b);
  }
  inline void Swap(OpenResp* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(OpenResp* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  OpenResp* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<OpenResp>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const OpenResp& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const OpenResp& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(OpenResp* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "newlogstorepb.OpenResp";
  }
  protected:
  explicit OpenResp(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRetCodeFieldNumber = 1,
    kErrNoFieldNumber = 2,
    kFdFieldNumber = 3,
  };
  // int64 ret_code = 1;
  void clear_ret_code();
  int64_t ret_code() const;
  void set_ret_code(int64_t value);
  private:
  int64_t _internal_ret_code() const;
  void _internal_set_ret_code(int64_t value);
  public:

  // int32 err_no = 2;
  void clear_err_no();
  int32_t err_no() const;
  void set_err_no(int32_t value);
  private:
  int32_t _internal_err_no() const;
  void _internal_set_err_no(int32_t value);
  public:

  // int32 fd = 3;
  void clear_fd();
  int32_t fd() const;
  void set_fd(int32_t value);
  private:
  int32_t _internal_fd() const;
  void _internal_set_fd(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:newlogstorepb.OpenResp)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  int64_t ret_code_;
  int32_t err_no_;
  int32_t fd_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_newlogstorepb_2eproto;
};
// -------------------------------------------------------------------

class CloseReq final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:newlogstorepb.CloseReq) */ {
 public:
  inline CloseReq() : CloseReq(nullptr) {}
  ~CloseReq() override;
  explicit constexpr CloseReq(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CloseReq(const CloseReq& from);
  CloseReq(CloseReq&& from) noexcept
    : CloseReq() {
    *this = ::std::move(from);
  }

  inline CloseReq& operator=(const CloseReq& from) {
    CopyFrom(from);
    return *this;
  }
  inline CloseReq& operator=(CloseReq&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CloseReq& default_instance() {
    return *internal_default_instance();
  }
  static inline const CloseReq* internal_default_instance() {
    return reinterpret_cast<const CloseReq*>(
               &_CloseReq_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(CloseReq& a, CloseReq& b) {
    a.Swap(&b);
  }
  inline void Swap(CloseReq* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CloseReq* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CloseReq* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CloseReq>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CloseReq& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const CloseReq& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CloseReq* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "newlogstorepb.CloseReq";
  }
  protected:
  explicit CloseReq(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kEpochFieldNumber = 1,
    kFdFieldNumber = 2,
  };
  // int64 epoch = 1;
  void clear_epoch();
  int64_t epoch() const;
  void set_epoch(int64_t value);
  private:
  int64_t _internal_epoch() const;
  void _internal_set_epoch(int64_t value);
  public:

  // int32 fd = 2;
  void clear_fd();
  int32_t fd() const;
  void set_fd(int32_t value);
  private:
  int32_t _internal_fd() const;
  void _internal_set_fd(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:newlogstorepb.CloseReq)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  int64_t epoch_;
  int32_t fd_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_newlogstorepb_2eproto;
};
// -------------------------------------------------------------------

class CloseResp final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:newlogstorepb.CloseResp) */ {
 public:
  inline CloseResp() : CloseResp(nullptr) {}
  ~CloseResp() override;
  explicit constexpr CloseResp(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CloseResp(const CloseResp& from);
  CloseResp(CloseResp&& from) noexcept
    : CloseResp() {
    *this = ::std::move(from);
  }

  inline CloseResp& operator=(const CloseResp& from) {
    CopyFrom(from);
    return *this;
  }
  inline CloseResp& operator=(CloseResp&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CloseResp& default_instance() {
    return *internal_default_instance();
  }
  static inline const CloseResp* internal_default_instance() {
    return reinterpret_cast<const CloseResp*>(
               &_CloseResp_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(CloseResp& a, CloseResp& b) {
    a.Swap(&b);
  }
  inline void Swap(CloseResp* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CloseResp* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CloseResp* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CloseResp>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CloseResp& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const CloseResp& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CloseResp* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "newlogstorepb.CloseResp";
  }
  protected:
  explicit CloseResp(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRetCodeFieldNumber = 1,
    kErrNoFieldNumber = 2,
  };
  // int64 ret_code = 1;
  void clear_ret_code();
  int64_t ret_code() const;
  void set_ret_code(int64_t value);
  private:
  int64_t _internal_ret_code() const;
  void _internal_set_ret_code(int64_t value);
  public:

  // int32 err_no = 2;
  void clear_err_no();
  int32_t err_no() const;
  void set_err_no(int32_t value);
  private:
  int32_t _internal_err_no() const;
  void _internal_set_err_no(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:newlogstorepb.CloseResp)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  int64_t ret_code_;
  int32_t err_no_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_newlogstorepb_2eproto;
};
// -------------------------------------------------------------------

class PwriteReq final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:newlogstorepb.PwriteReq) */ {
 public:
  inline PwriteReq() : PwriteReq(nullptr) {}
  ~PwriteReq() override;
  explicit constexpr PwriteReq(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  PwriteReq(const PwriteReq& from);
  PwriteReq(PwriteReq&& from) noexcept
    : PwriteReq() {
    *this = ::std::move(from);
  }

  inline PwriteReq& operator=(const PwriteReq& from) {
    CopyFrom(from);
    return *this;
  }
  inline PwriteReq& operator=(PwriteReq&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PwriteReq& default_instance() {
    return *internal_default_instance();
  }
  static inline const PwriteReq* internal_default_instance() {
    return reinterpret_cast<const PwriteReq*>(
               &_PwriteReq_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(PwriteReq& a, PwriteReq& b) {
    a.Swap(&b);
  }
  inline void Swap(PwriteReq* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PwriteReq* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PwriteReq* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<PwriteReq>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const PwriteReq& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const PwriteReq& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PwriteReq* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "newlogstorepb.PwriteReq";
  }
  protected:
  explicit PwriteReq(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kBufFieldNumber = 4,
    kEpochFieldNumber = 1,
    kSeqFieldNumber = 2,
    kSizeFieldNumber = 5,
    kFdFieldNumber = 3,
    kWriteModeFieldNumber = 7,
    kOffsetFieldNumber = 6,
  };
  // bytes buf = 4;
  void clear_buf();
  const std::string& buf() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_buf(ArgT0&& arg0, ArgT... args);
  std::string* mutable_buf();
  PROTOBUF_NODISCARD std::string* release_buf();
  void set_allocated_buf(std::string* buf);
  private:
  const std::string& _internal_buf() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_buf(const std::string& value);
  std::string* _internal_mutable_buf();
  public:

  // int64 epoch = 1;
  void clear_epoch();
  int64_t epoch() const;
  void set_epoch(int64_t value);
  private:
  int64_t _internal_epoch() const;
  void _internal_set_epoch(int64_t value);
  public:

  // int64 seq = 2;
  void clear_seq();
  int64_t seq() const;
  void set_seq(int64_t value);
  private:
  int64_t _internal_seq() const;
  void _internal_set_seq(int64_t value);
  public:

  // uint64 size = 5;
  void clear_size();
  uint64_t size() const;
  void set_size(uint64_t value);
  private:
  uint64_t _internal_size() const;
  void _internal_set_size(uint64_t value);
  public:

  // int32 fd = 3;
  void clear_fd();
  int32_t fd() const;
  void set_fd(int32_t value);
  private:
  int32_t _internal_fd() const;
  void _internal_set_fd(int32_t value);
  public:

  // int32 write_mode = 7;
  void clear_write_mode();
  int32_t write_mode() const;
  void set_write_mode(int32_t value);
  private:
  int32_t _internal_write_mode() const;
  void _internal_set_write_mode(int32_t value);
  public:

  // uint64 offset = 6;
  void clear_offset();
  uint64_t offset() const;
  void set_offset(uint64_t value);
  private:
  uint64_t _internal_offset() const;
  void _internal_set_offset(uint64_t value);
  public:

  // @@protoc_insertion_point(class_scope:newlogstorepb.PwriteReq)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr buf_;
  int64_t epoch_;
  int64_t seq_;
  uint64_t size_;
  int32_t fd_;
  int32_t write_mode_;
  uint64_t offset_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_newlogstorepb_2eproto;
};
// -------------------------------------------------------------------

class PwriteResp final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:newlogstorepb.PwriteResp) */ {
 public:
  inline PwriteResp() : PwriteResp(nullptr) {}
  ~PwriteResp() override;
  explicit constexpr PwriteResp(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  PwriteResp(const PwriteResp& from);
  PwriteResp(PwriteResp&& from) noexcept
    : PwriteResp() {
    *this = ::std::move(from);
  }

  inline PwriteResp& operator=(const PwriteResp& from) {
    CopyFrom(from);
    return *this;
  }
  inline PwriteResp& operator=(PwriteResp&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PwriteResp& default_instance() {
    return *internal_default_instance();
  }
  static inline const PwriteResp* internal_default_instance() {
    return reinterpret_cast<const PwriteResp*>(
               &_PwriteResp_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(PwriteResp& a, PwriteResp& b) {
    a.Swap(&b);
  }
  inline void Swap(PwriteResp* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PwriteResp* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PwriteResp* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<PwriteResp>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const PwriteResp& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const PwriteResp& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PwriteResp* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "newlogstorepb.PwriteResp";
  }
  protected:
  explicit PwriteResp(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRetCodeFieldNumber = 1,
    kSizeFieldNumber = 3,
    kErrNoFieldNumber = 2,
  };
  // int64 ret_code = 1;
  void clear_ret_code();
  int64_t ret_code() const;
  void set_ret_code(int64_t value);
  private:
  int64_t _internal_ret_code() const;
  void _internal_set_ret_code(int64_t value);
  public:

  // int64 size = 3;
  void clear_size();
  int64_t size() const;
  void set_size(int64_t value);
  private:
  int64_t _internal_size() const;
  void _internal_set_size(int64_t value);
  public:

  // int32 err_no = 2;
  void clear_err_no();
  int32_t err_no() const;
  void set_err_no(int32_t value);
  private:
  int32_t _internal_err_no() const;
  void _internal_set_err_no(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:newlogstorepb.PwriteResp)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  int64_t ret_code_;
  int64_t size_;
  int32_t err_no_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_newlogstorepb_2eproto;
};
// -------------------------------------------------------------------

class PreadReq final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:newlogstorepb.PreadReq) */ {
 public:
  inline PreadReq() : PreadReq(nullptr) {}
  ~PreadReq() override;
  explicit constexpr PreadReq(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  PreadReq(const PreadReq& from);
  PreadReq(PreadReq&& from) noexcept
    : PreadReq() {
    *this = ::std::move(from);
  }

  inline PreadReq& operator=(const PreadReq& from) {
    CopyFrom(from);
    return *this;
  }
  inline PreadReq& operator=(PreadReq&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PreadReq& default_instance() {
    return *internal_default_instance();
  }
  static inline const PreadReq* internal_default_instance() {
    return reinterpret_cast<const PreadReq*>(
               &_PreadReq_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(PreadReq& a, PreadReq& b) {
    a.Swap(&b);
  }
  inline void Swap(PreadReq* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PreadReq* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PreadReq* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<PreadReq>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const PreadReq& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const PreadReq& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PreadReq* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "newlogstorepb.PreadReq";
  }
  protected:
  explicit PreadReq(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kEpochFieldNumber = 1,
    kSizeFieldNumber = 3,
    kOffsetFieldNumber = 4,
    kFdFieldNumber = 2,
  };
  // int64 epoch = 1;
  void clear_epoch();
  int64_t epoch() const;
  void set_epoch(int64_t value);
  private:
  int64_t _internal_epoch() const;
  void _internal_set_epoch(int64_t value);
  public:

  // uint64 size = 3;
  void clear_size();
  uint64_t size() const;
  void set_size(uint64_t value);
  private:
  uint64_t _internal_size() const;
  void _internal_set_size(uint64_t value);
  public:

  // uint64 offset = 4;
  void clear_offset();
  uint64_t offset() const;
  void set_offset(uint64_t value);
  private:
  uint64_t _internal_offset() const;
  void _internal_set_offset(uint64_t value);
  public:

  // int32 fd = 2;
  void clear_fd();
  int32_t fd() const;
  void set_fd(int32_t value);
  private:
  int32_t _internal_fd() const;
  void _internal_set_fd(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:newlogstorepb.PreadReq)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  int64_t epoch_;
  uint64_t size_;
  uint64_t offset_;
  int32_t fd_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_newlogstorepb_2eproto;
};
// -------------------------------------------------------------------

class PreadResp final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:newlogstorepb.PreadResp) */ {
 public:
  inline PreadResp() : PreadResp(nullptr) {}
  ~PreadResp() override;
  explicit constexpr PreadResp(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  PreadResp(const PreadResp& from);
  PreadResp(PreadResp&& from) noexcept
    : PreadResp() {
    *this = ::std::move(from);
  }

  inline PreadResp& operator=(const PreadResp& from) {
    CopyFrom(from);
    return *this;
  }
  inline PreadResp& operator=(PreadResp&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PreadResp& default_instance() {
    return *internal_default_instance();
  }
  static inline const PreadResp* internal_default_instance() {
    return reinterpret_cast<const PreadResp*>(
               &_PreadResp_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(PreadResp& a, PreadResp& b) {
    a.Swap(&b);
  }
  inline void Swap(PreadResp* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PreadResp* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PreadResp* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<PreadResp>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const PreadResp& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const PreadResp& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PreadResp* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "newlogstorepb.PreadResp";
  }
  protected:
  explicit PreadResp(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kBufFieldNumber = 3,
    kRetCodeFieldNumber = 1,
    kSizeFieldNumber = 4,
    kErrNoFieldNumber = 2,
  };
  // bytes buf = 3;
  void clear_buf();
  const std::string& buf() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_buf(ArgT0&& arg0, ArgT... args);
  std::string* mutable_buf();
  PROTOBUF_NODISCARD std::string* release_buf();
  void set_allocated_buf(std::string* buf);
  private:
  const std::string& _internal_buf() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_buf(const std::string& value);
  std::string* _internal_mutable_buf();
  public:

  // int64 ret_code = 1;
  void clear_ret_code();
  int64_t ret_code() const;
  void set_ret_code(int64_t value);
  private:
  int64_t _internal_ret_code() const;
  void _internal_set_ret_code(int64_t value);
  public:

  // int64 size = 4;
  void clear_size();
  int64_t size() const;
  void set_size(int64_t value);
  private:
  int64_t _internal_size() const;
  void _internal_set_size(int64_t value);
  public:

  // int32 err_no = 2;
  void clear_err_no();
  int32_t err_no() const;
  void set_err_no(int32_t value);
  private:
  int32_t _internal_err_no() const;
  void _internal_set_err_no(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:newlogstorepb.PreadResp)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr buf_;
  int64_t ret_code_;
  int64_t size_;
  int32_t err_no_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_newlogstorepb_2eproto;
};
// -------------------------------------------------------------------

class FallocateReq final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:newlogstorepb.FallocateReq) */ {
 public:
  inline FallocateReq() : FallocateReq(nullptr) {}
  ~FallocateReq() override;
  explicit constexpr FallocateReq(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  FallocateReq(const FallocateReq& from);
  FallocateReq(FallocateReq&& from) noexcept
    : FallocateReq() {
    *this = ::std::move(from);
  }

  inline FallocateReq& operator=(const FallocateReq& from) {
    CopyFrom(from);
    return *this;
  }
  inline FallocateReq& operator=(FallocateReq&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const FallocateReq& default_instance() {
    return *internal_default_instance();
  }
  static inline const FallocateReq* internal_default_instance() {
    return reinterpret_cast<const FallocateReq*>(
               &_FallocateReq_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(FallocateReq& a, FallocateReq& b) {
    a.Swap(&b);
  }
  inline void Swap(FallocateReq* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(FallocateReq* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  FallocateReq* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<FallocateReq>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const FallocateReq& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const FallocateReq& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(FallocateReq* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "newlogstorepb.FallocateReq";
  }
  protected:
  explicit FallocateReq(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kEpochFieldNumber = 1,
    kFdFieldNumber = 2,
    kModeFieldNumber = 3,
    kOffsetFieldNumber = 4,
    kLenFieldNumber = 5,
  };
  // int64 epoch = 1;
  void clear_epoch();
  int64_t epoch() const;
  void set_epoch(int64_t value);
  private:
  int64_t _internal_epoch() const;
  void _internal_set_epoch(int64_t value);
  public:

  // int32 fd = 2;
  void clear_fd();
  int32_t fd() const;
  void set_fd(int32_t value);
  private:
  int32_t _internal_fd() const;
  void _internal_set_fd(int32_t value);
  public:

  // int32 mode = 3;
  void clear_mode();
  int32_t mode() const;
  void set_mode(int32_t value);
  private:
  int32_t _internal_mode() const;
  void _internal_set_mode(int32_t value);
  public:

  // int64 offset = 4;
  void clear_offset();
  int64_t offset() const;
  void set_offset(int64_t value);
  private:
  int64_t _internal_offset() const;
  void _internal_set_offset(int64_t value);
  public:

  // int64 len = 5;
  void clear_len();
  int64_t len() const;
  void set_len(int64_t value);
  private:
  int64_t _internal_len() const;
  void _internal_set_len(int64_t value);
  public:

  // @@protoc_insertion_point(class_scope:newlogstorepb.FallocateReq)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  int64_t epoch_;
  int32_t fd_;
  int32_t mode_;
  int64_t offset_;
  int64_t len_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_newlogstorepb_2eproto;
};
// -------------------------------------------------------------------

class FallocateResp final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:newlogstorepb.FallocateResp) */ {
 public:
  inline FallocateResp() : FallocateResp(nullptr) {}
  ~FallocateResp() override;
  explicit constexpr FallocateResp(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  FallocateResp(const FallocateResp& from);
  FallocateResp(FallocateResp&& from) noexcept
    : FallocateResp() {
    *this = ::std::move(from);
  }

  inline FallocateResp& operator=(const FallocateResp& from) {
    CopyFrom(from);
    return *this;
  }
  inline FallocateResp& operator=(FallocateResp&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const FallocateResp& default_instance() {
    return *internal_default_instance();
  }
  static inline const FallocateResp* internal_default_instance() {
    return reinterpret_cast<const FallocateResp*>(
               &_FallocateResp_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(FallocateResp& a, FallocateResp& b) {
    a.Swap(&b);
  }
  inline void Swap(FallocateResp* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(FallocateResp* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  FallocateResp* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<FallocateResp>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const FallocateResp& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const FallocateResp& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(FallocateResp* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "newlogstorepb.FallocateResp";
  }
  protected:
  explicit FallocateResp(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRetCodeFieldNumber = 1,
    kErrNoFieldNumber = 2,
  };
  // int64 ret_code = 1;
  void clear_ret_code();
  int64_t ret_code() const;
  void set_ret_code(int64_t value);
  private:
  int64_t _internal_ret_code() const;
  void _internal_set_ret_code(int64_t value);
  public:

  // int32 err_no = 2;
  void clear_err_no();
  int32_t err_no() const;
  void set_err_no(int32_t value);
  private:
  int32_t _internal_err_no() const;
  void _internal_set_err_no(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:newlogstorepb.FallocateResp)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  int64_t ret_code_;
  int32_t err_no_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_newlogstorepb_2eproto;
};
// -------------------------------------------------------------------

class FtruncateReq final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:newlogstorepb.FtruncateReq) */ {
 public:
  inline FtruncateReq() : FtruncateReq(nullptr) {}
  ~FtruncateReq() override;
  explicit constexpr FtruncateReq(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  FtruncateReq(const FtruncateReq& from);
  FtruncateReq(FtruncateReq&& from) noexcept
    : FtruncateReq() {
    *this = ::std::move(from);
  }

  inline FtruncateReq& operator=(const FtruncateReq& from) {
    CopyFrom(from);
    return *this;
  }
  inline FtruncateReq& operator=(FtruncateReq&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const FtruncateReq& default_instance() {
    return *internal_default_instance();
  }
  static inline const FtruncateReq* internal_default_instance() {
    return reinterpret_cast<const FtruncateReq*>(
               &_FtruncateReq_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  friend void swap(FtruncateReq& a, FtruncateReq& b) {
    a.Swap(&b);
  }
  inline void Swap(FtruncateReq* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(FtruncateReq* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  FtruncateReq* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<FtruncateReq>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const FtruncateReq& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const FtruncateReq& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(FtruncateReq* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "newlogstorepb.FtruncateReq";
  }
  protected:
  explicit FtruncateReq(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kEpochFieldNumber = 1,
    kLenFieldNumber = 3,
    kFdFieldNumber = 2,
  };
  // int64 epoch = 1;
  void clear_epoch();
  int64_t epoch() const;
  void set_epoch(int64_t value);
  private:
  int64_t _internal_epoch() const;
  void _internal_set_epoch(int64_t value);
  public:

  // int64 len = 3;
  void clear_len();
  int64_t len() const;
  void set_len(int64_t value);
  private:
  int64_t _internal_len() const;
  void _internal_set_len(int64_t value);
  public:

  // int32 fd = 2;
  void clear_fd();
  int32_t fd() const;
  void set_fd(int32_t value);
  private:
  int32_t _internal_fd() const;
  void _internal_set_fd(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:newlogstorepb.FtruncateReq)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  int64_t epoch_;
  int64_t len_;
  int32_t fd_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_newlogstorepb_2eproto;
};
// -------------------------------------------------------------------

class FtruncateResp final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:newlogstorepb.FtruncateResp) */ {
 public:
  inline FtruncateResp() : FtruncateResp(nullptr) {}
  ~FtruncateResp() override;
  explicit constexpr FtruncateResp(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  FtruncateResp(const FtruncateResp& from);
  FtruncateResp(FtruncateResp&& from) noexcept
    : FtruncateResp() {
    *this = ::std::move(from);
  }

  inline FtruncateResp& operator=(const FtruncateResp& from) {
    CopyFrom(from);
    return *this;
  }
  inline FtruncateResp& operator=(FtruncateResp&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const FtruncateResp& default_instance() {
    return *internal_default_instance();
  }
  static inline const FtruncateResp* internal_default_instance() {
    return reinterpret_cast<const FtruncateResp*>(
               &_FtruncateResp_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  friend void swap(FtruncateResp& a, FtruncateResp& b) {
    a.Swap(&b);
  }
  inline void Swap(FtruncateResp* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(FtruncateResp* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  FtruncateResp* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<FtruncateResp>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const FtruncateResp& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const FtruncateResp& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(FtruncateResp* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "newlogstorepb.FtruncateResp";
  }
  protected:
  explicit FtruncateResp(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRetCodeFieldNumber = 1,
    kErrNoFieldNumber = 2,
  };
  // int64 ret_code = 1;
  void clear_ret_code();
  int64_t ret_code() const;
  void set_ret_code(int64_t value);
  private:
  int64_t _internal_ret_code() const;
  void _internal_set_ret_code(int64_t value);
  public:

  // int32 err_no = 2;
  void clear_err_no();
  int32_t err_no() const;
  void set_err_no(int32_t value);
  private:
  int32_t _internal_err_no() const;
  void _internal_set_err_no(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:newlogstorepb.FtruncateResp)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  int64_t ret_code_;
  int32_t err_no_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_newlogstorepb_2eproto;
};
// -------------------------------------------------------------------

class ScanDirReq final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:newlogstorepb.ScanDirReq) */ {
 public:
  inline ScanDirReq() : ScanDirReq(nullptr) {}
  ~ScanDirReq() override;
  explicit constexpr ScanDirReq(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ScanDirReq(const ScanDirReq& from);
  ScanDirReq(ScanDirReq&& from) noexcept
    : ScanDirReq() {
    *this = ::std::move(from);
  }

  inline ScanDirReq& operator=(const ScanDirReq& from) {
    CopyFrom(from);
    return *this;
  }
  inline ScanDirReq& operator=(ScanDirReq&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ScanDirReq& default_instance() {
    return *internal_default_instance();
  }
  static inline const ScanDirReq* internal_default_instance() {
    return reinterpret_cast<const ScanDirReq*>(
               &_ScanDirReq_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  friend void swap(ScanDirReq& a, ScanDirReq& b) {
    a.Swap(&b);
  }
  inline void Swap(ScanDirReq* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ScanDirReq* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ScanDirReq* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ScanDirReq>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ScanDirReq& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const ScanDirReq& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ScanDirReq* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "newlogstorepb.ScanDirReq";
  }
  protected:
  explicit ScanDirReq(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDirnameFieldNumber = 2,
    kEpochFieldNumber = 1,
    kReqTypeFieldNumber = 3,
  };
  // string dirname = 2;
  void clear_dirname();
  const std::string& dirname() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_dirname(ArgT0&& arg0, ArgT... args);
  std::string* mutable_dirname();
  PROTOBUF_NODISCARD std::string* release_dirname();
  void set_allocated_dirname(std::string* dirname);
  private:
  const std::string& _internal_dirname() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_dirname(const std::string& value);
  std::string* _internal_mutable_dirname();
  public:

  // int64 epoch = 1;
  void clear_epoch();
  int64_t epoch() const;
  void set_epoch(int64_t value);
  private:
  int64_t _internal_epoch() const;
  void _internal_set_epoch(int64_t value);
  public:

  // int32 req_type = 3;
  void clear_req_type();
  int32_t req_type() const;
  void set_req_type(int32_t value);
  private:
  int32_t _internal_req_type() const;
  void _internal_set_req_type(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:newlogstorepb.ScanDirReq)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr dirname_;
  int64_t epoch_;
  int32_t req_type_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_newlogstorepb_2eproto;
};
// -------------------------------------------------------------------

class ScanDirResp1 final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:newlogstorepb.ScanDirResp1) */ {
 public:
  inline ScanDirResp1() : ScanDirResp1(nullptr) {}
  ~ScanDirResp1() override;
  explicit constexpr ScanDirResp1(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ScanDirResp1(const ScanDirResp1& from);
  ScanDirResp1(ScanDirResp1&& from) noexcept
    : ScanDirResp1() {
    *this = ::std::move(from);
  }

  inline ScanDirResp1& operator=(const ScanDirResp1& from) {
    CopyFrom(from);
    return *this;
  }
  inline ScanDirResp1& operator=(ScanDirResp1&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ScanDirResp1& default_instance() {
    return *internal_default_instance();
  }
  static inline const ScanDirResp1* internal_default_instance() {
    return reinterpret_cast<const ScanDirResp1*>(
               &_ScanDirResp1_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    15;

  friend void swap(ScanDirResp1& a, ScanDirResp1& b) {
    a.Swap(&b);
  }
  inline void Swap(ScanDirResp1* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ScanDirResp1* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ScanDirResp1* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ScanDirResp1>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ScanDirResp1& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const ScanDirResp1& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ScanDirResp1* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "newlogstorepb.ScanDirResp1";
  }
  protected:
  explicit ScanDirResp1(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRetCodeFieldNumber = 1,
    kErrNoFieldNumber = 2,
  };
  // int64 ret_code = 1;
  void clear_ret_code();
  int64_t ret_code() const;
  void set_ret_code(int64_t value);
  private:
  int64_t _internal_ret_code() const;
  void _internal_set_ret_code(int64_t value);
  public:

  // int32 err_no = 2;
  void clear_err_no();
  int32_t err_no() const;
  void set_err_no(int32_t value);
  private:
  int32_t _internal_err_no() const;
  void _internal_set_err_no(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:newlogstorepb.ScanDirResp1)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  int64_t ret_code_;
  int32_t err_no_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_newlogstorepb_2eproto;
};
// -------------------------------------------------------------------

class ScanDirResp final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:newlogstorepb.ScanDirResp) */ {
 public:
  inline ScanDirResp() : ScanDirResp(nullptr) {}
  ~ScanDirResp() override;
  explicit constexpr ScanDirResp(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ScanDirResp(const ScanDirResp& from);
  ScanDirResp(ScanDirResp&& from) noexcept
    : ScanDirResp() {
    *this = ::std::move(from);
  }

  inline ScanDirResp& operator=(const ScanDirResp& from) {
    CopyFrom(from);
    return *this;
  }
  inline ScanDirResp& operator=(ScanDirResp&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ScanDirResp& default_instance() {
    return *internal_default_instance();
  }
  static inline const ScanDirResp* internal_default_instance() {
    return reinterpret_cast<const ScanDirResp*>(
               &_ScanDirResp_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    16;

  friend void swap(ScanDirResp& a, ScanDirResp& b) {
    a.Swap(&b);
  }
  inline void Swap(ScanDirResp* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ScanDirResp* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ScanDirResp* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ScanDirResp>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ScanDirResp& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const ScanDirResp& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ScanDirResp* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "newlogstorepb.ScanDirResp";
  }
  protected:
  explicit ScanDirResp(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kResp1FieldNumber = 2,
    kReqTypeFieldNumber = 1,
  };
  // .newlogstorepb.ScanDirResp1 resp1 = 2;
  bool has_resp1() const;
  private:
  bool _internal_has_resp1() const;
  public:
  void clear_resp1();
  const ::newlogstorepb::ScanDirResp1& resp1() const;
  PROTOBUF_NODISCARD ::newlogstorepb::ScanDirResp1* release_resp1();
  ::newlogstorepb::ScanDirResp1* mutable_resp1();
  void set_allocated_resp1(::newlogstorepb::ScanDirResp1* resp1);
  private:
  const ::newlogstorepb::ScanDirResp1& _internal_resp1() const;
  ::newlogstorepb::ScanDirResp1* _internal_mutable_resp1();
  public:
  void unsafe_arena_set_allocated_resp1(
      ::newlogstorepb::ScanDirResp1* resp1);
  ::newlogstorepb::ScanDirResp1* unsafe_arena_release_resp1();

  // int32 req_type = 1;
  void clear_req_type();
  int32_t req_type() const;
  void set_req_type(int32_t value);
  private:
  int32_t _internal_req_type() const;
  void _internal_set_req_type(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:newlogstorepb.ScanDirResp)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::newlogstorepb::ScanDirResp1* resp1_;
  int32_t req_type_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_newlogstorepb_2eproto;
};
// -------------------------------------------------------------------

class UnlinkReq final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:newlogstorepb.UnlinkReq) */ {
 public:
  inline UnlinkReq() : UnlinkReq(nullptr) {}
  ~UnlinkReq() override;
  explicit constexpr UnlinkReq(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  UnlinkReq(const UnlinkReq& from);
  UnlinkReq(UnlinkReq&& from) noexcept
    : UnlinkReq() {
    *this = ::std::move(from);
  }

  inline UnlinkReq& operator=(const UnlinkReq& from) {
    CopyFrom(from);
    return *this;
  }
  inline UnlinkReq& operator=(UnlinkReq&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UnlinkReq& default_instance() {
    return *internal_default_instance();
  }
  static inline const UnlinkReq* internal_default_instance() {
    return reinterpret_cast<const UnlinkReq*>(
               &_UnlinkReq_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    17;

  friend void swap(UnlinkReq& a, UnlinkReq& b) {
    a.Swap(&b);
  }
  inline void Swap(UnlinkReq* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UnlinkReq* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UnlinkReq* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<UnlinkReq>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const UnlinkReq& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const UnlinkReq& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UnlinkReq* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "newlogstorepb.UnlinkReq";
  }
  protected:
  explicit UnlinkReq(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPathnameFieldNumber = 2,
    kEpochFieldNumber = 1,
  };
  // string pathname = 2;
  void clear_pathname();
  const std::string& pathname() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_pathname(ArgT0&& arg0, ArgT... args);
  std::string* mutable_pathname();
  PROTOBUF_NODISCARD std::string* release_pathname();
  void set_allocated_pathname(std::string* pathname);
  private:
  const std::string& _internal_pathname() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_pathname(const std::string& value);
  std::string* _internal_mutable_pathname();
  public:

  // int64 epoch = 1;
  void clear_epoch();
  int64_t epoch() const;
  void set_epoch(int64_t value);
  private:
  int64_t _internal_epoch() const;
  void _internal_set_epoch(int64_t value);
  public:

  // @@protoc_insertion_point(class_scope:newlogstorepb.UnlinkReq)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr pathname_;
  int64_t epoch_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_newlogstorepb_2eproto;
};
// -------------------------------------------------------------------

class UnlinkResp final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:newlogstorepb.UnlinkResp) */ {
 public:
  inline UnlinkResp() : UnlinkResp(nullptr) {}
  ~UnlinkResp() override;
  explicit constexpr UnlinkResp(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  UnlinkResp(const UnlinkResp& from);
  UnlinkResp(UnlinkResp&& from) noexcept
    : UnlinkResp() {
    *this = ::std::move(from);
  }

  inline UnlinkResp& operator=(const UnlinkResp& from) {
    CopyFrom(from);
    return *this;
  }
  inline UnlinkResp& operator=(UnlinkResp&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UnlinkResp& default_instance() {
    return *internal_default_instance();
  }
  static inline const UnlinkResp* internal_default_instance() {
    return reinterpret_cast<const UnlinkResp*>(
               &_UnlinkResp_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    18;

  friend void swap(UnlinkResp& a, UnlinkResp& b) {
    a.Swap(&b);
  }
  inline void Swap(UnlinkResp* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UnlinkResp* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UnlinkResp* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<UnlinkResp>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const UnlinkResp& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const UnlinkResp& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UnlinkResp* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "newlogstorepb.UnlinkResp";
  }
  protected:
  explicit UnlinkResp(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRetCodeFieldNumber = 1,
    kErrNoFieldNumber = 2,
  };
  // int64 ret_code = 1;
  void clear_ret_code();
  int64_t ret_code() const;
  void set_ret_code(int64_t value);
  private:
  int64_t _internal_ret_code() const;
  void _internal_set_ret_code(int64_t value);
  public:

  // int32 err_no = 2;
  void clear_err_no();
  int32_t err_no() const;
  void set_err_no(int32_t value);
  private:
  int32_t _internal_err_no() const;
  void _internal_set_err_no(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:newlogstorepb.UnlinkResp)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  int64_t ret_code_;
  int32_t err_no_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_newlogstorepb_2eproto;
};
// -------------------------------------------------------------------

class MkdirReq final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:newlogstorepb.MkdirReq) */ {
 public:
  inline MkdirReq() : MkdirReq(nullptr) {}
  ~MkdirReq() override;
  explicit constexpr MkdirReq(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  MkdirReq(const MkdirReq& from);
  MkdirReq(MkdirReq&& from) noexcept
    : MkdirReq() {
    *this = ::std::move(from);
  }

  inline MkdirReq& operator=(const MkdirReq& from) {
    CopyFrom(from);
    return *this;
  }
  inline MkdirReq& operator=(MkdirReq&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MkdirReq& default_instance() {
    return *internal_default_instance();
  }
  static inline const MkdirReq* internal_default_instance() {
    return reinterpret_cast<const MkdirReq*>(
               &_MkdirReq_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    19;

  friend void swap(MkdirReq& a, MkdirReq& b) {
    a.Swap(&b);
  }
  inline void Swap(MkdirReq* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MkdirReq* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MkdirReq* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<MkdirReq>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const MkdirReq& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const MkdirReq& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MkdirReq* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "newlogstorepb.MkdirReq";
  }
  protected:
  explicit MkdirReq(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPathnameFieldNumber = 2,
    kEpochFieldNumber = 1,
    kModeFieldNumber = 3,
  };
  // string pathname = 2;
  void clear_pathname();
  const std::string& pathname() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_pathname(ArgT0&& arg0, ArgT... args);
  std::string* mutable_pathname();
  PROTOBUF_NODISCARD std::string* release_pathname();
  void set_allocated_pathname(std::string* pathname);
  private:
  const std::string& _internal_pathname() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_pathname(const std::string& value);
  std::string* _internal_mutable_pathname();
  public:

  // int64 epoch = 1;
  void clear_epoch();
  int64_t epoch() const;
  void set_epoch(int64_t value);
  private:
  int64_t _internal_epoch() const;
  void _internal_set_epoch(int64_t value);
  public:

  // uint32 mode = 3;
  void clear_mode();
  uint32_t mode() const;
  void set_mode(uint32_t value);
  private:
  uint32_t _internal_mode() const;
  void _internal_set_mode(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:newlogstorepb.MkdirReq)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr pathname_;
  int64_t epoch_;
  uint32_t mode_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_newlogstorepb_2eproto;
};
// -------------------------------------------------------------------

class MkdirResp final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:newlogstorepb.MkdirResp) */ {
 public:
  inline MkdirResp() : MkdirResp(nullptr) {}
  ~MkdirResp() override;
  explicit constexpr MkdirResp(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  MkdirResp(const MkdirResp& from);
  MkdirResp(MkdirResp&& from) noexcept
    : MkdirResp() {
    *this = ::std::move(from);
  }

  inline MkdirResp& operator=(const MkdirResp& from) {
    CopyFrom(from);
    return *this;
  }
  inline MkdirResp& operator=(MkdirResp&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MkdirResp& default_instance() {
    return *internal_default_instance();
  }
  static inline const MkdirResp* internal_default_instance() {
    return reinterpret_cast<const MkdirResp*>(
               &_MkdirResp_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    20;

  friend void swap(MkdirResp& a, MkdirResp& b) {
    a.Swap(&b);
  }
  inline void Swap(MkdirResp* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MkdirResp* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MkdirResp* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<MkdirResp>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const MkdirResp& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const MkdirResp& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MkdirResp* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "newlogstorepb.MkdirResp";
  }
  protected:
  explicit MkdirResp(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRetCodeFieldNumber = 1,
    kErrNoFieldNumber = 2,
  };
  // int64 ret_code = 1;
  void clear_ret_code();
  int64_t ret_code() const;
  void set_ret_code(int64_t value);
  private:
  int64_t _internal_ret_code() const;
  void _internal_set_ret_code(int64_t value);
  public:

  // int32 err_no = 2;
  void clear_err_no();
  int32_t err_no() const;
  void set_err_no(int32_t value);
  private:
  int32_t _internal_err_no() const;
  void _internal_set_err_no(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:newlogstorepb.MkdirResp)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  int64_t ret_code_;
  int32_t err_no_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_newlogstorepb_2eproto;
};
// -------------------------------------------------------------------

class RmdirReq final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:newlogstorepb.RmdirReq) */ {
 public:
  inline RmdirReq() : RmdirReq(nullptr) {}
  ~RmdirReq() override;
  explicit constexpr RmdirReq(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RmdirReq(const RmdirReq& from);
  RmdirReq(RmdirReq&& from) noexcept
    : RmdirReq() {
    *this = ::std::move(from);
  }

  inline RmdirReq& operator=(const RmdirReq& from) {
    CopyFrom(from);
    return *this;
  }
  inline RmdirReq& operator=(RmdirReq&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RmdirReq& default_instance() {
    return *internal_default_instance();
  }
  static inline const RmdirReq* internal_default_instance() {
    return reinterpret_cast<const RmdirReq*>(
               &_RmdirReq_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    21;

  friend void swap(RmdirReq& a, RmdirReq& b) {
    a.Swap(&b);
  }
  inline void Swap(RmdirReq* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RmdirReq* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RmdirReq* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RmdirReq>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const RmdirReq& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const RmdirReq& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RmdirReq* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "newlogstorepb.RmdirReq";
  }
  protected:
  explicit RmdirReq(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPathnameFieldNumber = 2,
    kEpochFieldNumber = 1,
  };
  // string pathname = 2;
  void clear_pathname();
  const std::string& pathname() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_pathname(ArgT0&& arg0, ArgT... args);
  std::string* mutable_pathname();
  PROTOBUF_NODISCARD std::string* release_pathname();
  void set_allocated_pathname(std::string* pathname);
  private:
  const std::string& _internal_pathname() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_pathname(const std::string& value);
  std::string* _internal_mutable_pathname();
  public:

  // int64 epoch = 1;
  void clear_epoch();
  int64_t epoch() const;
  void set_epoch(int64_t value);
  private:
  int64_t _internal_epoch() const;
  void _internal_set_epoch(int64_t value);
  public:

  // @@protoc_insertion_point(class_scope:newlogstorepb.RmdirReq)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr pathname_;
  int64_t epoch_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_newlogstorepb_2eproto;
};
// -------------------------------------------------------------------

class RmdirResp final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:newlogstorepb.RmdirResp) */ {
 public:
  inline RmdirResp() : RmdirResp(nullptr) {}
  ~RmdirResp() override;
  explicit constexpr RmdirResp(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RmdirResp(const RmdirResp& from);
  RmdirResp(RmdirResp&& from) noexcept
    : RmdirResp() {
    *this = ::std::move(from);
  }

  inline RmdirResp& operator=(const RmdirResp& from) {
    CopyFrom(from);
    return *this;
  }
  inline RmdirResp& operator=(RmdirResp&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RmdirResp& default_instance() {
    return *internal_default_instance();
  }
  static inline const RmdirResp* internal_default_instance() {
    return reinterpret_cast<const RmdirResp*>(
               &_RmdirResp_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    22;

  friend void swap(RmdirResp& a, RmdirResp& b) {
    a.Swap(&b);
  }
  inline void Swap(RmdirResp* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RmdirResp* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RmdirResp* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RmdirResp>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const RmdirResp& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const RmdirResp& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RmdirResp* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "newlogstorepb.RmdirResp";
  }
  protected:
  explicit RmdirResp(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRetCodeFieldNumber = 1,
    kErrNoFieldNumber = 2,
  };
  // int64 ret_code = 1;
  void clear_ret_code();
  int64_t ret_code() const;
  void set_ret_code(int64_t value);
  private:
  int64_t _internal_ret_code() const;
  void _internal_set_ret_code(int64_t value);
  public:

  // int32 err_no = 2;
  void clear_err_no();
  int32_t err_no() const;
  void set_err_no(int32_t value);
  private:
  int32_t _internal_err_no() const;
  void _internal_set_err_no(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:newlogstorepb.RmdirResp)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  int64_t ret_code_;
  int32_t err_no_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_newlogstorepb_2eproto;
};
// -------------------------------------------------------------------

class StatReq final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:newlogstorepb.StatReq) */ {
 public:
  inline StatReq() : StatReq(nullptr) {}
  ~StatReq() override;
  explicit constexpr StatReq(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  StatReq(const StatReq& from);
  StatReq(StatReq&& from) noexcept
    : StatReq() {
    *this = ::std::move(from);
  }

  inline StatReq& operator=(const StatReq& from) {
    CopyFrom(from);
    return *this;
  }
  inline StatReq& operator=(StatReq&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const StatReq& default_instance() {
    return *internal_default_instance();
  }
  static inline const StatReq* internal_default_instance() {
    return reinterpret_cast<const StatReq*>(
               &_StatReq_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    23;

  friend void swap(StatReq& a, StatReq& b) {
    a.Swap(&b);
  }
  inline void Swap(StatReq* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(StatReq* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  StatReq* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<StatReq>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const StatReq& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const StatReq& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(StatReq* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "newlogstorepb.StatReq";
  }
  protected:
  explicit StatReq(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPathnameFieldNumber = 2,
    kEpochFieldNumber = 1,
  };
  // string pathname = 2;
  void clear_pathname();
  const std::string& pathname() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_pathname(ArgT0&& arg0, ArgT... args);
  std::string* mutable_pathname();
  PROTOBUF_NODISCARD std::string* release_pathname();
  void set_allocated_pathname(std::string* pathname);
  private:
  const std::string& _internal_pathname() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_pathname(const std::string& value);
  std::string* _internal_mutable_pathname();
  public:

  // int64 epoch = 1;
  void clear_epoch();
  int64_t epoch() const;
  void set_epoch(int64_t value);
  private:
  int64_t _internal_epoch() const;
  void _internal_set_epoch(int64_t value);
  public:

  // @@protoc_insertion_point(class_scope:newlogstorepb.StatReq)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr pathname_;
  int64_t epoch_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_newlogstorepb_2eproto;
};
// -------------------------------------------------------------------

class StatResp final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:newlogstorepb.StatResp) */ {
 public:
  inline StatResp() : StatResp(nullptr) {}
  ~StatResp() override;
  explicit constexpr StatResp(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  StatResp(const StatResp& from);
  StatResp(StatResp&& from) noexcept
    : StatResp() {
    *this = ::std::move(from);
  }

  inline StatResp& operator=(const StatResp& from) {
    CopyFrom(from);
    return *this;
  }
  inline StatResp& operator=(StatResp&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const StatResp& default_instance() {
    return *internal_default_instance();
  }
  static inline const StatResp* internal_default_instance() {
    return reinterpret_cast<const StatResp*>(
               &_StatResp_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    24;

  friend void swap(StatResp& a, StatResp& b) {
    a.Swap(&b);
  }
  inline void Swap(StatResp* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(StatResp* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  StatResp* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<StatResp>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const StatResp& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const StatResp& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(StatResp* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "newlogstorepb.StatResp";
  }
  protected:
  explicit StatResp(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRetCodeFieldNumber = 1,
    kErrNoFieldNumber = 2,
    kIsDirFieldNumber = 3,
    kStSizeFieldNumber = 4,
  };
  // int64 ret_code = 1;
  void clear_ret_code();
  int64_t ret_code() const;
  void set_ret_code(int64_t value);
  private:
  int64_t _internal_ret_code() const;
  void _internal_set_ret_code(int64_t value);
  public:

  // int32 err_no = 2;
  void clear_err_no();
  int32_t err_no() const;
  void set_err_no(int32_t value);
  private:
  int32_t _internal_err_no() const;
  void _internal_set_err_no(int32_t value);
  public:

  // bool is_dir = 3;
  void clear_is_dir();
  bool is_dir() const;
  void set_is_dir(bool value);
  private:
  bool _internal_is_dir() const;
  void _internal_set_is_dir(bool value);
  public:

  // uint64 st_size = 4;
  void clear_st_size();
  uint64_t st_size() const;
  void set_st_size(uint64_t value);
  private:
  uint64_t _internal_st_size() const;
  void _internal_set_st_size(uint64_t value);
  public:

  // @@protoc_insertion_point(class_scope:newlogstorepb.StatResp)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  int64_t ret_code_;
  int32_t err_no_;
  bool is_dir_;
  uint64_t st_size_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_newlogstorepb_2eproto;
};
// -------------------------------------------------------------------

class RenameReq final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:newlogstorepb.RenameReq) */ {
 public:
  inline RenameReq() : RenameReq(nullptr) {}
  ~RenameReq() override;
  explicit constexpr RenameReq(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RenameReq(const RenameReq& from);
  RenameReq(RenameReq&& from) noexcept
    : RenameReq() {
    *this = ::std::move(from);
  }

  inline RenameReq& operator=(const RenameReq& from) {
    CopyFrom(from);
    return *this;
  }
  inline RenameReq& operator=(RenameReq&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RenameReq& default_instance() {
    return *internal_default_instance();
  }
  static inline const RenameReq* internal_default_instance() {
    return reinterpret_cast<const RenameReq*>(
               &_RenameReq_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    25;

  friend void swap(RenameReq& a, RenameReq& b) {
    a.Swap(&b);
  }
  inline void Swap(RenameReq* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RenameReq* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RenameReq* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RenameReq>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const RenameReq& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const RenameReq& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RenameReq* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "newlogstorepb.RenameReq";
  }
  protected:
  explicit RenameReq(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kOldpathFieldNumber = 2,
    kNewpathFieldNumber = 3,
    kEpochFieldNumber = 1,
  };
  // string oldpath = 2;
  void clear_oldpath();
  const std::string& oldpath() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_oldpath(ArgT0&& arg0, ArgT... args);
  std::string* mutable_oldpath();
  PROTOBUF_NODISCARD std::string* release_oldpath();
  void set_allocated_oldpath(std::string* oldpath);
  private:
  const std::string& _internal_oldpath() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_oldpath(const std::string& value);
  std::string* _internal_mutable_oldpath();
  public:

  // string newpath = 3;
  void clear_newpath();
  const std::string& newpath() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_newpath(ArgT0&& arg0, ArgT... args);
  std::string* mutable_newpath();
  PROTOBUF_NODISCARD std::string* release_newpath();
  void set_allocated_newpath(std::string* newpath);
  private:
  const std::string& _internal_newpath() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_newpath(const std::string& value);
  std::string* _internal_mutable_newpath();
  public:

  // int64 epoch = 1;
  void clear_epoch();
  int64_t epoch() const;
  void set_epoch(int64_t value);
  private:
  int64_t _internal_epoch() const;
  void _internal_set_epoch(int64_t value);
  public:

  // @@protoc_insertion_point(class_scope:newlogstorepb.RenameReq)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr oldpath_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr newpath_;
  int64_t epoch_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_newlogstorepb_2eproto;
};
// -------------------------------------------------------------------

class RenameResp final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:newlogstorepb.RenameResp) */ {
 public:
  inline RenameResp() : RenameResp(nullptr) {}
  ~RenameResp() override;
  explicit constexpr RenameResp(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RenameResp(const RenameResp& from);
  RenameResp(RenameResp&& from) noexcept
    : RenameResp() {
    *this = ::std::move(from);
  }

  inline RenameResp& operator=(const RenameResp& from) {
    CopyFrom(from);
    return *this;
  }
  inline RenameResp& operator=(RenameResp&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RenameResp& default_instance() {
    return *internal_default_instance();
  }
  static inline const RenameResp* internal_default_instance() {
    return reinterpret_cast<const RenameResp*>(
               &_RenameResp_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    26;

  friend void swap(RenameResp& a, RenameResp& b) {
    a.Swap(&b);
  }
  inline void Swap(RenameResp* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RenameResp* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RenameResp* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RenameResp>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const RenameResp& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const RenameResp& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RenameResp* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "newlogstorepb.RenameResp";
  }
  protected:
  explicit RenameResp(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRetCodeFieldNumber = 1,
    kErrNoFieldNumber = 2,
  };
  // int64 ret_code = 1;
  void clear_ret_code();
  int64_t ret_code() const;
  void set_ret_code(int64_t value);
  private:
  int64_t _internal_ret_code() const;
  void _internal_set_ret_code(int64_t value);
  public:

  // int32 err_no = 2;
  void clear_err_no();
  int32_t err_no() const;
  void set_err_no(int32_t value);
  private:
  int32_t _internal_err_no() const;
  void _internal_set_err_no(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:newlogstorepb.RenameResp)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  int64_t ret_code_;
  int32_t err_no_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_newlogstorepb_2eproto;
};
// -------------------------------------------------------------------

class FsyncReq final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:newlogstorepb.FsyncReq) */ {
 public:
  inline FsyncReq() : FsyncReq(nullptr) {}
  ~FsyncReq() override;
  explicit constexpr FsyncReq(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  FsyncReq(const FsyncReq& from);
  FsyncReq(FsyncReq&& from) noexcept
    : FsyncReq() {
    *this = ::std::move(from);
  }

  inline FsyncReq& operator=(const FsyncReq& from) {
    CopyFrom(from);
    return *this;
  }
  inline FsyncReq& operator=(FsyncReq&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const FsyncReq& default_instance() {
    return *internal_default_instance();
  }
  static inline const FsyncReq* internal_default_instance() {
    return reinterpret_cast<const FsyncReq*>(
               &_FsyncReq_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    27;

  friend void swap(FsyncReq& a, FsyncReq& b) {
    a.Swap(&b);
  }
  inline void Swap(FsyncReq* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(FsyncReq* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  FsyncReq* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<FsyncReq>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const FsyncReq& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const FsyncReq& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(FsyncReq* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "newlogstorepb.FsyncReq";
  }
  protected:
  explicit FsyncReq(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kEpochFieldNumber = 1,
    kFdFieldNumber = 2,
  };
  // int64 epoch = 1;
  void clear_epoch();
  int64_t epoch() const;
  void set_epoch(int64_t value);
  private:
  int64_t _internal_epoch() const;
  void _internal_set_epoch(int64_t value);
  public:

  // int32 fd = 2;
  void clear_fd();
  int32_t fd() const;
  void set_fd(int32_t value);
  private:
  int32_t _internal_fd() const;
  void _internal_set_fd(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:newlogstorepb.FsyncReq)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  int64_t epoch_;
  int32_t fd_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_newlogstorepb_2eproto;
};
// -------------------------------------------------------------------

class FsyncResp final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:newlogstorepb.FsyncResp) */ {
 public:
  inline FsyncResp() : FsyncResp(nullptr) {}
  ~FsyncResp() override;
  explicit constexpr FsyncResp(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  FsyncResp(const FsyncResp& from);
  FsyncResp(FsyncResp&& from) noexcept
    : FsyncResp() {
    *this = ::std::move(from);
  }

  inline FsyncResp& operator=(const FsyncResp& from) {
    CopyFrom(from);
    return *this;
  }
  inline FsyncResp& operator=(FsyncResp&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const FsyncResp& default_instance() {
    return *internal_default_instance();
  }
  static inline const FsyncResp* internal_default_instance() {
    return reinterpret_cast<const FsyncResp*>(
               &_FsyncResp_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    28;

  friend void swap(FsyncResp& a, FsyncResp& b) {
    a.Swap(&b);
  }
  inline void Swap(FsyncResp* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(FsyncResp* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  FsyncResp* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<FsyncResp>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const FsyncResp& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const FsyncResp& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(FsyncResp* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "newlogstorepb.FsyncResp";
  }
  protected:
  explicit FsyncResp(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRetCodeFieldNumber = 1,
    kErrNoFieldNumber = 2,
  };
  // int64 ret_code = 1;
  void clear_ret_code();
  int64_t ret_code() const;
  void set_ret_code(int64_t value);
  private:
  int64_t _internal_ret_code() const;
  void _internal_set_ret_code(int64_t value);
  public:

  // int32 err_no = 2;
  void clear_err_no();
  int32_t err_no() const;
  void set_err_no(int32_t value);
  private:
  int32_t _internal_err_no() const;
  void _internal_set_err_no(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:newlogstorepb.FsyncResp)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  int64_t ret_code_;
  int32_t err_no_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_newlogstorepb_2eproto;
};
// -------------------------------------------------------------------

class GetLogStoreInfoReq final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:newlogstorepb.GetLogStoreInfoReq) */ {
 public:
  inline GetLogStoreInfoReq() : GetLogStoreInfoReq(nullptr) {}
  ~GetLogStoreInfoReq() override;
  explicit constexpr GetLogStoreInfoReq(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetLogStoreInfoReq(const GetLogStoreInfoReq& from);
  GetLogStoreInfoReq(GetLogStoreInfoReq&& from) noexcept
    : GetLogStoreInfoReq() {
    *this = ::std::move(from);
  }

  inline GetLogStoreInfoReq& operator=(const GetLogStoreInfoReq& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetLogStoreInfoReq& operator=(GetLogStoreInfoReq&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetLogStoreInfoReq& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetLogStoreInfoReq* internal_default_instance() {
    return reinterpret_cast<const GetLogStoreInfoReq*>(
               &_GetLogStoreInfoReq_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    29;

  friend void swap(GetLogStoreInfoReq& a, GetLogStoreInfoReq& b) {
    a.Swap(&b);
  }
  inline void Swap(GetLogStoreInfoReq* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetLogStoreInfoReq* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetLogStoreInfoReq* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetLogStoreInfoReq>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetLogStoreInfoReq& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const GetLogStoreInfoReq& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetLogStoreInfoReq* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "newlogstorepb.GetLogStoreInfoReq";
  }
  protected:
  explicit GetLogStoreInfoReq(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kEpochFieldNumber = 1,
  };
  // int64 epoch = 1;
  void clear_epoch();
  int64_t epoch() const;
  void set_epoch(int64_t value);
  private:
  int64_t _internal_epoch() const;
  void _internal_set_epoch(int64_t value);
  public:

  // @@protoc_insertion_point(class_scope:newlogstorepb.GetLogStoreInfoReq)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  int64_t epoch_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_newlogstorepb_2eproto;
};
// -------------------------------------------------------------------

class GetLogStoreInfoResp final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:newlogstorepb.GetLogStoreInfoResp) */ {
 public:
  inline GetLogStoreInfoResp() : GetLogStoreInfoResp(nullptr) {}
  ~GetLogStoreInfoResp() override;
  explicit constexpr GetLogStoreInfoResp(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetLogStoreInfoResp(const GetLogStoreInfoResp& from);
  GetLogStoreInfoResp(GetLogStoreInfoResp&& from) noexcept
    : GetLogStoreInfoResp() {
    *this = ::std::move(from);
  }

  inline GetLogStoreInfoResp& operator=(const GetLogStoreInfoResp& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetLogStoreInfoResp& operator=(GetLogStoreInfoResp&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetLogStoreInfoResp& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetLogStoreInfoResp* internal_default_instance() {
    return reinterpret_cast<const GetLogStoreInfoResp*>(
               &_GetLogStoreInfoResp_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    30;

  friend void swap(GetLogStoreInfoResp& a, GetLogStoreInfoResp& b) {
    a.Swap(&b);
  }
  inline void Swap(GetLogStoreInfoResp* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetLogStoreInfoResp* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetLogStoreInfoResp* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetLogStoreInfoResp>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetLogStoreInfoResp& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const GetLogStoreInfoResp& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetLogStoreInfoResp* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "newlogstorepb.GetLogStoreInfoResp";
  }
  protected:
  explicit GetLogStoreInfoResp(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRetCodeFieldNumber = 1,
    kMemoryLimitFieldNumber = 2,
    kMemoryUsedFieldNumber = 3,
    kShmLimitFieldNumber = 4,
    kShmUsedFieldNumber = 5,
  };
  // int64 ret_code = 1;
  void clear_ret_code();
  int64_t ret_code() const;
  void set_ret_code(int64_t value);
  private:
  int64_t _internal_ret_code() const;
  void _internal_set_ret_code(int64_t value);
  public:

  // int64 memory_limit = 2;
  void clear_memory_limit();
  int64_t memory_limit() const;
  void set_memory_limit(int64_t value);
  private:
  int64_t _internal_memory_limit() const;
  void _internal_set_memory_limit(int64_t value);
  public:

  // int64 memory_used = 3;
  void clear_memory_used();
  int64_t memory_used() const;
  void set_memory_used(int64_t value);
  private:
  int64_t _internal_memory_used() const;
  void _internal_set_memory_used(int64_t value);
  public:

  // int64 shm_limit = 4;
  void clear_shm_limit();
  int64_t shm_limit() const;
  void set_shm_limit(int64_t value);
  private:
  int64_t _internal_shm_limit() const;
  void _internal_set_shm_limit(int64_t value);
  public:

  // int64 shm_used = 5;
  void clear_shm_used();
  int64_t shm_used() const;
  void set_shm_used(int64_t value);
  private:
  int64_t _internal_shm_used() const;
  void _internal_set_shm_used(int64_t value);
  public:

  // @@protoc_insertion_point(class_scope:newlogstorepb.GetLogStoreInfoResp)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  int64_t ret_code_;
  int64_t memory_limit_;
  int64_t memory_used_;
  int64_t shm_limit_;
  int64_t shm_used_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_newlogstorepb_2eproto;
};
// -------------------------------------------------------------------

class BatchFallocateReq final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:newlogstorepb.BatchFallocateReq) */ {
 public:
  inline BatchFallocateReq() : BatchFallocateReq(nullptr) {}
  ~BatchFallocateReq() override;
  explicit constexpr BatchFallocateReq(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  BatchFallocateReq(const BatchFallocateReq& from);
  BatchFallocateReq(BatchFallocateReq&& from) noexcept
    : BatchFallocateReq() {
    *this = ::std::move(from);
  }

  inline BatchFallocateReq& operator=(const BatchFallocateReq& from) {
    CopyFrom(from);
    return *this;
  }
  inline BatchFallocateReq& operator=(BatchFallocateReq&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const BatchFallocateReq& default_instance() {
    return *internal_default_instance();
  }
  static inline const BatchFallocateReq* internal_default_instance() {
    return reinterpret_cast<const BatchFallocateReq*>(
               &_BatchFallocateReq_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    31;

  friend void swap(BatchFallocateReq& a, BatchFallocateReq& b) {
    a.Swap(&b);
  }
  inline void Swap(BatchFallocateReq* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(BatchFallocateReq* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  BatchFallocateReq* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<BatchFallocateReq>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const BatchFallocateReq& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const BatchFallocateReq& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(BatchFallocateReq* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "newlogstorepb.BatchFallocateReq";
  }
  protected:
  explicit BatchFallocateReq(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDirnameFieldNumber = 2,
    kEpochFieldNumber = 1,
    kCountFieldNumber = 3,
    kSizeFieldNumber = 4,
  };
  // string dirname = 2;
  void clear_dirname();
  const std::string& dirname() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_dirname(ArgT0&& arg0, ArgT... args);
  std::string* mutable_dirname();
  PROTOBUF_NODISCARD std::string* release_dirname();
  void set_allocated_dirname(std::string* dirname);
  private:
  const std::string& _internal_dirname() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_dirname(const std::string& value);
  std::string* _internal_mutable_dirname();
  public:

  // int64 epoch = 1;
  void clear_epoch();
  int64_t epoch() const;
  void set_epoch(int64_t value);
  private:
  int64_t _internal_epoch() const;
  void _internal_set_epoch(int64_t value);
  public:

  // int64 count = 3;
  void clear_count();
  int64_t count() const;
  void set_count(int64_t value);
  private:
  int64_t _internal_count() const;
  void _internal_set_count(int64_t value);
  public:

  // int64 size = 4;
  void clear_size();
  int64_t size() const;
  void set_size(int64_t value);
  private:
  int64_t _internal_size() const;
  void _internal_set_size(int64_t value);
  public:

  // @@protoc_insertion_point(class_scope:newlogstorepb.BatchFallocateReq)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr dirname_;
  int64_t epoch_;
  int64_t count_;
  int64_t size_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_newlogstorepb_2eproto;
};
// -------------------------------------------------------------------

class BatchFallocateResp final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:newlogstorepb.BatchFallocateResp) */ {
 public:
  inline BatchFallocateResp() : BatchFallocateResp(nullptr) {}
  ~BatchFallocateResp() override;
  explicit constexpr BatchFallocateResp(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  BatchFallocateResp(const BatchFallocateResp& from);
  BatchFallocateResp(BatchFallocateResp&& from) noexcept
    : BatchFallocateResp() {
    *this = ::std::move(from);
  }

  inline BatchFallocateResp& operator=(const BatchFallocateResp& from) {
    CopyFrom(from);
    return *this;
  }
  inline BatchFallocateResp& operator=(BatchFallocateResp&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const BatchFallocateResp& default_instance() {
    return *internal_default_instance();
  }
  static inline const BatchFallocateResp* internal_default_instance() {
    return reinterpret_cast<const BatchFallocateResp*>(
               &_BatchFallocateResp_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    32;

  friend void swap(BatchFallocateResp& a, BatchFallocateResp& b) {
    a.Swap(&b);
  }
  inline void Swap(BatchFallocateResp* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(BatchFallocateResp* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  BatchFallocateResp* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<BatchFallocateResp>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const BatchFallocateResp& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const BatchFallocateResp& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(BatchFallocateResp* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "newlogstorepb.BatchFallocateResp";
  }
  protected:
  explicit BatchFallocateResp(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRetCodeFieldNumber = 1,
    kErrNoFieldNumber = 2,
  };
  // int64 ret_code = 1;
  void clear_ret_code();
  int64_t ret_code() const;
  void set_ret_code(int64_t value);
  private:
  int64_t _internal_ret_code() const;
  void _internal_set_ret_code(int64_t value);
  public:

  // int32 err_no = 2;
  void clear_err_no();
  int32_t err_no() const;
  void set_err_no(int32_t value);
  private:
  int32_t _internal_err_no() const;
  void _internal_set_err_no(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:newlogstorepb.BatchFallocateResp)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  int64_t ret_code_;
  int32_t err_no_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_newlogstorepb_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// LoadLogStoreReq

// int64 version = 1;
inline void LoadLogStoreReq::clear_version() {
  version_ = int64_t{0};
}
inline int64_t LoadLogStoreReq::_internal_version() const {
  return version_;
}
inline int64_t LoadLogStoreReq::version() const {
  // @@protoc_insertion_point(field_get:newlogstorepb.LoadLogStoreReq.version)
  return _internal_version();
}
inline void LoadLogStoreReq::_internal_set_version(int64_t value) {

  version_ = value;
}
inline void LoadLogStoreReq::set_version(int64_t value) {
  _internal_set_version(value);
  // @@protoc_insertion_point(field_set:newlogstorepb.LoadLogStoreReq.version)
}

// -------------------------------------------------------------------

// LoadLogStoreResp

// int64 ret_code = 1;
inline void LoadLogStoreResp::clear_ret_code() {
  ret_code_ = int64_t{0};
}
inline int64_t LoadLogStoreResp::_internal_ret_code() const {
  return ret_code_;
}
inline int64_t LoadLogStoreResp::ret_code() const {
  // @@protoc_insertion_point(field_get:newlogstorepb.LoadLogStoreResp.ret_code)
  return _internal_ret_code();
}
inline void LoadLogStoreResp::_internal_set_ret_code(int64_t value) {

  ret_code_ = value;
}
inline void LoadLogStoreResp::set_ret_code(int64_t value) {
  _internal_set_ret_code(value);
  // @@protoc_insertion_point(field_set:newlogstorepb.LoadLogStoreResp.ret_code)
}

// int64 version = 2;
inline void LoadLogStoreResp::clear_version() {
  version_ = int64_t{0};
}
inline int64_t LoadLogStoreResp::_internal_version() const {
  return version_;
}
inline int64_t LoadLogStoreResp::version() const {
  // @@protoc_insertion_point(field_get:newlogstorepb.LoadLogStoreResp.version)
  return _internal_version();
}
inline void LoadLogStoreResp::_internal_set_version(int64_t value) {

  version_ = value;
}
inline void LoadLogStoreResp::set_version(int64_t value) {
  _internal_set_version(value);
  // @@protoc_insertion_point(field_set:newlogstorepb.LoadLogStoreResp.version)
}

// int64 epoch = 3;
inline void LoadLogStoreResp::clear_epoch() {
  epoch_ = int64_t{0};
}
inline int64_t LoadLogStoreResp::_internal_epoch() const {
  return epoch_;
}
inline int64_t LoadLogStoreResp::epoch() const {
  // @@protoc_insertion_point(field_get:newlogstorepb.LoadLogStoreResp.epoch)
  return _internal_epoch();
}
inline void LoadLogStoreResp::_internal_set_epoch(int64_t value) {

  epoch_ = value;
}
inline void LoadLogStoreResp::set_epoch(int64_t value) {
  _internal_set_epoch(value);
  // @@protoc_insertion_point(field_set:newlogstorepb.LoadLogStoreResp.epoch)
}

// -------------------------------------------------------------------

// OpenReq

// int64 epoch = 1;
inline void OpenReq::clear_epoch() {
  epoch_ = int64_t{0};
}
inline int64_t OpenReq::_internal_epoch() const {
  return epoch_;
}
inline int64_t OpenReq::epoch() const {
  // @@protoc_insertion_point(field_get:newlogstorepb.OpenReq.epoch)
  return _internal_epoch();
}
inline void OpenReq::_internal_set_epoch(int64_t value) {

  epoch_ = value;
}
inline void OpenReq::set_epoch(int64_t value) {
  _internal_set_epoch(value);
  // @@protoc_insertion_point(field_set:newlogstorepb.OpenReq.epoch)
}

// string pathname = 2;
inline void OpenReq::clear_pathname() {
  pathname_.ClearToEmpty();
}
inline const std::string& OpenReq::pathname() const {
  // @@protoc_insertion_point(field_get:newlogstorepb.OpenReq.pathname)
  return _internal_pathname();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void OpenReq::set_pathname(ArgT0&& arg0, ArgT... args) {

 pathname_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:newlogstorepb.OpenReq.pathname)
}
inline std::string* OpenReq::mutable_pathname() {
  std::string* _s = _internal_mutable_pathname();
  // @@protoc_insertion_point(field_mutable:newlogstorepb.OpenReq.pathname)
  return _s;
}
inline const std::string& OpenReq::_internal_pathname() const {
  return pathname_.Get();
}
inline void OpenReq::_internal_set_pathname(const std::string& value) {

  pathname_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* OpenReq::_internal_mutable_pathname() {

  return pathname_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* OpenReq::release_pathname() {
  // @@protoc_insertion_point(field_release:newlogstorepb.OpenReq.pathname)
  return pathname_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void OpenReq::set_allocated_pathname(std::string* pathname) {
  if (pathname != nullptr) {

  } else {

  }
  pathname_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), pathname,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (pathname_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    pathname_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:newlogstorepb.OpenReq.pathname)
}

// int32 flags = 3;
inline void OpenReq::clear_flags() {
  flags_ = 0;
}
inline int32_t OpenReq::_internal_flags() const {
  return flags_;
}
inline int32_t OpenReq::flags() const {
  // @@protoc_insertion_point(field_get:newlogstorepb.OpenReq.flags)
  return _internal_flags();
}
inline void OpenReq::_internal_set_flags(int32_t value) {

  flags_ = value;
}
inline void OpenReq::set_flags(int32_t value) {
  _internal_set_flags(value);
  // @@protoc_insertion_point(field_set:newlogstorepb.OpenReq.flags)
}

// uint32 mode = 4;
inline void OpenReq::clear_mode() {
  mode_ = 0u;
}
inline uint32_t OpenReq::_internal_mode() const {
  return mode_;
}
inline uint32_t OpenReq::mode() const {
  // @@protoc_insertion_point(field_get:newlogstorepb.OpenReq.mode)
  return _internal_mode();
}
inline void OpenReq::_internal_set_mode(uint32_t value) {

  mode_ = value;
}
inline void OpenReq::set_mode(uint32_t value) {
  _internal_set_mode(value);
  // @@protoc_insertion_point(field_set:newlogstorepb.OpenReq.mode)
}

// -------------------------------------------------------------------

// OpenResp

// int64 ret_code = 1;
inline void OpenResp::clear_ret_code() {
  ret_code_ = int64_t{0};
}
inline int64_t OpenResp::_internal_ret_code() const {
  return ret_code_;
}
inline int64_t OpenResp::ret_code() const {
  // @@protoc_insertion_point(field_get:newlogstorepb.OpenResp.ret_code)
  return _internal_ret_code();
}
inline void OpenResp::_internal_set_ret_code(int64_t value) {

  ret_code_ = value;
}
inline void OpenResp::set_ret_code(int64_t value) {
  _internal_set_ret_code(value);
  // @@protoc_insertion_point(field_set:newlogstorepb.OpenResp.ret_code)
}

// int32 err_no = 2;
inline void OpenResp::clear_err_no() {
  err_no_ = 0;
}
inline int32_t OpenResp::_internal_err_no() const {
  return err_no_;
}
inline int32_t OpenResp::err_no() const {
  // @@protoc_insertion_point(field_get:newlogstorepb.OpenResp.err_no)
  return _internal_err_no();
}
inline void OpenResp::_internal_set_err_no(int32_t value) {

  err_no_ = value;
}
inline void OpenResp::set_err_no(int32_t value) {
  _internal_set_err_no(value);
  // @@protoc_insertion_point(field_set:newlogstorepb.OpenResp.err_no)
}

// int32 fd = 3;
inline void OpenResp::clear_fd() {
  fd_ = 0;
}
inline int32_t OpenResp::_internal_fd() const {
  return fd_;
}
inline int32_t OpenResp::fd() const {
  // @@protoc_insertion_point(field_get:newlogstorepb.OpenResp.fd)
  return _internal_fd();
}
inline void OpenResp::_internal_set_fd(int32_t value) {

  fd_ = value;
}
inline void OpenResp::set_fd(int32_t value) {
  _internal_set_fd(value);
  // @@protoc_insertion_point(field_set:newlogstorepb.OpenResp.fd)
}

// -------------------------------------------------------------------

// CloseReq

// int64 epoch = 1;
inline void CloseReq::clear_epoch() {
  epoch_ = int64_t{0};
}
inline int64_t CloseReq::_internal_epoch() const {
  return epoch_;
}
inline int64_t CloseReq::epoch() const {
  // @@protoc_insertion_point(field_get:newlogstorepb.CloseReq.epoch)
  return _internal_epoch();
}
inline void CloseReq::_internal_set_epoch(int64_t value) {

  epoch_ = value;
}
inline void CloseReq::set_epoch(int64_t value) {
  _internal_set_epoch(value);
  // @@protoc_insertion_point(field_set:newlogstorepb.CloseReq.epoch)
}

// int32 fd = 2;
inline void CloseReq::clear_fd() {
  fd_ = 0;
}
inline int32_t CloseReq::_internal_fd() const {
  return fd_;
}
inline int32_t CloseReq::fd() const {
  // @@protoc_insertion_point(field_get:newlogstorepb.CloseReq.fd)
  return _internal_fd();
}
inline void CloseReq::_internal_set_fd(int32_t value) {

  fd_ = value;
}
inline void CloseReq::set_fd(int32_t value) {
  _internal_set_fd(value);
  // @@protoc_insertion_point(field_set:newlogstorepb.CloseReq.fd)
}

// -------------------------------------------------------------------

// CloseResp

// int64 ret_code = 1;
inline void CloseResp::clear_ret_code() {
  ret_code_ = int64_t{0};
}
inline int64_t CloseResp::_internal_ret_code() const {
  return ret_code_;
}
inline int64_t CloseResp::ret_code() const {
  // @@protoc_insertion_point(field_get:newlogstorepb.CloseResp.ret_code)
  return _internal_ret_code();
}
inline void CloseResp::_internal_set_ret_code(int64_t value) {

  ret_code_ = value;
}
inline void CloseResp::set_ret_code(int64_t value) {
  _internal_set_ret_code(value);
  // @@protoc_insertion_point(field_set:newlogstorepb.CloseResp.ret_code)
}

// int32 err_no = 2;
inline void CloseResp::clear_err_no() {
  err_no_ = 0;
}
inline int32_t CloseResp::_internal_err_no() const {
  return err_no_;
}
inline int32_t CloseResp::err_no() const {
  // @@protoc_insertion_point(field_get:newlogstorepb.CloseResp.err_no)
  return _internal_err_no();
}
inline void CloseResp::_internal_set_err_no(int32_t value) {

  err_no_ = value;
}
inline void CloseResp::set_err_no(int32_t value) {
  _internal_set_err_no(value);
  // @@protoc_insertion_point(field_set:newlogstorepb.CloseResp.err_no)
}

// -------------------------------------------------------------------

// PwriteReq

// int64 epoch = 1;
inline void PwriteReq::clear_epoch() {
  epoch_ = int64_t{0};
}
inline int64_t PwriteReq::_internal_epoch() const {
  return epoch_;
}
inline int64_t PwriteReq::epoch() const {
  // @@protoc_insertion_point(field_get:newlogstorepb.PwriteReq.epoch)
  return _internal_epoch();
}
inline void PwriteReq::_internal_set_epoch(int64_t value) {

  epoch_ = value;
}
inline void PwriteReq::set_epoch(int64_t value) {
  _internal_set_epoch(value);
  // @@protoc_insertion_point(field_set:newlogstorepb.PwriteReq.epoch)
}

// int64 seq = 2;
inline void PwriteReq::clear_seq() {
  seq_ = int64_t{0};
}
inline int64_t PwriteReq::_internal_seq() const {
  return seq_;
}
inline int64_t PwriteReq::seq() const {
  // @@protoc_insertion_point(field_get:newlogstorepb.PwriteReq.seq)
  return _internal_seq();
}
inline void PwriteReq::_internal_set_seq(int64_t value) {

  seq_ = value;
}
inline void PwriteReq::set_seq(int64_t value) {
  _internal_set_seq(value);
  // @@protoc_insertion_point(field_set:newlogstorepb.PwriteReq.seq)
}

// int32 fd = 3;
inline void PwriteReq::clear_fd() {
  fd_ = 0;
}
inline int32_t PwriteReq::_internal_fd() const {
  return fd_;
}
inline int32_t PwriteReq::fd() const {
  // @@protoc_insertion_point(field_get:newlogstorepb.PwriteReq.fd)
  return _internal_fd();
}
inline void PwriteReq::_internal_set_fd(int32_t value) {

  fd_ = value;
}
inline void PwriteReq::set_fd(int32_t value) {
  _internal_set_fd(value);
  // @@protoc_insertion_point(field_set:newlogstorepb.PwriteReq.fd)
}

// bytes buf = 4;
inline void PwriteReq::clear_buf() {
  buf_.ClearToEmpty();
}
inline const std::string& PwriteReq::buf() const {
  // @@protoc_insertion_point(field_get:newlogstorepb.PwriteReq.buf)
  return _internal_buf();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void PwriteReq::set_buf(ArgT0&& arg0, ArgT... args) {

 buf_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:newlogstorepb.PwriteReq.buf)
}
inline std::string* PwriteReq::mutable_buf() {
  std::string* _s = _internal_mutable_buf();
  // @@protoc_insertion_point(field_mutable:newlogstorepb.PwriteReq.buf)
  return _s;
}
inline const std::string& PwriteReq::_internal_buf() const {
  return buf_.Get();
}
inline void PwriteReq::_internal_set_buf(const std::string& value) {

  buf_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* PwriteReq::_internal_mutable_buf() {

  return buf_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* PwriteReq::release_buf() {
  // @@protoc_insertion_point(field_release:newlogstorepb.PwriteReq.buf)
  return buf_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void PwriteReq::set_allocated_buf(std::string* buf) {
  if (buf != nullptr) {

  } else {

  }
  buf_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), buf,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (buf_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    buf_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:newlogstorepb.PwriteReq.buf)
}

// uint64 size = 5;
inline void PwriteReq::clear_size() {
  size_ = uint64_t{0u};
}
inline uint64_t PwriteReq::_internal_size() const {
  return size_;
}
inline uint64_t PwriteReq::size() const {
  // @@protoc_insertion_point(field_get:newlogstorepb.PwriteReq.size)
  return _internal_size();
}
inline void PwriteReq::_internal_set_size(uint64_t value) {

  size_ = value;
}
inline void PwriteReq::set_size(uint64_t value) {
  _internal_set_size(value);
  // @@protoc_insertion_point(field_set:newlogstorepb.PwriteReq.size)
}

// uint64 offset = 6;
inline void PwriteReq::clear_offset() {
  offset_ = uint64_t{0u};
}
inline uint64_t PwriteReq::_internal_offset() const {
  return offset_;
}
inline uint64_t PwriteReq::offset() const {
  // @@protoc_insertion_point(field_get:newlogstorepb.PwriteReq.offset)
  return _internal_offset();
}
inline void PwriteReq::_internal_set_offset(uint64_t value) {

  offset_ = value;
}
inline void PwriteReq::set_offset(uint64_t value) {
  _internal_set_offset(value);
  // @@protoc_insertion_point(field_set:newlogstorepb.PwriteReq.offset)
}

// int32 write_mode = 7;
inline void PwriteReq::clear_write_mode() {
  write_mode_ = 0;
}
inline int32_t PwriteReq::_internal_write_mode() const {
  return write_mode_;
}
inline int32_t PwriteReq::write_mode() const {
  // @@protoc_insertion_point(field_get:newlogstorepb.PwriteReq.write_mode)
  return _internal_write_mode();
}
inline void PwriteReq::_internal_set_write_mode(int32_t value) {

  write_mode_ = value;
}
inline void PwriteReq::set_write_mode(int32_t value) {
  _internal_set_write_mode(value);
  // @@protoc_insertion_point(field_set:newlogstorepb.PwriteReq.write_mode)
}

// -------------------------------------------------------------------

// PwriteResp

// int64 ret_code = 1;
inline void PwriteResp::clear_ret_code() {
  ret_code_ = int64_t{0};
}
inline int64_t PwriteResp::_internal_ret_code() const {
  return ret_code_;
}
inline int64_t PwriteResp::ret_code() const {
  // @@protoc_insertion_point(field_get:newlogstorepb.PwriteResp.ret_code)
  return _internal_ret_code();
}
inline void PwriteResp::_internal_set_ret_code(int64_t value) {

  ret_code_ = value;
}
inline void PwriteResp::set_ret_code(int64_t value) {
  _internal_set_ret_code(value);
  // @@protoc_insertion_point(field_set:newlogstorepb.PwriteResp.ret_code)
}

// int32 err_no = 2;
inline void PwriteResp::clear_err_no() {
  err_no_ = 0;
}
inline int32_t PwriteResp::_internal_err_no() const {
  return err_no_;
}
inline int32_t PwriteResp::err_no() const {
  // @@protoc_insertion_point(field_get:newlogstorepb.PwriteResp.err_no)
  return _internal_err_no();
}
inline void PwriteResp::_internal_set_err_no(int32_t value) {

  err_no_ = value;
}
inline void PwriteResp::set_err_no(int32_t value) {
  _internal_set_err_no(value);
  // @@protoc_insertion_point(field_set:newlogstorepb.PwriteResp.err_no)
}

// int64 size = 3;
inline void PwriteResp::clear_size() {
  size_ = int64_t{0};
}
inline int64_t PwriteResp::_internal_size() const {
  return size_;
}
inline int64_t PwriteResp::size() const {
  // @@protoc_insertion_point(field_get:newlogstorepb.PwriteResp.size)
  return _internal_size();
}
inline void PwriteResp::_internal_set_size(int64_t value) {

  size_ = value;
}
inline void PwriteResp::set_size(int64_t value) {
  _internal_set_size(value);
  // @@protoc_insertion_point(field_set:newlogstorepb.PwriteResp.size)
}

// -------------------------------------------------------------------

// PreadReq

// int64 epoch = 1;
inline void PreadReq::clear_epoch() {
  epoch_ = int64_t{0};
}
inline int64_t PreadReq::_internal_epoch() const {
  return epoch_;
}
inline int64_t PreadReq::epoch() const {
  // @@protoc_insertion_point(field_get:newlogstorepb.PreadReq.epoch)
  return _internal_epoch();
}
inline void PreadReq::_internal_set_epoch(int64_t value) {

  epoch_ = value;
}
inline void PreadReq::set_epoch(int64_t value) {
  _internal_set_epoch(value);
  // @@protoc_insertion_point(field_set:newlogstorepb.PreadReq.epoch)
}

// int32 fd = 2;
inline void PreadReq::clear_fd() {
  fd_ = 0;
}
inline int32_t PreadReq::_internal_fd() const {
  return fd_;
}
inline int32_t PreadReq::fd() const {
  // @@protoc_insertion_point(field_get:newlogstorepb.PreadReq.fd)
  return _internal_fd();
}
inline void PreadReq::_internal_set_fd(int32_t value) {

  fd_ = value;
}
inline void PreadReq::set_fd(int32_t value) {
  _internal_set_fd(value);
  // @@protoc_insertion_point(field_set:newlogstorepb.PreadReq.fd)
}

// uint64 size = 3;
inline void PreadReq::clear_size() {
  size_ = uint64_t{0u};
}
inline uint64_t PreadReq::_internal_size() const {
  return size_;
}
inline uint64_t PreadReq::size() const {
  // @@protoc_insertion_point(field_get:newlogstorepb.PreadReq.size)
  return _internal_size();
}
inline void PreadReq::_internal_set_size(uint64_t value) {

  size_ = value;
}
inline void PreadReq::set_size(uint64_t value) {
  _internal_set_size(value);
  // @@protoc_insertion_point(field_set:newlogstorepb.PreadReq.size)
}

// uint64 offset = 4;
inline void PreadReq::clear_offset() {
  offset_ = uint64_t{0u};
}
inline uint64_t PreadReq::_internal_offset() const {
  return offset_;
}
inline uint64_t PreadReq::offset() const {
  // @@protoc_insertion_point(field_get:newlogstorepb.PreadReq.offset)
  return _internal_offset();
}
inline void PreadReq::_internal_set_offset(uint64_t value) {

  offset_ = value;
}
inline void PreadReq::set_offset(uint64_t value) {
  _internal_set_offset(value);
  // @@protoc_insertion_point(field_set:newlogstorepb.PreadReq.offset)
}

// -------------------------------------------------------------------

// PreadResp

// int64 ret_code = 1;
inline void PreadResp::clear_ret_code() {
  ret_code_ = int64_t{0};
}
inline int64_t PreadResp::_internal_ret_code() const {
  return ret_code_;
}
inline int64_t PreadResp::ret_code() const {
  // @@protoc_insertion_point(field_get:newlogstorepb.PreadResp.ret_code)
  return _internal_ret_code();
}
inline void PreadResp::_internal_set_ret_code(int64_t value) {

  ret_code_ = value;
}
inline void PreadResp::set_ret_code(int64_t value) {
  _internal_set_ret_code(value);
  // @@protoc_insertion_point(field_set:newlogstorepb.PreadResp.ret_code)
}

// int32 err_no = 2;
inline void PreadResp::clear_err_no() {
  err_no_ = 0;
}
inline int32_t PreadResp::_internal_err_no() const {
  return err_no_;
}
inline int32_t PreadResp::err_no() const {
  // @@protoc_insertion_point(field_get:newlogstorepb.PreadResp.err_no)
  return _internal_err_no();
}
inline void PreadResp::_internal_set_err_no(int32_t value) {

  err_no_ = value;
}
inline void PreadResp::set_err_no(int32_t value) {
  _internal_set_err_no(value);
  // @@protoc_insertion_point(field_set:newlogstorepb.PreadResp.err_no)
}

// bytes buf = 3;
inline void PreadResp::clear_buf() {
  buf_.ClearToEmpty();
}
inline const std::string& PreadResp::buf() const {
  // @@protoc_insertion_point(field_get:newlogstorepb.PreadResp.buf)
  return _internal_buf();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void PreadResp::set_buf(ArgT0&& arg0, ArgT... args) {

 buf_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:newlogstorepb.PreadResp.buf)
}
inline std::string* PreadResp::mutable_buf() {
  std::string* _s = _internal_mutable_buf();
  // @@protoc_insertion_point(field_mutable:newlogstorepb.PreadResp.buf)
  return _s;
}
inline const std::string& PreadResp::_internal_buf() const {
  return buf_.Get();
}
inline void PreadResp::_internal_set_buf(const std::string& value) {

  buf_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* PreadResp::_internal_mutable_buf() {

  return buf_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* PreadResp::release_buf() {
  // @@protoc_insertion_point(field_release:newlogstorepb.PreadResp.buf)
  return buf_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void PreadResp::set_allocated_buf(std::string* buf) {
  if (buf != nullptr) {

  } else {

  }
  buf_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), buf,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (buf_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    buf_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:newlogstorepb.PreadResp.buf)
}

// int64 size = 4;
inline void PreadResp::clear_size() {
  size_ = int64_t{0};
}
inline int64_t PreadResp::_internal_size() const {
  return size_;
}
inline int64_t PreadResp::size() const {
  // @@protoc_insertion_point(field_get:newlogstorepb.PreadResp.size)
  return _internal_size();
}
inline void PreadResp::_internal_set_size(int64_t value) {

  size_ = value;
}
inline void PreadResp::set_size(int64_t value) {
  _internal_set_size(value);
  // @@protoc_insertion_point(field_set:newlogstorepb.PreadResp.size)
}

// -------------------------------------------------------------------

// FallocateReq

// int64 epoch = 1;
inline void FallocateReq::clear_epoch() {
  epoch_ = int64_t{0};
}
inline int64_t FallocateReq::_internal_epoch() const {
  return epoch_;
}
inline int64_t FallocateReq::epoch() const {
  // @@protoc_insertion_point(field_get:newlogstorepb.FallocateReq.epoch)
  return _internal_epoch();
}
inline void FallocateReq::_internal_set_epoch(int64_t value) {

  epoch_ = value;
}
inline void FallocateReq::set_epoch(int64_t value) {
  _internal_set_epoch(value);
  // @@protoc_insertion_point(field_set:newlogstorepb.FallocateReq.epoch)
}

// int32 fd = 2;
inline void FallocateReq::clear_fd() {
  fd_ = 0;
}
inline int32_t FallocateReq::_internal_fd() const {
  return fd_;
}
inline int32_t FallocateReq::fd() const {
  // @@protoc_insertion_point(field_get:newlogstorepb.FallocateReq.fd)
  return _internal_fd();
}
inline void FallocateReq::_internal_set_fd(int32_t value) {

  fd_ = value;
}
inline void FallocateReq::set_fd(int32_t value) {
  _internal_set_fd(value);
  // @@protoc_insertion_point(field_set:newlogstorepb.FallocateReq.fd)
}

// int32 mode = 3;
inline void FallocateReq::clear_mode() {
  mode_ = 0;
}
inline int32_t FallocateReq::_internal_mode() const {
  return mode_;
}
inline int32_t FallocateReq::mode() const {
  // @@protoc_insertion_point(field_get:newlogstorepb.FallocateReq.mode)
  return _internal_mode();
}
inline void FallocateReq::_internal_set_mode(int32_t value) {

  mode_ = value;
}
inline void FallocateReq::set_mode(int32_t value) {
  _internal_set_mode(value);
  // @@protoc_insertion_point(field_set:newlogstorepb.FallocateReq.mode)
}

// int64 offset = 4;
inline void FallocateReq::clear_offset() {
  offset_ = int64_t{0};
}
inline int64_t FallocateReq::_internal_offset() const {
  return offset_;
}
inline int64_t FallocateReq::offset() const {
  // @@protoc_insertion_point(field_get:newlogstorepb.FallocateReq.offset)
  return _internal_offset();
}
inline void FallocateReq::_internal_set_offset(int64_t value) {

  offset_ = value;
}
inline void FallocateReq::set_offset(int64_t value) {
  _internal_set_offset(value);
  // @@protoc_insertion_point(field_set:newlogstorepb.FallocateReq.offset)
}

// int64 len = 5;
inline void FallocateReq::clear_len() {
  len_ = int64_t{0};
}
inline int64_t FallocateReq::_internal_len() const {
  return len_;
}
inline int64_t FallocateReq::len() const {
  // @@protoc_insertion_point(field_get:newlogstorepb.FallocateReq.len)
  return _internal_len();
}
inline void FallocateReq::_internal_set_len(int64_t value) {

  len_ = value;
}
inline void FallocateReq::set_len(int64_t value) {
  _internal_set_len(value);
  // @@protoc_insertion_point(field_set:newlogstorepb.FallocateReq.len)
}

// -------------------------------------------------------------------

// FallocateResp

// int64 ret_code = 1;
inline void FallocateResp::clear_ret_code() {
  ret_code_ = int64_t{0};
}
inline int64_t FallocateResp::_internal_ret_code() const {
  return ret_code_;
}
inline int64_t FallocateResp::ret_code() const {
  // @@protoc_insertion_point(field_get:newlogstorepb.FallocateResp.ret_code)
  return _internal_ret_code();
}
inline void FallocateResp::_internal_set_ret_code(int64_t value) {

  ret_code_ = value;
}
inline void FallocateResp::set_ret_code(int64_t value) {
  _internal_set_ret_code(value);
  // @@protoc_insertion_point(field_set:newlogstorepb.FallocateResp.ret_code)
}

// int32 err_no = 2;
inline void FallocateResp::clear_err_no() {
  err_no_ = 0;
}
inline int32_t FallocateResp::_internal_err_no() const {
  return err_no_;
}
inline int32_t FallocateResp::err_no() const {
  // @@protoc_insertion_point(field_get:newlogstorepb.FallocateResp.err_no)
  return _internal_err_no();
}
inline void FallocateResp::_internal_set_err_no(int32_t value) {

  err_no_ = value;
}
inline void FallocateResp::set_err_no(int32_t value) {
  _internal_set_err_no(value);
  // @@protoc_insertion_point(field_set:newlogstorepb.FallocateResp.err_no)
}

// -------------------------------------------------------------------

// FtruncateReq

// int64 epoch = 1;
inline void FtruncateReq::clear_epoch() {
  epoch_ = int64_t{0};
}
inline int64_t FtruncateReq::_internal_epoch() const {
  return epoch_;
}
inline int64_t FtruncateReq::epoch() const {
  // @@protoc_insertion_point(field_get:newlogstorepb.FtruncateReq.epoch)
  return _internal_epoch();
}
inline void FtruncateReq::_internal_set_epoch(int64_t value) {

  epoch_ = value;
}
inline void FtruncateReq::set_epoch(int64_t value) {
  _internal_set_epoch(value);
  // @@protoc_insertion_point(field_set:newlogstorepb.FtruncateReq.epoch)
}

// int32 fd = 2;
inline void FtruncateReq::clear_fd() {
  fd_ = 0;
}
inline int32_t FtruncateReq::_internal_fd() const {
  return fd_;
}
inline int32_t FtruncateReq::fd() const {
  // @@protoc_insertion_point(field_get:newlogstorepb.FtruncateReq.fd)
  return _internal_fd();
}
inline void FtruncateReq::_internal_set_fd(int32_t value) {

  fd_ = value;
}
inline void FtruncateReq::set_fd(int32_t value) {
  _internal_set_fd(value);
  // @@protoc_insertion_point(field_set:newlogstorepb.FtruncateReq.fd)
}

// int64 len = 3;
inline void FtruncateReq::clear_len() {
  len_ = int64_t{0};
}
inline int64_t FtruncateReq::_internal_len() const {
  return len_;
}
inline int64_t FtruncateReq::len() const {
  // @@protoc_insertion_point(field_get:newlogstorepb.FtruncateReq.len)
  return _internal_len();
}
inline void FtruncateReq::_internal_set_len(int64_t value) {

  len_ = value;
}
inline void FtruncateReq::set_len(int64_t value) {
  _internal_set_len(value);
  // @@protoc_insertion_point(field_set:newlogstorepb.FtruncateReq.len)
}

// -------------------------------------------------------------------

// FtruncateResp

// int64 ret_code = 1;
inline void FtruncateResp::clear_ret_code() {
  ret_code_ = int64_t{0};
}
inline int64_t FtruncateResp::_internal_ret_code() const {
  return ret_code_;
}
inline int64_t FtruncateResp::ret_code() const {
  // @@protoc_insertion_point(field_get:newlogstorepb.FtruncateResp.ret_code)
  return _internal_ret_code();
}
inline void FtruncateResp::_internal_set_ret_code(int64_t value) {

  ret_code_ = value;
}
inline void FtruncateResp::set_ret_code(int64_t value) {
  _internal_set_ret_code(value);
  // @@protoc_insertion_point(field_set:newlogstorepb.FtruncateResp.ret_code)
}

// int32 err_no = 2;
inline void FtruncateResp::clear_err_no() {
  err_no_ = 0;
}
inline int32_t FtruncateResp::_internal_err_no() const {
  return err_no_;
}
inline int32_t FtruncateResp::err_no() const {
  // @@protoc_insertion_point(field_get:newlogstorepb.FtruncateResp.err_no)
  return _internal_err_no();
}
inline void FtruncateResp::_internal_set_err_no(int32_t value) {

  err_no_ = value;
}
inline void FtruncateResp::set_err_no(int32_t value) {
  _internal_set_err_no(value);
  // @@protoc_insertion_point(field_set:newlogstorepb.FtruncateResp.err_no)
}

// -------------------------------------------------------------------

// ScanDirReq

// int64 epoch = 1;
inline void ScanDirReq::clear_epoch() {
  epoch_ = int64_t{0};
}
inline int64_t ScanDirReq::_internal_epoch() const {
  return epoch_;
}
inline int64_t ScanDirReq::epoch() const {
  // @@protoc_insertion_point(field_get:newlogstorepb.ScanDirReq.epoch)
  return _internal_epoch();
}
inline void ScanDirReq::_internal_set_epoch(int64_t value) {

  epoch_ = value;
}
inline void ScanDirReq::set_epoch(int64_t value) {
  _internal_set_epoch(value);
  // @@protoc_insertion_point(field_set:newlogstorepb.ScanDirReq.epoch)
}

// string dirname = 2;
inline void ScanDirReq::clear_dirname() {
  dirname_.ClearToEmpty();
}
inline const std::string& ScanDirReq::dirname() const {
  // @@protoc_insertion_point(field_get:newlogstorepb.ScanDirReq.dirname)
  return _internal_dirname();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ScanDirReq::set_dirname(ArgT0&& arg0, ArgT... args) {

 dirname_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:newlogstorepb.ScanDirReq.dirname)
}
inline std::string* ScanDirReq::mutable_dirname() {
  std::string* _s = _internal_mutable_dirname();
  // @@protoc_insertion_point(field_mutable:newlogstorepb.ScanDirReq.dirname)
  return _s;
}
inline const std::string& ScanDirReq::_internal_dirname() const {
  return dirname_.Get();
}
inline void ScanDirReq::_internal_set_dirname(const std::string& value) {

  dirname_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* ScanDirReq::_internal_mutable_dirname() {

  return dirname_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* ScanDirReq::release_dirname() {
  // @@protoc_insertion_point(field_release:newlogstorepb.ScanDirReq.dirname)
  return dirname_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void ScanDirReq::set_allocated_dirname(std::string* dirname) {
  if (dirname != nullptr) {

  } else {

  }
  dirname_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), dirname,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (dirname_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    dirname_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:newlogstorepb.ScanDirReq.dirname)
}

// int32 req_type = 3;
inline void ScanDirReq::clear_req_type() {
  req_type_ = 0;
}
inline int32_t ScanDirReq::_internal_req_type() const {
  return req_type_;
}
inline int32_t ScanDirReq::req_type() const {
  // @@protoc_insertion_point(field_get:newlogstorepb.ScanDirReq.req_type)
  return _internal_req_type();
}
inline void ScanDirReq::_internal_set_req_type(int32_t value) {

  req_type_ = value;
}
inline void ScanDirReq::set_req_type(int32_t value) {
  _internal_set_req_type(value);
  // @@protoc_insertion_point(field_set:newlogstorepb.ScanDirReq.req_type)
}

// -------------------------------------------------------------------

// ScanDirResp1

// int64 ret_code = 1;
inline void ScanDirResp1::clear_ret_code() {
  ret_code_ = int64_t{0};
}
inline int64_t ScanDirResp1::_internal_ret_code() const {
  return ret_code_;
}
inline int64_t ScanDirResp1::ret_code() const {
  // @@protoc_insertion_point(field_get:newlogstorepb.ScanDirResp1.ret_code)
  return _internal_ret_code();
}
inline void ScanDirResp1::_internal_set_ret_code(int64_t value) {

  ret_code_ = value;
}
inline void ScanDirResp1::set_ret_code(int64_t value) {
  _internal_set_ret_code(value);
  // @@protoc_insertion_point(field_set:newlogstorepb.ScanDirResp1.ret_code)
}

// int32 err_no = 2;
inline void ScanDirResp1::clear_err_no() {
  err_no_ = 0;
}
inline int32_t ScanDirResp1::_internal_err_no() const {
  return err_no_;
}
inline int32_t ScanDirResp1::err_no() const {
  // @@protoc_insertion_point(field_get:newlogstorepb.ScanDirResp1.err_no)
  return _internal_err_no();
}
inline void ScanDirResp1::_internal_set_err_no(int32_t value) {

  err_no_ = value;
}
inline void ScanDirResp1::set_err_no(int32_t value) {
  _internal_set_err_no(value);
  // @@protoc_insertion_point(field_set:newlogstorepb.ScanDirResp1.err_no)
}

// -------------------------------------------------------------------

// ScanDirResp

// int32 req_type = 1;
inline void ScanDirResp::clear_req_type() {
  req_type_ = 0;
}
inline int32_t ScanDirResp::_internal_req_type() const {
  return req_type_;
}
inline int32_t ScanDirResp::req_type() const {
  // @@protoc_insertion_point(field_get:newlogstorepb.ScanDirResp.req_type)
  return _internal_req_type();
}
inline void ScanDirResp::_internal_set_req_type(int32_t value) {

  req_type_ = value;
}
inline void ScanDirResp::set_req_type(int32_t value) {
  _internal_set_req_type(value);
  // @@protoc_insertion_point(field_set:newlogstorepb.ScanDirResp.req_type)
}

// .newlogstorepb.ScanDirResp1 resp1 = 2;
inline bool ScanDirResp::_internal_has_resp1() const {
  return this != internal_default_instance() && resp1_ != nullptr;
}
inline bool ScanDirResp::has_resp1() const {
  return _internal_has_resp1();
}
inline void ScanDirResp::clear_resp1() {
  if (GetArenaForAllocation() == nullptr && resp1_ != nullptr) {
    delete resp1_;
  }
  resp1_ = nullptr;
}
inline const ::newlogstorepb::ScanDirResp1& ScanDirResp::_internal_resp1() const {
  const ::newlogstorepb::ScanDirResp1* p = resp1_;
  return p != nullptr ? *p : reinterpret_cast<const ::newlogstorepb::ScanDirResp1&>(
      ::newlogstorepb::_ScanDirResp1_default_instance_);
}
inline const ::newlogstorepb::ScanDirResp1& ScanDirResp::resp1() const {
  // @@protoc_insertion_point(field_get:newlogstorepb.ScanDirResp.resp1)
  return _internal_resp1();
}
inline void ScanDirResp::unsafe_arena_set_allocated_resp1(
    ::newlogstorepb::ScanDirResp1* resp1) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(resp1_);
  }
  resp1_ = resp1;
  if (resp1) {

  } else {

  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:newlogstorepb.ScanDirResp.resp1)
}
inline ::newlogstorepb::ScanDirResp1* ScanDirResp::release_resp1() {

  ::newlogstorepb::ScanDirResp1* temp = resp1_;
  resp1_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::newlogstorepb::ScanDirResp1* ScanDirResp::unsafe_arena_release_resp1() {
  // @@protoc_insertion_point(field_release:newlogstorepb.ScanDirResp.resp1)

  ::newlogstorepb::ScanDirResp1* temp = resp1_;
  resp1_ = nullptr;
  return temp;
}
inline ::newlogstorepb::ScanDirResp1* ScanDirResp::_internal_mutable_resp1() {

  if (resp1_ == nullptr) {
    auto* p = CreateMaybeMessage<::newlogstorepb::ScanDirResp1>(GetArenaForAllocation());
    resp1_ = p;
  }
  return resp1_;
}
inline ::newlogstorepb::ScanDirResp1* ScanDirResp::mutable_resp1() {
  ::newlogstorepb::ScanDirResp1* _msg = _internal_mutable_resp1();
  // @@protoc_insertion_point(field_mutable:newlogstorepb.ScanDirResp.resp1)
  return _msg;
}
inline void ScanDirResp::set_allocated_resp1(::newlogstorepb::ScanDirResp1* resp1) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete resp1_;
  }
  if (resp1) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::newlogstorepb::ScanDirResp1>::GetOwningArena(resp1);
    if (message_arena != submessage_arena) {
      resp1 = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, resp1, submessage_arena);
    }

  } else {

  }
  resp1_ = resp1;
  // @@protoc_insertion_point(field_set_allocated:newlogstorepb.ScanDirResp.resp1)
}

// -------------------------------------------------------------------

// UnlinkReq

// int64 epoch = 1;
inline void UnlinkReq::clear_epoch() {
  epoch_ = int64_t{0};
}
inline int64_t UnlinkReq::_internal_epoch() const {
  return epoch_;
}
inline int64_t UnlinkReq::epoch() const {
  // @@protoc_insertion_point(field_get:newlogstorepb.UnlinkReq.epoch)
  return _internal_epoch();
}
inline void UnlinkReq::_internal_set_epoch(int64_t value) {

  epoch_ = value;
}
inline void UnlinkReq::set_epoch(int64_t value) {
  _internal_set_epoch(value);
  // @@protoc_insertion_point(field_set:newlogstorepb.UnlinkReq.epoch)
}

// string pathname = 2;
inline void UnlinkReq::clear_pathname() {
  pathname_.ClearToEmpty();
}
inline const std::string& UnlinkReq::pathname() const {
  // @@protoc_insertion_point(field_get:newlogstorepb.UnlinkReq.pathname)
  return _internal_pathname();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void UnlinkReq::set_pathname(ArgT0&& arg0, ArgT... args) {

 pathname_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:newlogstorepb.UnlinkReq.pathname)
}
inline std::string* UnlinkReq::mutable_pathname() {
  std::string* _s = _internal_mutable_pathname();
  // @@protoc_insertion_point(field_mutable:newlogstorepb.UnlinkReq.pathname)
  return _s;
}
inline const std::string& UnlinkReq::_internal_pathname() const {
  return pathname_.Get();
}
inline void UnlinkReq::_internal_set_pathname(const std::string& value) {

  pathname_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* UnlinkReq::_internal_mutable_pathname() {

  return pathname_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* UnlinkReq::release_pathname() {
  // @@protoc_insertion_point(field_release:newlogstorepb.UnlinkReq.pathname)
  return pathname_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void UnlinkReq::set_allocated_pathname(std::string* pathname) {
  if (pathname != nullptr) {

  } else {

  }
  pathname_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), pathname,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (pathname_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    pathname_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:newlogstorepb.UnlinkReq.pathname)
}

// -------------------------------------------------------------------

// UnlinkResp

// int64 ret_code = 1;
inline void UnlinkResp::clear_ret_code() {
  ret_code_ = int64_t{0};
}
inline int64_t UnlinkResp::_internal_ret_code() const {
  return ret_code_;
}
inline int64_t UnlinkResp::ret_code() const {
  // @@protoc_insertion_point(field_get:newlogstorepb.UnlinkResp.ret_code)
  return _internal_ret_code();
}
inline void UnlinkResp::_internal_set_ret_code(int64_t value) {

  ret_code_ = value;
}
inline void UnlinkResp::set_ret_code(int64_t value) {
  _internal_set_ret_code(value);
  // @@protoc_insertion_point(field_set:newlogstorepb.UnlinkResp.ret_code)
}

// int32 err_no = 2;
inline void UnlinkResp::clear_err_no() {
  err_no_ = 0;
}
inline int32_t UnlinkResp::_internal_err_no() const {
  return err_no_;
}
inline int32_t UnlinkResp::err_no() const {
  // @@protoc_insertion_point(field_get:newlogstorepb.UnlinkResp.err_no)
  return _internal_err_no();
}
inline void UnlinkResp::_internal_set_err_no(int32_t value) {

  err_no_ = value;
}
inline void UnlinkResp::set_err_no(int32_t value) {
  _internal_set_err_no(value);
  // @@protoc_insertion_point(field_set:newlogstorepb.UnlinkResp.err_no)
}

// -------------------------------------------------------------------

// MkdirReq

// int64 epoch = 1;
inline void MkdirReq::clear_epoch() {
  epoch_ = int64_t{0};
}
inline int64_t MkdirReq::_internal_epoch() const {
  return epoch_;
}
inline int64_t MkdirReq::epoch() const {
  // @@protoc_insertion_point(field_get:newlogstorepb.MkdirReq.epoch)
  return _internal_epoch();
}
inline void MkdirReq::_internal_set_epoch(int64_t value) {

  epoch_ = value;
}
inline void MkdirReq::set_epoch(int64_t value) {
  _internal_set_epoch(value);
  // @@protoc_insertion_point(field_set:newlogstorepb.MkdirReq.epoch)
}

// string pathname = 2;
inline void MkdirReq::clear_pathname() {
  pathname_.ClearToEmpty();
}
inline const std::string& MkdirReq::pathname() const {
  // @@protoc_insertion_point(field_get:newlogstorepb.MkdirReq.pathname)
  return _internal_pathname();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void MkdirReq::set_pathname(ArgT0&& arg0, ArgT... args) {

 pathname_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:newlogstorepb.MkdirReq.pathname)
}
inline std::string* MkdirReq::mutable_pathname() {
  std::string* _s = _internal_mutable_pathname();
  // @@protoc_insertion_point(field_mutable:newlogstorepb.MkdirReq.pathname)
  return _s;
}
inline const std::string& MkdirReq::_internal_pathname() const {
  return pathname_.Get();
}
inline void MkdirReq::_internal_set_pathname(const std::string& value) {

  pathname_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* MkdirReq::_internal_mutable_pathname() {

  return pathname_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* MkdirReq::release_pathname() {
  // @@protoc_insertion_point(field_release:newlogstorepb.MkdirReq.pathname)
  return pathname_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void MkdirReq::set_allocated_pathname(std::string* pathname) {
  if (pathname != nullptr) {

  } else {

  }
  pathname_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), pathname,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (pathname_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    pathname_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:newlogstorepb.MkdirReq.pathname)
}

// uint32 mode = 3;
inline void MkdirReq::clear_mode() {
  mode_ = 0u;
}
inline uint32_t MkdirReq::_internal_mode() const {
  return mode_;
}
inline uint32_t MkdirReq::mode() const {
  // @@protoc_insertion_point(field_get:newlogstorepb.MkdirReq.mode)
  return _internal_mode();
}
inline void MkdirReq::_internal_set_mode(uint32_t value) {

  mode_ = value;
}
inline void MkdirReq::set_mode(uint32_t value) {
  _internal_set_mode(value);
  // @@protoc_insertion_point(field_set:newlogstorepb.MkdirReq.mode)
}

// -------------------------------------------------------------------

// MkdirResp

// int64 ret_code = 1;
inline void MkdirResp::clear_ret_code() {
  ret_code_ = int64_t{0};
}
inline int64_t MkdirResp::_internal_ret_code() const {
  return ret_code_;
}
inline int64_t MkdirResp::ret_code() const {
  // @@protoc_insertion_point(field_get:newlogstorepb.MkdirResp.ret_code)
  return _internal_ret_code();
}
inline void MkdirResp::_internal_set_ret_code(int64_t value) {

  ret_code_ = value;
}
inline void MkdirResp::set_ret_code(int64_t value) {
  _internal_set_ret_code(value);
  // @@protoc_insertion_point(field_set:newlogstorepb.MkdirResp.ret_code)
}

// int32 err_no = 2;
inline void MkdirResp::clear_err_no() {
  err_no_ = 0;
}
inline int32_t MkdirResp::_internal_err_no() const {
  return err_no_;
}
inline int32_t MkdirResp::err_no() const {
  // @@protoc_insertion_point(field_get:newlogstorepb.MkdirResp.err_no)
  return _internal_err_no();
}
inline void MkdirResp::_internal_set_err_no(int32_t value) {

  err_no_ = value;
}
inline void MkdirResp::set_err_no(int32_t value) {
  _internal_set_err_no(value);
  // @@protoc_insertion_point(field_set:newlogstorepb.MkdirResp.err_no)
}

// -------------------------------------------------------------------

// RmdirReq

// int64 epoch = 1;
inline void RmdirReq::clear_epoch() {
  epoch_ = int64_t{0};
}
inline int64_t RmdirReq::_internal_epoch() const {
  return epoch_;
}
inline int64_t RmdirReq::epoch() const {
  // @@protoc_insertion_point(field_get:newlogstorepb.RmdirReq.epoch)
  return _internal_epoch();
}
inline void RmdirReq::_internal_set_epoch(int64_t value) {

  epoch_ = value;
}
inline void RmdirReq::set_epoch(int64_t value) {
  _internal_set_epoch(value);
  // @@protoc_insertion_point(field_set:newlogstorepb.RmdirReq.epoch)
}

// string pathname = 2;
inline void RmdirReq::clear_pathname() {
  pathname_.ClearToEmpty();
}
inline const std::string& RmdirReq::pathname() const {
  // @@protoc_insertion_point(field_get:newlogstorepb.RmdirReq.pathname)
  return _internal_pathname();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void RmdirReq::set_pathname(ArgT0&& arg0, ArgT... args) {

 pathname_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:newlogstorepb.RmdirReq.pathname)
}
inline std::string* RmdirReq::mutable_pathname() {
  std::string* _s = _internal_mutable_pathname();
  // @@protoc_insertion_point(field_mutable:newlogstorepb.RmdirReq.pathname)
  return _s;
}
inline const std::string& RmdirReq::_internal_pathname() const {
  return pathname_.Get();
}
inline void RmdirReq::_internal_set_pathname(const std::string& value) {

  pathname_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* RmdirReq::_internal_mutable_pathname() {

  return pathname_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* RmdirReq::release_pathname() {
  // @@protoc_insertion_point(field_release:newlogstorepb.RmdirReq.pathname)
  return pathname_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void RmdirReq::set_allocated_pathname(std::string* pathname) {
  if (pathname != nullptr) {

  } else {

  }
  pathname_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), pathname,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (pathname_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    pathname_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:newlogstorepb.RmdirReq.pathname)
}

// -------------------------------------------------------------------

// RmdirResp

// int64 ret_code = 1;
inline void RmdirResp::clear_ret_code() {
  ret_code_ = int64_t{0};
}
inline int64_t RmdirResp::_internal_ret_code() const {
  return ret_code_;
}
inline int64_t RmdirResp::ret_code() const {
  // @@protoc_insertion_point(field_get:newlogstorepb.RmdirResp.ret_code)
  return _internal_ret_code();
}
inline void RmdirResp::_internal_set_ret_code(int64_t value) {

  ret_code_ = value;
}
inline void RmdirResp::set_ret_code(int64_t value) {
  _internal_set_ret_code(value);
  // @@protoc_insertion_point(field_set:newlogstorepb.RmdirResp.ret_code)
}

// int32 err_no = 2;
inline void RmdirResp::clear_err_no() {
  err_no_ = 0;
}
inline int32_t RmdirResp::_internal_err_no() const {
  return err_no_;
}
inline int32_t RmdirResp::err_no() const {
  // @@protoc_insertion_point(field_get:newlogstorepb.RmdirResp.err_no)
  return _internal_err_no();
}
inline void RmdirResp::_internal_set_err_no(int32_t value) {

  err_no_ = value;
}
inline void RmdirResp::set_err_no(int32_t value) {
  _internal_set_err_no(value);
  // @@protoc_insertion_point(field_set:newlogstorepb.RmdirResp.err_no)
}

// -------------------------------------------------------------------

// StatReq

// int64 epoch = 1;
inline void StatReq::clear_epoch() {
  epoch_ = int64_t{0};
}
inline int64_t StatReq::_internal_epoch() const {
  return epoch_;
}
inline int64_t StatReq::epoch() const {
  // @@protoc_insertion_point(field_get:newlogstorepb.StatReq.epoch)
  return _internal_epoch();
}
inline void StatReq::_internal_set_epoch(int64_t value) {

  epoch_ = value;
}
inline void StatReq::set_epoch(int64_t value) {
  _internal_set_epoch(value);
  // @@protoc_insertion_point(field_set:newlogstorepb.StatReq.epoch)
}

// string pathname = 2;
inline void StatReq::clear_pathname() {
  pathname_.ClearToEmpty();
}
inline const std::string& StatReq::pathname() const {
  // @@protoc_insertion_point(field_get:newlogstorepb.StatReq.pathname)
  return _internal_pathname();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void StatReq::set_pathname(ArgT0&& arg0, ArgT... args) {

 pathname_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:newlogstorepb.StatReq.pathname)
}
inline std::string* StatReq::mutable_pathname() {
  std::string* _s = _internal_mutable_pathname();
  // @@protoc_insertion_point(field_mutable:newlogstorepb.StatReq.pathname)
  return _s;
}
inline const std::string& StatReq::_internal_pathname() const {
  return pathname_.Get();
}
inline void StatReq::_internal_set_pathname(const std::string& value) {

  pathname_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* StatReq::_internal_mutable_pathname() {

  return pathname_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* StatReq::release_pathname() {
  // @@protoc_insertion_point(field_release:newlogstorepb.StatReq.pathname)
  return pathname_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void StatReq::set_allocated_pathname(std::string* pathname) {
  if (pathname != nullptr) {

  } else {

  }
  pathname_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), pathname,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (pathname_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    pathname_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:newlogstorepb.StatReq.pathname)
}

// -------------------------------------------------------------------

// StatResp

// int64 ret_code = 1;
inline void StatResp::clear_ret_code() {
  ret_code_ = int64_t{0};
}
inline int64_t StatResp::_internal_ret_code() const {
  return ret_code_;
}
inline int64_t StatResp::ret_code() const {
  // @@protoc_insertion_point(field_get:newlogstorepb.StatResp.ret_code)
  return _internal_ret_code();
}
inline void StatResp::_internal_set_ret_code(int64_t value) {

  ret_code_ = value;
}
inline void StatResp::set_ret_code(int64_t value) {
  _internal_set_ret_code(value);
  // @@protoc_insertion_point(field_set:newlogstorepb.StatResp.ret_code)
}

// int32 err_no = 2;
inline void StatResp::clear_err_no() {
  err_no_ = 0;
}
inline int32_t StatResp::_internal_err_no() const {
  return err_no_;
}
inline int32_t StatResp::err_no() const {
  // @@protoc_insertion_point(field_get:newlogstorepb.StatResp.err_no)
  return _internal_err_no();
}
inline void StatResp::_internal_set_err_no(int32_t value) {

  err_no_ = value;
}
inline void StatResp::set_err_no(int32_t value) {
  _internal_set_err_no(value);
  // @@protoc_insertion_point(field_set:newlogstorepb.StatResp.err_no)
}

// bool is_dir = 3;
inline void StatResp::clear_is_dir() {
  is_dir_ = false;
}
inline bool StatResp::_internal_is_dir() const {
  return is_dir_;
}
inline bool StatResp::is_dir() const {
  // @@protoc_insertion_point(field_get:newlogstorepb.StatResp.is_dir)
  return _internal_is_dir();
}
inline void StatResp::_internal_set_is_dir(bool value) {

  is_dir_ = value;
}
inline void StatResp::set_is_dir(bool value) {
  _internal_set_is_dir(value);
  // @@protoc_insertion_point(field_set:newlogstorepb.StatResp.is_dir)
}

// uint64 st_size = 4;
inline void StatResp::clear_st_size() {
  st_size_ = uint64_t{0u};
}
inline uint64_t StatResp::_internal_st_size() const {
  return st_size_;
}
inline uint64_t StatResp::st_size() const {
  // @@protoc_insertion_point(field_get:newlogstorepb.StatResp.st_size)
  return _internal_st_size();
}
inline void StatResp::_internal_set_st_size(uint64_t value) {

  st_size_ = value;
}
inline void StatResp::set_st_size(uint64_t value) {
  _internal_set_st_size(value);
  // @@protoc_insertion_point(field_set:newlogstorepb.StatResp.st_size)
}

// -------------------------------------------------------------------

// RenameReq

// int64 epoch = 1;
inline void RenameReq::clear_epoch() {
  epoch_ = int64_t{0};
}
inline int64_t RenameReq::_internal_epoch() const {
  return epoch_;
}
inline int64_t RenameReq::epoch() const {
  // @@protoc_insertion_point(field_get:newlogstorepb.RenameReq.epoch)
  return _internal_epoch();
}
inline void RenameReq::_internal_set_epoch(int64_t value) {

  epoch_ = value;
}
inline void RenameReq::set_epoch(int64_t value) {
  _internal_set_epoch(value);
  // @@protoc_insertion_point(field_set:newlogstorepb.RenameReq.epoch)
}

// string oldpath = 2;
inline void RenameReq::clear_oldpath() {
  oldpath_.ClearToEmpty();
}
inline const std::string& RenameReq::oldpath() const {
  // @@protoc_insertion_point(field_get:newlogstorepb.RenameReq.oldpath)
  return _internal_oldpath();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void RenameReq::set_oldpath(ArgT0&& arg0, ArgT... args) {

 oldpath_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:newlogstorepb.RenameReq.oldpath)
}
inline std::string* RenameReq::mutable_oldpath() {
  std::string* _s = _internal_mutable_oldpath();
  // @@protoc_insertion_point(field_mutable:newlogstorepb.RenameReq.oldpath)
  return _s;
}
inline const std::string& RenameReq::_internal_oldpath() const {
  return oldpath_.Get();
}
inline void RenameReq::_internal_set_oldpath(const std::string& value) {

  oldpath_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* RenameReq::_internal_mutable_oldpath() {

  return oldpath_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* RenameReq::release_oldpath() {
  // @@protoc_insertion_point(field_release:newlogstorepb.RenameReq.oldpath)
  return oldpath_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void RenameReq::set_allocated_oldpath(std::string* oldpath) {
  if (oldpath != nullptr) {

  } else {

  }
  oldpath_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), oldpath,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (oldpath_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    oldpath_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:newlogstorepb.RenameReq.oldpath)
}

// string newpath = 3;
inline void RenameReq::clear_newpath() {
  newpath_.ClearToEmpty();
}
inline const std::string& RenameReq::newpath() const {
  // @@protoc_insertion_point(field_get:newlogstorepb.RenameReq.newpath)
  return _internal_newpath();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void RenameReq::set_newpath(ArgT0&& arg0, ArgT... args) {

 newpath_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:newlogstorepb.RenameReq.newpath)
}
inline std::string* RenameReq::mutable_newpath() {
  std::string* _s = _internal_mutable_newpath();
  // @@protoc_insertion_point(field_mutable:newlogstorepb.RenameReq.newpath)
  return _s;
}
inline const std::string& RenameReq::_internal_newpath() const {
  return newpath_.Get();
}
inline void RenameReq::_internal_set_newpath(const std::string& value) {

  newpath_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* RenameReq::_internal_mutable_newpath() {

  return newpath_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* RenameReq::release_newpath() {
  // @@protoc_insertion_point(field_release:newlogstorepb.RenameReq.newpath)
  return newpath_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void RenameReq::set_allocated_newpath(std::string* newpath) {
  if (newpath != nullptr) {

  } else {

  }
  newpath_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), newpath,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (newpath_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    newpath_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:newlogstorepb.RenameReq.newpath)
}

// -------------------------------------------------------------------

// RenameResp

// int64 ret_code = 1;
inline void RenameResp::clear_ret_code() {
  ret_code_ = int64_t{0};
}
inline int64_t RenameResp::_internal_ret_code() const {
  return ret_code_;
}
inline int64_t RenameResp::ret_code() const {
  // @@protoc_insertion_point(field_get:newlogstorepb.RenameResp.ret_code)
  return _internal_ret_code();
}
inline void RenameResp::_internal_set_ret_code(int64_t value) {

  ret_code_ = value;
}
inline void RenameResp::set_ret_code(int64_t value) {
  _internal_set_ret_code(value);
  // @@protoc_insertion_point(field_set:newlogstorepb.RenameResp.ret_code)
}

// int32 err_no = 2;
inline void RenameResp::clear_err_no() {
  err_no_ = 0;
}
inline int32_t RenameResp::_internal_err_no() const {
  return err_no_;
}
inline int32_t RenameResp::err_no() const {
  // @@protoc_insertion_point(field_get:newlogstorepb.RenameResp.err_no)
  return _internal_err_no();
}
inline void RenameResp::_internal_set_err_no(int32_t value) {

  err_no_ = value;
}
inline void RenameResp::set_err_no(int32_t value) {
  _internal_set_err_no(value);
  // @@protoc_insertion_point(field_set:newlogstorepb.RenameResp.err_no)
}

// -------------------------------------------------------------------

// FsyncReq

// int64 epoch = 1;
inline void FsyncReq::clear_epoch() {
  epoch_ = int64_t{0};
}
inline int64_t FsyncReq::_internal_epoch() const {
  return epoch_;
}
inline int64_t FsyncReq::epoch() const {
  // @@protoc_insertion_point(field_get:newlogstorepb.FsyncReq.epoch)
  return _internal_epoch();
}
inline void FsyncReq::_internal_set_epoch(int64_t value) {

  epoch_ = value;
}
inline void FsyncReq::set_epoch(int64_t value) {
  _internal_set_epoch(value);
  // @@protoc_insertion_point(field_set:newlogstorepb.FsyncReq.epoch)
}

// int32 fd = 2;
inline void FsyncReq::clear_fd() {
  fd_ = 0;
}
inline int32_t FsyncReq::_internal_fd() const {
  return fd_;
}
inline int32_t FsyncReq::fd() const {
  // @@protoc_insertion_point(field_get:newlogstorepb.FsyncReq.fd)
  return _internal_fd();
}
inline void FsyncReq::_internal_set_fd(int32_t value) {

  fd_ = value;
}
inline void FsyncReq::set_fd(int32_t value) {
  _internal_set_fd(value);
  // @@protoc_insertion_point(field_set:newlogstorepb.FsyncReq.fd)
}

// -------------------------------------------------------------------

// FsyncResp

// int64 ret_code = 1;
inline void FsyncResp::clear_ret_code() {
  ret_code_ = int64_t{0};
}
inline int64_t FsyncResp::_internal_ret_code() const {
  return ret_code_;
}
inline int64_t FsyncResp::ret_code() const {
  // @@protoc_insertion_point(field_get:newlogstorepb.FsyncResp.ret_code)
  return _internal_ret_code();
}
inline void FsyncResp::_internal_set_ret_code(int64_t value) {

  ret_code_ = value;
}
inline void FsyncResp::set_ret_code(int64_t value) {
  _internal_set_ret_code(value);
  // @@protoc_insertion_point(field_set:newlogstorepb.FsyncResp.ret_code)
}

// int32 err_no = 2;
inline void FsyncResp::clear_err_no() {
  err_no_ = 0;
}
inline int32_t FsyncResp::_internal_err_no() const {
  return err_no_;
}
inline int32_t FsyncResp::err_no() const {
  // @@protoc_insertion_point(field_get:newlogstorepb.FsyncResp.err_no)
  return _internal_err_no();
}
inline void FsyncResp::_internal_set_err_no(int32_t value) {

  err_no_ = value;
}
inline void FsyncResp::set_err_no(int32_t value) {
  _internal_set_err_no(value);
  // @@protoc_insertion_point(field_set:newlogstorepb.FsyncResp.err_no)
}

// -------------------------------------------------------------------

// GetLogStoreInfoReq

// int64 epoch = 1;
inline void GetLogStoreInfoReq::clear_epoch() {
  epoch_ = int64_t{0};
}
inline int64_t GetLogStoreInfoReq::_internal_epoch() const {
  return epoch_;
}
inline int64_t GetLogStoreInfoReq::epoch() const {
  // @@protoc_insertion_point(field_get:newlogstorepb.GetLogStoreInfoReq.epoch)
  return _internal_epoch();
}
inline void GetLogStoreInfoReq::_internal_set_epoch(int64_t value) {

  epoch_ = value;
}
inline void GetLogStoreInfoReq::set_epoch(int64_t value) {
  _internal_set_epoch(value);
  // @@protoc_insertion_point(field_set:newlogstorepb.GetLogStoreInfoReq.epoch)
}

// -------------------------------------------------------------------

// GetLogStoreInfoResp

// int64 ret_code = 1;
inline void GetLogStoreInfoResp::clear_ret_code() {
  ret_code_ = int64_t{0};
}
inline int64_t GetLogStoreInfoResp::_internal_ret_code() const {
  return ret_code_;
}
inline int64_t GetLogStoreInfoResp::ret_code() const {
  // @@protoc_insertion_point(field_get:newlogstorepb.GetLogStoreInfoResp.ret_code)
  return _internal_ret_code();
}
inline void GetLogStoreInfoResp::_internal_set_ret_code(int64_t value) {

  ret_code_ = value;
}
inline void GetLogStoreInfoResp::set_ret_code(int64_t value) {
  _internal_set_ret_code(value);
  // @@protoc_insertion_point(field_set:newlogstorepb.GetLogStoreInfoResp.ret_code)
}

// int64 memory_limit = 2;
inline void GetLogStoreInfoResp::clear_memory_limit() {
  memory_limit_ = int64_t{0};
}
inline int64_t GetLogStoreInfoResp::_internal_memory_limit() const {
  return memory_limit_;
}
inline int64_t GetLogStoreInfoResp::memory_limit() const {
  // @@protoc_insertion_point(field_get:newlogstorepb.GetLogStoreInfoResp.memory_limit)
  return _internal_memory_limit();
}
inline void GetLogStoreInfoResp::_internal_set_memory_limit(int64_t value) {

  memory_limit_ = value;
}
inline void GetLogStoreInfoResp::set_memory_limit(int64_t value) {
  _internal_set_memory_limit(value);
  // @@protoc_insertion_point(field_set:newlogstorepb.GetLogStoreInfoResp.memory_limit)
}

// int64 memory_used = 3;
inline void GetLogStoreInfoResp::clear_memory_used() {
  memory_used_ = int64_t{0};
}
inline int64_t GetLogStoreInfoResp::_internal_memory_used() const {
  return memory_used_;
}
inline int64_t GetLogStoreInfoResp::memory_used() const {
  // @@protoc_insertion_point(field_get:newlogstorepb.GetLogStoreInfoResp.memory_used)
  return _internal_memory_used();
}
inline void GetLogStoreInfoResp::_internal_set_memory_used(int64_t value) {

  memory_used_ = value;
}
inline void GetLogStoreInfoResp::set_memory_used(int64_t value) {
  _internal_set_memory_used(value);
  // @@protoc_insertion_point(field_set:newlogstorepb.GetLogStoreInfoResp.memory_used)
}

// int64 shm_limit = 4;
inline void GetLogStoreInfoResp::clear_shm_limit() {
  shm_limit_ = int64_t{0};
}
inline int64_t GetLogStoreInfoResp::_internal_shm_limit() const {
  return shm_limit_;
}
inline int64_t GetLogStoreInfoResp::shm_limit() const {
  // @@protoc_insertion_point(field_get:newlogstorepb.GetLogStoreInfoResp.shm_limit)
  return _internal_shm_limit();
}
inline void GetLogStoreInfoResp::_internal_set_shm_limit(int64_t value) {

  shm_limit_ = value;
}
inline void GetLogStoreInfoResp::set_shm_limit(int64_t value) {
  _internal_set_shm_limit(value);
  // @@protoc_insertion_point(field_set:newlogstorepb.GetLogStoreInfoResp.shm_limit)
}

// int64 shm_used = 5;
inline void GetLogStoreInfoResp::clear_shm_used() {
  shm_used_ = int64_t{0};
}
inline int64_t GetLogStoreInfoResp::_internal_shm_used() const {
  return shm_used_;
}
inline int64_t GetLogStoreInfoResp::shm_used() const {
  // @@protoc_insertion_point(field_get:newlogstorepb.GetLogStoreInfoResp.shm_used)
  return _internal_shm_used();
}
inline void GetLogStoreInfoResp::_internal_set_shm_used(int64_t value) {

  shm_used_ = value;
}
inline void GetLogStoreInfoResp::set_shm_used(int64_t value) {
  _internal_set_shm_used(value);
  // @@protoc_insertion_point(field_set:newlogstorepb.GetLogStoreInfoResp.shm_used)
}

// -------------------------------------------------------------------

// BatchFallocateReq

// int64 epoch = 1;
inline void BatchFallocateReq::clear_epoch() {
  epoch_ = int64_t{0};
}
inline int64_t BatchFallocateReq::_internal_epoch() const {
  return epoch_;
}
inline int64_t BatchFallocateReq::epoch() const {
  // @@protoc_insertion_point(field_get:newlogstorepb.BatchFallocateReq.epoch)
  return _internal_epoch();
}
inline void BatchFallocateReq::_internal_set_epoch(int64_t value) {

  epoch_ = value;
}
inline void BatchFallocateReq::set_epoch(int64_t value) {
  _internal_set_epoch(value);
  // @@protoc_insertion_point(field_set:newlogstorepb.BatchFallocateReq.epoch)
}

// string dirname = 2;
inline void BatchFallocateReq::clear_dirname() {
  dirname_.ClearToEmpty();
}
inline const std::string& BatchFallocateReq::dirname() const {
  // @@protoc_insertion_point(field_get:newlogstorepb.BatchFallocateReq.dirname)
  return _internal_dirname();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void BatchFallocateReq::set_dirname(ArgT0&& arg0, ArgT... args) {

 dirname_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:newlogstorepb.BatchFallocateReq.dirname)
}
inline std::string* BatchFallocateReq::mutable_dirname() {
  std::string* _s = _internal_mutable_dirname();
  // @@protoc_insertion_point(field_mutable:newlogstorepb.BatchFallocateReq.dirname)
  return _s;
}
inline const std::string& BatchFallocateReq::_internal_dirname() const {
  return dirname_.Get();
}
inline void BatchFallocateReq::_internal_set_dirname(const std::string& value) {

  dirname_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* BatchFallocateReq::_internal_mutable_dirname() {

  return dirname_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* BatchFallocateReq::release_dirname() {
  // @@protoc_insertion_point(field_release:newlogstorepb.BatchFallocateReq.dirname)
  return dirname_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void BatchFallocateReq::set_allocated_dirname(std::string* dirname) {
  if (dirname != nullptr) {

  } else {

  }
  dirname_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), dirname,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (dirname_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    dirname_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:newlogstorepb.BatchFallocateReq.dirname)
}

// int64 count = 3;
inline void BatchFallocateReq::clear_count() {
  count_ = int64_t{0};
}
inline int64_t BatchFallocateReq::_internal_count() const {
  return count_;
}
inline int64_t BatchFallocateReq::count() const {
  // @@protoc_insertion_point(field_get:newlogstorepb.BatchFallocateReq.count)
  return _internal_count();
}
inline void BatchFallocateReq::_internal_set_count(int64_t value) {

  count_ = value;
}
inline void BatchFallocateReq::set_count(int64_t value) {
  _internal_set_count(value);
  // @@protoc_insertion_point(field_set:newlogstorepb.BatchFallocateReq.count)
}

// int64 size = 4;
inline void BatchFallocateReq::clear_size() {
  size_ = int64_t{0};
}
inline int64_t BatchFallocateReq::_internal_size() const {
  return size_;
}
inline int64_t BatchFallocateReq::size() const {
  // @@protoc_insertion_point(field_get:newlogstorepb.BatchFallocateReq.size)
  return _internal_size();
}
inline void BatchFallocateReq::_internal_set_size(int64_t value) {

  size_ = value;
}
inline void BatchFallocateReq::set_size(int64_t value) {
  _internal_set_size(value);
  // @@protoc_insertion_point(field_set:newlogstorepb.BatchFallocateReq.size)
}

// -------------------------------------------------------------------

// BatchFallocateResp

// int64 ret_code = 1;
inline void BatchFallocateResp::clear_ret_code() {
  ret_code_ = int64_t{0};
}
inline int64_t BatchFallocateResp::_internal_ret_code() const {
  return ret_code_;
}
inline int64_t BatchFallocateResp::ret_code() const {
  // @@protoc_insertion_point(field_get:newlogstorepb.BatchFallocateResp.ret_code)
  return _internal_ret_code();
}
inline void BatchFallocateResp::_internal_set_ret_code(int64_t value) {

  ret_code_ = value;
}
inline void BatchFallocateResp::set_ret_code(int64_t value) {
  _internal_set_ret_code(value);
  // @@protoc_insertion_point(field_set:newlogstorepb.BatchFallocateResp.ret_code)
}

// int32 err_no = 2;
inline void BatchFallocateResp::clear_err_no() {
  err_no_ = 0;
}
inline int32_t BatchFallocateResp::_internal_err_no() const {
  return err_no_;
}
inline int32_t BatchFallocateResp::err_no() const {
  // @@protoc_insertion_point(field_get:newlogstorepb.BatchFallocateResp.err_no)
  return _internal_err_no();
}
inline void BatchFallocateResp::_internal_set_err_no(int32_t value) {

  err_no_ = value;
}
inline void BatchFallocateResp::set_err_no(int32_t value) {
  _internal_set_err_no(value);
  // @@protoc_insertion_point(field_set:newlogstorepb.BatchFallocateResp.err_no)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace newlogstorepb

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_newlogstorepb_2eproto
